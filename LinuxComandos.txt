#### Guía de comandos en Linux by dM ####

################################################
### Probados en: Debian GNU/Linux 7 (wheezy) ###
################################################

Crtl + h // Mostrar archivos ocultos de un directorio, en el entorno grafico

cat /etc/issue.net  //Para saber la versión de SO que tenemos.  

!! // Repetir el ultimo comando ejecutado en consola

comando && comando && comando... // Ejecucion multiple de comandos

Ctrl + u // Cortar el contenido de la linea de comandos desde la posicion del cursor hasta el principio

Ctrl + k // Cortar el contenido de la linea de comandos desde la posicion del cursor hasta el final

Ctrl + t // Intercambiar de posicion las letras que estan a cada lado del cursor

Alt + d // Borrar palabra

lsb_release -a //También tenemos un comando que nos va a dar muchos más detalles 

uname // Muestra información del sistema

uname -a // Version de Kernel

uname -mrs // Saber mi version de Kernel especifica, recomendada

cat /etc/*-release // Ver info del sistema (Probado en Debian GNU/Linux 7 wheezy)

ifconfig // Siendo root, permite desplegar numerosos parámetros de las interfaces de red residentes  en el núcleo,
como la dirección IP (dinámica o estática), o la máscara de red entre otros.

nmap -sT -O localhost // Ver que puertos estan escuchando 

user@debian:/media$ umount nombre_device // Desmontar un dispositivo, pendrive, disco externo etc.

who // Muestra usuarios conectados a nuestra máquina, tambien usado para ver las conexiones entrantes de un servidor

Ejemplo:
user tty7         2015-07-28 08:47 (:0)
user pts/0        2015-07-30 14:03 (:0.0)
user pts/1        2015-07-30 17:03 (:0.0)
user pts/2        2015-07-31 14:15 (:0.0)
user pts/3        2015-07-31 12:37 (:0.0)

//En este caso son los usuarios conectados a mi máquina, eso quiere decir que tengo shells
abiertos, por lo tanto todos son representados como usuarios, entre los diversos parametros
se puede apreciar la fecha y la hora en que se abrio el shell, en un servidor seria
el momento en que se conecto el usuario

whoami // Muestra que usuario soy, nombre de usuario

who am i // Nos dira cual usuario somos, si navegamos por los shells abiertos y ejecutamos el comando nos dira cual usuario es

who -u //Ver usuarios conectados

// Ejemplo:

user tty7         2015-07-28 08:47  antig       4257 (:0)
user pts/0        2015-07-30 14:03 03:22        8351 (:0.0)
user pts/1        2015-07-30 17:03 03:19        8351 (:0.0)
user pts/2        2015-07-31 14:15 00:08        8351 (:0.0)
user pts/3        2015-07-31 12:37 02:53        8351 (:192.168.0.240)

//Aqui observamos que hay una conexion externa a traves de ssh a nuestro servidor proveniente de la maquina
(192.168.0.240) demarcada por el id process 8351 la cual podemos cancelar, es decir refusar esa conexion con
kill -9 8351

last // listar los ultimos usuarios conectados

clear // Limpia la pantalla

date // Muestra la fecha

man nombre_comando  // Muestra el manual de una comando donde como: ls, grep, aptitude etc...

cal // Muestra un calendario

pwd // Muestra la ruta en la que te encuentras

ls // Muestra lo que hay en la carpeta en la que te encuentras

ls -l // Muestra los archivos, fecha, permisos, etc

ls -la // Muestra los archivos, los ocultos tambien, fecha, permisos, etc

ls -1 // Muestra los archivos en forma de lista

ls *.xxx // Listar todos los ficheros de un directorio que tengan las extension .xxx, donde xxx puede ser: txt, html, php, css, etc.

ls -R // Listar los directorios y subdirectorios asi como ficehros de un directorio.

\du // Para ver la lista de carpetas y sub carpetas, los directorios que existen 
dentro de donde se encuentre situado

cd // Cambiar de directorio

cd .. // retroceder un directorio

cd ../../ // Retroceder dos directorios (../) representa un directorio

mkdir // Crear carpeta

&& // El operador '&&' sirver para continuar con la ejecucion de comadnos en el shell, ejemplo:

$ mkdir carpetaFFF && cd carpetaFFF // Creamos una carpetaFFF y luego entramos en la carpeta creada
,&& nos permite poner varias instrucciones en una sola linea del shell, otro ejemplo:

$ mkdir carpetaZZZ && cd carpetaZZZ && touch archivo.txt // Creamos una carpeta, entramos en ella y creamos un archivo
en ese directorio en una sola instruccion.

touch Nombre_Fichero // Crear fichero

nano nombre_fichero // Modificar un fichero con el editor nano.

man nano // Leer el manual del editor de textos nano, muy útil, práctico y fácil de usar

cat nombre_fichero // Mostrar contenido de un fichero

less nombre_fichero // Mostrar el contenido de un archivo, mayor movilidad que cat.

stat nombre_fichero // Muestra el estado e información de un fichero

stat nombre_carpeta // Muestra información de un directorio

Ctrl + D // En el shell, cerrar sesion, salir del root, de maquinas virtuales o de sesiones de usuarios iniciadas

Ctrl + flecha derecha o izquierda // Moverse en el prompt palabra a palabra, no letra por letra.

Ctrl + w // Borrar la palabra que esta antes del cursor en el shell

top  // Listar los procesos de ejecución del sistema (y más cosas) en tiempo real, es una de las herramientas más importantes para un administrador.

// Cada proceso tiene un identificador (PID) proccess ID, entonces podemos matar ese proceso con:

kill -9 xxxx // Matar un proceso donde xxxx es el identificador del proceso.

ps // Muestra los procesos actuales del sistema y acepta varios parametros como:

ps -e // Visualiza información sobre "todos" los procesos del sistema.

ps -l // Muestra algunos detalles de los procesos del sistema

ps l //  Muestra mas detalles de los procesos del sistema.

poweroff // Apagar la maquina, se debe ser root para ejecutarlo.

reboot // Reiniciar la maquina.

file xxx // donde xxx es el nombre de un fichero, nos dira el tipo de fichero que es.
    Ejemplo: file index.html
    index.html: HTML document, UTF-8 Unicode text

file * // Nos dira el tipo de archivo de todos los ficheros del directorio

diff /home/user/file.html /home/user/file2.html // Permite hacer una comparacion de dos archivos para apreciar sus diferencias
se debe especificar la ruta de ambos archivos y separarlos con un espacio, si estan en el mismo directorio no hace
falta especificar las rutas completas.

df // Muestra el espacio disponible del disco y demas dispositivos asi como el espacio usado

free // Muestra el estado de la memoria RAM, total, usado, disponible, cached, buffers 

vmstat // Muestra el estado de la memoria virtual

pstree // Muestra los procesos del sistema en forma de arbol

gnome-screenshot // Captura de pantalla del escritorio

pdfimages fichero.pdf nombre_imagene // Extrae las imagenes de un .pdf

du // Muestra una lista de los directorios y el espacio que ocupan en el disco

du * // Muestra todos directorios y ficheros y el espacio que ocupan en el disco

ping xxx // Donde xxx es el nombre de un host al cual enviaremos paquetes y comprobaremos si hay una conexion con ese host, util para saber si estamos conectados a internet por ejemplo:
    ping http://www.google.com.ve // Si hay conexion a internet enviara paquetes que seran recibidos, de lo contrario dara un error.

glxgears // Siendo root, Ver si hay aceleracion grafica en la maquina, muestra unos engranajes de colores rodando, si es así, está correcta la instalacion del video.

xrandr // Detectar las resoluciones de pantalla disponibles del sistema así como los hz correspondientes, la que
tenga (*) es la que está siendo usada.

adduser nombre_de_usuario // Como root, Agregar un usuario nuevo al sistema, una nueva sesion, nos pedira agregar el 
nombre de usuario y asignarle contraseña, la clave de root es la misma para todas las sesiones.

su nombre_de_usuario // Conectarse como otro usuario creado

userdel -r nombre_usuario // Como root, eliminar el usuario creado

deluser --remove-home nombre_usuario // Otra forma de eliminar un usuario creado

rename 's/\.txt/\.xls/' *.txt  //Cambiar extension a todos los ficheros de un directorio
//En el ejemplo vamos a sustituir los .txt por .xls y le decimos que se lo haga a todos los .txt

##########################
########## Less ##########
##########################

// less es un visualizador de archivos de texto que funciona en intérpretes de comando.
// A diferencia de otros programas similares (como more), less permite una completa navegación
// por el contenido del archivo, utilizando un mínino de recursos del sistema.

***** Comandos basicos *****

man less // Manual de less

AvPag // Avanzar una página

RePag // Retroceder una página

space // Tecla espacio para avanzar, como page up

:q // Salir

:h // Ayuda

:/palabra // (/) Buscamos una palabra dentro del documento
// (n) para ir a la siguiente coincidencia.
// (N) para ir a la coincidencia anterior

:G // Ir al final del texto

:g // Ir al inicio del texto

:v //Invocar un editor de texto para el documento, por lo general usa vi pero puede usar nano automaticamente

**********

cp // Copiar un fichero o carpeta

cp -r // Copiar un fichero o carpeta

cp Nombre_de_archivo.txt /Carpeta/destino/a/copiar // Copiar un fichero en un directorio
se debe estar situado en la carpeta del archivo a copiar

cp Nombre_carpeta -r /Carpeta/destino/a/copiar // Copiar un directorio en otro, 
se debe estar situado en la carpeta de la carpeta a copiar

cp -r /home/usuario/carpeta1/ /home/usuario/carpeta2/ //Se pueden copiar archivos o carpetas especificando las
rutas completas, en este caso la primera ruta es el directorio o archivo a copiar y la segunda es la ruta donde
se va a pegar lo copiado, ambas rutas separadas por un espacio en blanco.

cp -r carpeta/ carpeta2/ // Ambas carpetas estan en el mismo directorio donde estamos situados, por lo tanto
no hay que especificar las rutas completas de las carpetas involucradas

cp nombre_fichero.xxx nombre_fichero2.xxx // Hacer una copia de un fichero y cambiarle el nombre.

cp -r carpeta1 carpeta2 // Hacer una copia de un directorio y cambiarle el nombre.

mv // Mover un fichero o carpeta y/o cambiar su nombre

mv /home/carpeta/archivo1.txt /home/carpeta2/ // Mover una carpeta o archivo especificando el directorio
de salida y el de llegada, si estan en el mismo directorio no hace falta poner las rutas completas.

mv archivo1.txt archivo2.txt // Renombrar un archivo o carpeta 

rmdir // Borrar una carpeta

rm nombre_fichero // Borrar un fichero

rm fichero1 fichero2 fichero3 // Borrar varios ficheros

rm -r /directorio // Para borrar una carpeta, se le da la ruta del directorio a borrar

rm * // Borrar todos el contenido de una carpeta, se debe estar dentro del directorio

rm -r * // Borrar todo el contenido de una carpeta, incluyendo las carpetas de ese directorio
se debe estar dentro del directorio

sudo rm -rf /xxx/xxxx // rm: Comando "remove", eliminar. -rf: r de "recursivo" donde se borra todo y f de "force";
nunca solicita confirmación. /xxx/xxx indica la ruta de los ficehros o carpetas a borrar.

sudo -i // Pedir contraseña root, algunas versiones basadas en Debian

su // Pedir contraseña del root

root@debian:/home/user# Ctrl + d //Para salir del root, tambien exit, funciona en algunas consolas como python, ruby, entre otras.

Ctrl + r // En la consola, para hacer una busqueda de comandos usados baasndose en la palabra que se introduzca

Shift + Page up <--> Page down // Moverse a traves de los logs de la consola, simula el scroll up/down del mouse

####################################
##### Editor de texto VI o VIM #####
####################################

// Es un editor de texto poderoso, muy usado en la comunidad de desarrolladores de Software Libre para escribir scripts, modificar ficheros
de texto en el shell, programar etc. No posee botones y todas sus funcionalidades se usan a traves de comandos.
Por lo general viene preinstalado en la mayoria de distribuciones, si no es así solo basta con un:

apt-get install vim // con apt-get

aptitude install vim // con aptitude

----------------

--- Modos de uso ---

// Al entrar a VIM para editar un fichero por primera vez, estamos en modo de comandos, quiere decir que no podemos editar el texto
sino que solo podremos usar comandos.

vim // Abrir vim, un fichero en blanco sin nombre ni contenido

i // Tecleamos i para entrar en modo de edicion, podemos insertar texto

escape // Pulsamos la tecla escape para salir del modo edicion o de cualquier otro modo, y volvemos al modo comandos.

:q // En modo comandos escribimos :q para salir del editor sin guardar

:q! // Salir del editor sin guardar ni pedir confirmacion

:w nombre_fichero.xxx //Guardamos un fichero nuevo, le asignamos el nombre y la extension si es necesario.

vim nombre_archivo.xxx // Nos aparecerá una ventana en negro, donde nos aparecerá el contenido del fichero o en negro si está vacío
// En la parte inferior, nos aparecerán los mensajes o comandos que escribamos para manejar el editor, así como la línea en la que estamos, porcentaje del fichero, etc.

:w // Guardar un documento

:wq! // Guardar y salir, esta accion aplica a un fichero ya creado, que estemos editando.

:f // Para saber el nombre y extensión del fichero abierto.

u // Deshacer el ultimo cambio

Ctrl + R // Rehacer el ultimo cambio

yy // Copiar la linea

dd // Eliminar una linea, en tal caso la corta y esta lista para pegarse

p // Pegar una linea cortada

guu // Convertir la linea actual en minusculas

gUU // Convertir la linea actual en mayusculas

g // Ir al principio del archivo

G // Ir al final del documento

w // navegar palabra por palabra en el fichero

:/palabra // Para hacer una busqueda de una palabra dentro del archivo
n // Para ir a la siguiente coincidencia.
N // Para ir a la coincidencia anterior

:123 // Ir a la linea (x) donde 123 es el número de linea a la cual queremos ir.

:syntax on // Sirve para dar color al codigo que estemos editando, VIM reconoce la sintaxis de muchos lenguajes y
la resalta en colores como muchos otros editores graficos como gedit, sublime, ninja, komodo, Geany.

En /etc/vim en el fichero vimrc descomentamos la linea 
"syntax on // Quitamos las (") para que quede activado directamente la coloracion de codigos

##############################################
########## Cambiar el pass del root ##########
##############################################

su: ****** // Acceder como root
passwd // Nos pedira que introduzcamos la nueva contraseña y la confirmacion para cambiar la clave de root

root@debian:/home/user# passwd
Introduzca la nueva contraseña de UNIX: ****** 
Vuelva a escribir la nueva contraseña de UNIX: ***** 
passwd: contraseña actualizada correctamente
root@debian:/home/user#

#########################################################
########## Instalacion de programas y paquetes ##########
#########################################################

sudo apt-get install Nombre_Paquete // Instalar paquetes

sudo aptitude install Nombre_Paquete // Instalar paquetes, otra forma

aptitude install -s Nombre_Paquete // Hace una simulacion de la instalacion, podemos ver que procesos haría la instalación

apt-get install -s Nombre_Paquete // Simulacion de instalacion con  apt-get install

sudo aptitude search Nombre_Paquete // Realizar una busqueda en los repositorios del paquete que se quiere encontrar

aptitude show Nombre_Paguete // Para ver la informacion del paquete, version, estado, tamaño, conflictos, etc.

aptitude remove Nombre_paquete // Elimina o Desinstala el paquete

aptitude purge Nombre_Paquete //Elimina el paquete y sus archivos de configuracion

aptitude download nombre_paquete // Descargar el paquete en el directorio

aptitude reinstall nombre_paquete // Reinstalar un paquete

####################################################
##### Saber la version instalada de un paquete #####
####################################################

xxx --version // Saber la version de algun paquete que tengamos instalado.

Ejemplo:
    bash --version
    gcc --version
    python --version
    ruby --version


#####################################################
########## Comprimir/Descomprimir archivos ##########
#####################################################

paquete.tar
paquete.tar.gz

tar -cvf paquete.tar carpeta/ // Le damos los parametros de compresion, asi como el nombre del paquete
y la carpeta que vamos a comprimir

-c : indica a tar que cree un archivo
-x : extraer un archivo
-t : listar los contenidos de un archivo
-v : indica a tar que muestre lo que va empaquetando.
-f : indica a tar que el siguiente argumento es el nombre del fichero.tar
-z : comprimir a la vez que se empaqueta

tar -cvf paquete.tar archivo.txt // Creara un paquete con el nombre que le dimos y contiene el archivo.txt 

tar -xvf paquete.tar // Descomprimir un paquete

--- Descomprimir archivo .tar.bz2 ---
tar -xjvf example.tar.bz2

--- Descomprimir archivo.rar ---
//Necesitamos instalar unrar
aptitude search unrar

Si no lo encuentra debemos bajar el source de http://www.unrarlib.org/
Nos bajara unrarsrc-3.7.8.tar.gz // Descomprimimos, nos dejara la carpeta (unrar)
luego: 
$ cd unrar
$ make -f makefile.unix
$ install -v -m755 unrar /usr/bin // Como root

// Ya deberíamos poder descomprimir .rar

Uso: unrar [OPTION...] ARCHIVE [FILE...] [DESTINATION]
-x, --extract              Extract files from archive (default)
-t, --list                 List files in archive
-f, --force                Overwrite files when extracting
    --extract-newer        Only extract newer files from the archive
    --extract-no-paths     Don't create directories while extracting
-p, --password             Decrypt archive using a password
-?, --help                 Give this help list
    --usage                Give a short usage message
-V, --version              Print program version

ejemplo:
$ unrar x archivo.rar // Para descomprimir un fichero .rar
$ unrar x archivo.rar /home/user/carpeta // Para descomprimir un fichero .rar dando la ruta


--- Descomprimir archivo.zip ---

unzip archivo.zip // Descomprimir el fichero

#####################################
########## Instalar APACHE ##########
#####################################

$ sudo apt-get install apache2 // Instalar servidor apache, 127.0.0.1 o LocalHost es para iniciarlo

/var/www/ // Es la carpeta de donde podemos guardar nuestros proyectos, ficheros etc 
puesto que es la carpeta por defecto de Apache para ese fin.

$ chmod -R 777 /var/www/ // Cambiar los permisos de /var/www puesto que solo tiene permisos root, 
-R para que los permisos se hagan de forma recursiva, esto se hace porque al pegar ficheros
o carpetas estas no tiene los permisos de lectura/escritura necesarios.

sudo aptitude search php // Realizar una búsqueda en los repositorios del paquete que se quiere encontrar

http://192.xxx.xx.xxx/ //La direccion ip sirve para acceder al directorio del servidor

127.0.0.1:80 // Apache cuando está en ejecucion siempre está escuchando por el puerto 80
por lo que si visitamos 127.0.0.1:80 accederemos al servicio

Sus archivos e configuracion están en etc/apache2

$ sudo service apache2 restart // Restart apache para guardar los cambios

###############################################
########## Instalar y configurar PHP ##########
###############################################

apt-get install php5 php5-mysql php5-gd libapache2-mod-php5

// Una vez que se hayan descargado e instalado los paquetes de PHP, solo tienes que reiniciar el 
servidor Apache para que el servicio esté disponible. Para hacerlo solo tienes que teclear los siguientes comandos:

/etc/init.d/apache2 restart

// Para probar que tu servicio esta trabajando puedes crear un pequeño archivo y verlo en tu navegador.
// Para hacer esto puedes teclear los siguientes comandos:

nano /var/www/testphp.php

// agrega las lineas siguientes

<?php
// Muestra toda la información, por defecto INFO_ALL
phpinfo();
?>

Para ver este archivo abre tu navegador web y teclea la IP de tu servidor seguido del archivo que acabas de crear, por ejemplo:

http://127.0.0.1/testphp.php //Si aparece la pagina azul pastel de PHP se instalo correctamente

######################################################
########## Instalar y configurar phpMyAdmin ##########
######################################################

aptitude install phpmyadmin // Instalar

http://localhost/phpmyadmin // Acceder al servicio

***After the installation has completed, add phpmyadmin to the apache configuration.**

# sudo nano /etc/apache2/apache2.conf //Agregar en este archivo la configuracion de abajo

***Add the phpmyadmin config to the file.

Include /etc/phpmyadmin/apache.conf //Esta linea se agrega al final de la configuracion del apache para que reconozca el phpMyAdmin

/etc/init.d/xxx restart // xxx mysql, apache etc... restart


###########################################
########## Instalar MySQL server ##########
###########################################

apt-get install mysql-server

root@debian:/home/user# aptitude search mysql | grep mysql

# mysql -p //acceder al mysql

########################################################################################
##### Comandos para hacer busquedas en los directorios y en el historial del shell #####
########################################################################################

history // Mostrar el historial de los comandos de la consola

fc -l // Mostrar los ultimos comandos usados por el usuario

history | grep xxx // Busqueda especifica de una comando usado, ejemplo: aptitude, alias, grep etc.

.bash_history // En los archivos ocultos del home, en este fichero se almacena el historial de los comandos usados

grep --color=always -n "mysql" /var/www/prueba/2/datos.php // --color para colorear la palabra a buscar, 
-n para listar la la linea del caracter buscado y al final ra ruta del archivo a buscar

grep cadena_texto ./* -rIn //Busca la cadena de manera recursiva en la carpeta en que se encuentre situado

grep --color=always -n "cadena_texto" ./* -Ir //Busca la cadena de manera recursiva en la carpeta en que se encuentre situado

grep --color -n "cadena_texto" -Ir // No hace falta poner =always

egrep -r "Saludo" . //Otra forma de busqueda.

| grep xxx // filtra la busqueda con el parametro que le demos ejemplo:

aptitude search python | grep 2.7 // Busca las versiones de python que coincidan con el patron 2.7

ps -e | grep ruby // Busca en los procesos del sistema las coincidencias con ruby

whereis python // Para saber donde esta instalado un programa, saber el directorio
whereis firefox
whereis apache2

su:
find / -type f -name NombreArchivo.html // Para mostrar el directorio del archivo que se 
//quiera buscar, se debe saber el nombre del archivo

locate nombre_del_archivo // Hacer una busqueda de un archivo en los directorios, se puede especificar un nombre con su extensión
//o solo especificar una palabra, la busqueda se hara en todos los archivos que contengan la palabra o nombre de archivo escrita.

su: *****
find / -name nombre_carpeta // (/) es para hacer la busqueda desde ahi en adelante, puede ser (/home/user)

find /carpeta // Lista los archivos que componen el directorio introducido

type nombre_comando // Busca la ruta donde se encuentra el comando, ejemplo: aptitude, python, etc.

which nombre_programa // Buscar la ruta de un programa

----------

wget -r www.host.com //descargar el contenido de una web, los archivos del directorio
wget -r www.programador-de-software.blogspot.com

######################################################
####### GIT - Software de Control de Versiones #######
######################################################

// Software de control de versiones diseñado por Linus Torvalds, pensando en la eficiencia
y la confiabilidad del mantenimiento de versiones de aplicaciones cuando éstas tienen un gran número de
archivos de código fuente. Hay algunos proyectos de mucha relevancia que ya usan Git
en particular, el grupo de programación del núcleo Linux.

aptitude install git // fast, scalable, distributed revision control system 

git // Con este comando nos listara la lista de comandos Git que podemos usar en un proyecto

git --version // Para saber que version tenemos instalada.

//Lo primero que debemos hacer despues de la instalacion es configurar nuestro Git

git config --global user.name "Argenis Osorio" // Asignamos el nombre de usuario que será la firma del usuario en cada commit

git config --global user.email aosorio@example.com // igualmente el correo que siempre acompañara al autor de cada commit

git init // Crear un directorio, dentro del directorio ejecutar
para crear un nuevo repositorio de git.

git status -s // Lista los archivos del proyecto y se visualiza si fueron agregados al seguimiento de Git.
//Tambien podemos ver si un archivo fue modificado y no a sido agregado al seguimiento de Git

git add * // Para agregar todos los archivos al seguimiento

git status // Muestra el estado actual de la rama, como los cambios que hay sin commitear.

git status -s // Muestra el estado de los archivos del proyecto, si estan sin agregar o fueron modificados

git branch // Lista todas las ramas locales.

git branch -a // Lista todas las ramas locales y remotas.

A  gris.jpg // Agregado
A  principal.html // Agregado
AM principal2.html // Agregado y modificado, se debe agregar otra ver para aceptar los cambios
?? principal3.html // Archivo agregado al directorio pero no agregado al seguimiento de Git

git add Nombre_archivo.xxx // Agregamos el archivo al seguimiento de Git

git rm Nombre_ficehro // Borrar un fichero de manera segura, puesto que lo borra del directorio y del seguimiento de git, es un error
común borrar los archivos directamente y estos siguen estando en el seguimiento de git por lo que se lia bastantes veces
al subir los cambios, recomendable borrarlos desde git.

git rm -f Nombre_ficehro // para forzar el borrado.

git rm --cached Nombre_archivo.xxx // Si un archivo fue modificado queda un registro de su nombre anterior en el cache
para borrarlo se esa este comando

git commit -m "Primer commit del proyecto" //Hacer un commit al proyecto, se activara la rama master

git log // Podemos ver todos los commits que se han hehco a un proyecto

git commit --amend -m "comentario commit corregido" // Corregir algun error en el texto del ultimo commit

git commit --amend // Correguir un error en el commit, abrira un editor de texto

git reset --hard HEAD~1 // Borrar el ultimo commit hecho.

git checkout -b Nombre_Rama // Crear una rama y cambiarse a ella.

git branch -d Nombre_Rama // Borrar una rama, se debe estar en otra rama para borrarla

git branch -D Nombre_Branch // Forzar el borrado de una rama, a veces no se dejan borrar si hay cambios sin guardar.

git checkout Nombre_Rama // Cambiarse de rama

git branch -v // Para ver los ultimos commits de cada rama.

git checkout XXXXXX123456 // Este comando sirve para moverse entre los commits, cada commit genera una
etiqueta hash, un identificador muy largo alfanumerico, estas etiquetas identifican una version del proyecto
lo que permite restaurar el proyecto a estados anteriores donde XXXXXX123456 representa la etiqueta del commit al que queremos ir.

//Una vez movidos a ese commit especifico del historial se puede crear una nueva rama desde ese punto, si hacemos git log nos mostrara
los commits que habian hasta ese momento y el ultimo es en el que nos encontramos, si queremos volver a tener los commits anteriores 
solo hacemos git checkout a la rama en que estabamos antes o a alguna rama especifica.

git diff // Si se hacen cambios o se agregaron archivos al proyecto este comando nos hará mostrara una comparacion entre los
ultimos cambios hechos el ultimo commit hecho, es recomendable revisar esos cambios antes de agregarlos al seguimiento de git
y por supuesto antes de hacer un commit.

---------

//Luego de hacer el commit en la rama master y luego de haber creado la rama desarrollo y hacer el commit
se pueden listar los commits de las ramas existentes y asi poder realizar comparacaiones entre las
diferentes versiones del codigo. En este caso se agregaron 2 lineas al <div id="cabecera"> de una plantilla del proyecto
//Usando los identificadores de cada commit se pueden comparar las versiones del software.

$ git branch -v
* desarrollo e6dcbf4 Modificacion de texto de la cabecera
  master     a537ef5 Primer commit
user@debian:~/DIV$ git diff a537ef5 e6dcbf4
diff --git a/principal.html b/principal.html
index 554fd4f..94b3eac 100755
--- a/principal.html
+++ b/principal.html
@@ -14,6 +14,8 @@
 
                <div id="cabecera">
                        CabeceraXXX
+                       CabeceraXXX
+                       CabeceraXXX
                </div>  
 
                <div id="cuerpo1">


git clone /home/directorio/proyecto/ //Crea una copia local del repositorio se debe situar en la carpeta
donde se quiere hacer la copia y luego se le da la ruta del proyecto a copiar 

git clone https://xxx.xxx.gob.ve/xxx/xxx/xxx.git // Si esta subido en algun servidor 

---Recomendado---

*Cada desarrollador o equipo de desarrollo puede hacer uso de Git de la forma que le parezca
 conveniente. Sin embargo una buena práctica es la siguiente:

Se deben utilizar 4 tipos de ramas: Master, Development, Features, y Hotfix.

-Master: Es la rama principal. Contiene el repositorio que se encuentra publicado
en producción, por lo que debe estar siempre estable.

-Development: Es una rama sacada de master. Es la rama de integración, todas las nuevas
funcionalidades se deben integrar en esta rama. Luego que se realice la integración y se
 corrijan los errores (en caso de haber alguno), es decir que la rama se encuentre estable,
 se puede hacer un merge de development sobre la rama master.

-Features: Cada nueva funcionalidad se debe realizar en una rama nueva, específica para
esa funcionalidad. Estas se deben sacar de development. Una vez que la funcionalidad
esté pronta, se hace un merge de la rama sobre development, donde
se integrará con las demás funcionalidades.

-Hotfix: Son bugs que surgen en producción, por lo que se deben arreglar y publicar
de forma urgente. Es por ello, que son ramas sacadas de master. Una vez corregido
el error, se debe hacer un merge de la rama sobre master. Al final, para que no
quede desactualizada, se debe realizar el merge de master sobre development.

#############################################
######### Subir proyectos a GitHub ##########
#############################################

// Repositorio: Un repositorio, depósito o archivo es un sitio centralizado donde
se almacena y mantiene información digital, habitualmente bases de datos o archivos informáticos.

1- Crearnos una cuenta en GitHub
2- Crear un repositorio, ese repo tendra una URL asignada, ejem: https://github.com/name_user/name_repo
3- Una forma rapida de subir un proyecto de git es bajando ese repositorio creado, clonandolo en nuestro directorio,
al clonarlo ya viene configurado con los ficheros de git lo que nos permitira hacer push directamente sin hacer mayores
configuraciones.

git clone https://github.com/name_user/name_repo.git // Clonamos el repositorio del proyecto

cd name_repo/ //Nos cambiamos a la carpeta del proyecto

4- Una vez hecho es veremos una carpeta local con el nombre de nuestro repositorio de Github
esta carpeta estará vacía porque aun no hemos puesto nada. Ahora puedes meter dentro todos los archivos
nuestro proyecto y cuando los tengas todos dentro puedes ejecutar estos comandos:

git add . // Para agregar todos los archivos nuevos

git commit -m "Comentario" // Hacemos el primer commit del proyecto, ejemplo: "Primer commit" o "Caga inicial"

git push origin master // Este comando es para subir el proyecto directamente al repo de nuestra cuenta en 
github, cabe mencionar que en el directorio .git descargado, en el archivo config estará por defecto
escrita la URL de nuestro repo lo que facilita subir los proyectos y los cambios directamente, por ello 
el paso de la clonacion del repo.

// Antes de subir los cambios nos pedira el user y pass de la cuenta github para realizar la autenticacion
user@debian:~/GuiasLenguajes$ git push origin master
Username for 'https://github.com': user
Password for 'https://user@github.com': *****
Counting objects: 14, done.
Delta compression using up to 4 threads.
Compressing objects: 100% (13/13), done.
Writing objects: 100% (13/13), 45.99 KiB, done.
Total 13 (delta 0), reused 0 (delta 0)
To https://github.com/user/proyecto.git
   af47064..228246e  master -> master

//Listo ya deberias porder ver tu proyecto en github

git push origin --delete your_branch //Eliminar una rama en tu Github o en tu repositorio remoto.

git push origin :your_branch // Eliminar una rama, alternativa al anterior.

git push origin +master // Para borrar o deshacer un commit en github, se debe primero borrar el commit 
de manera local, luego volvemos a subir el proyecto con este comando para que quede como estaba.

#########################################
########## Terminal Terminator ##########
#########################################

//Gran herramienta para los desarrolladores, permite abrir multiples terminales
y poder ordenarlos, muy personalizable, entre muchas otras cosas. **RECOMENDADO**

Paquete: terminator / multiple GNOME terminals in one window

aptitude install terminator // Para instalarlo
apt-get install terminator

Dentro de Terminator:
Ctrl + Shift + o // Abrir un terminal horizontal y paralelo
Ctrl + Shift + e // Abrir un terminal vertical y paralelo
Alt + flechas // Moverse por los terminales
Ctrl + Shift + w // Cerrar un terminal
Ctrl + Shift + x // Maximizar un terminal, igual para salir
Ctrl + Shift + z // Maximizar un terminal(aumentado), igual para salir
Ctrl + Shift + flechas // Cambiar el tamaño a voluntad de un terminal
Ctrl + (+) // Aumentar tamaño de fuente, el (+) del Qwerty
Ctrl + (-) // Minimizar tamaño de fuente, el (-) del Qwerty 
Ctrl + d // Si no hay sesion de usuario abierta, como root y otros cerrará la pestaña o ventana.

-----------------

################################################
########## Ambiente virtual en Python ##########
################################################

// Cuando se desarrollando software con Python, quizas se presente el problema de tener utilizar diferentes versiones de una mismo paquete en
diferentes proyectos, ya sea el mismo Python o diferentes versiones de un Framework como Django por ejemplo, el problema a solucionar radica
en como poder instalar las dos o mas versiones de la misma librería con el fin de poder desarrollar varios proyectos de forma simultánea.

La solución consiste en crear virtualenvs o entornos virtuales. Un entorno virtual de Python es un espacio completamente independiente
de otros entornos virtuales y de los paquetes instalados globalmente en el sistema. Esto significa que es posible instalar la versión
2.7 de Python en un entorno virtual y la versión 3.0 en otro diferente o de forma global sin problema alguno.

El porder tener diferentes entornos donde podemos instalar diferentes versiones de paquetes nos da la oportunidad de hacer un desarrollo simultaneo
así como poder hacer pruebas si afectar a los paquetes del sistema global.

--- Instalación: ---

$ aptitude install python-virtualenv virtualenvwrapper // Para crear un ambiente virtual instale las herramientas
python-virtualenv y virtualenvwrapper

$ mkvirtualenv nombre_ambiente_virtual //  Con un usuario (diferente a root) cree un ambiente virtual para su proyecto.

$ workon nombre_ambiente_virtual // Para acceder al nombre del ambiente virtual creado

ejemplo: 
user@debian:/home$ workon proyecto // Accedemos al entorno virtual creado
(proyecto)user@debian:/home$ // Ya estamos en el entorno virtual creado, denotado por el nombre del entorno al inicio del prompt

$ deactivate nombre_ambiente_virtual // Para salir del entorno virtaul, o simplemente deactivate

$ lsvirtualenv // Para listar los entornos virtuales creados o disponibles.

$ rmvirtualenv nombre_virtualenv // Remover o borrar un entorno virtual.

// Los entornos virtuales se crean en el directorio /home/user/.virtualenvs

########################
##### Paquetes PIP #####
########################

// Para desarrollar software con rapidez y calidad, es imprescindible utilizar paquetes externos que ayuden
con parte de la funcionalidad que se desea implementar. En el ambiente Python esto no es la excepción.

// Para solventar ésta necesidad, la comunidad Python ha puesto convenientemente a disposición de los desarrolladores
un repositorio de paquetes de fácil acceso llamado PyPi. Solo es necesario ejecutar un comando en la terminal
para poder instalar el paquete Python que necesitemos. Incluso es posible instalar paquetes que no se encuentren
en el mencionado repositorio.

// Para descargar paquetes del repositorio PyPi se pueden utilizar varias herramientas, pero en este caso se
va a usar pip. Es necesario instalar esta herramienta en el sistema en caso de no estar disponible, antes
de poder instalar un paquete Python.

// El comando pip equivale al apt-get de Debian pero para paquetes Python.

$ aptitude install python−pip python−dev python-setuptools // Instalamos PIP y otros necesarios

// Una vez instalado ya podremos instalar paquetes de Python a traves de pip ejemplo:

$ pip install django // Nos instalara la ultima version de Django disponible en los paquetes pi

// Tambien es posible crear ficheros que contengan rutinas para automatizar la instalacion
de varios paquetes ejemplo:

Creamos un requirements.txt y dentro escribimos como ejemplo:
django==1.5.12
pillow==2.4.0
Geraldo==0.4.17

// Luego podemos ejecutar un pip install sobre el fichero e instalará lo que contenga:

pip install -r requirements.txt

// Dentro de los .virtualenvs, dentro de nuestro entorno virtual en
lib/python2.7/site-packages podemos ver que se instalaron los paquetes de requirements.txt
de no ser así hay que revisar el fichero o el nombre de los paquetes a instalar, etc.

$ pip search nombre_paquete // Buscar un paquete.

#############################################
########## Conexion remota con SSH ##########
#############################################

SSH (Secure SHell) es el nombre de un protocolo y del programa que lo implementa, y sirve para acceder
a máquinas remotas a través de una red. Permite manejar por completo la computadora mediante un intérprete
de comandos, y también puede redirigir el tráfico de X para poder ejecutar programas gráficos si tenemos ejecutando un Servidor X (en sistemas Unix y Windows).

Además de la conexión a otros dispositivos, SSH nos permite copiar datos de forma segura
(tanto archivos sueltos como simular sesiones FTP cifradas), gestionar claves RSA para no escribir
claves al conectar a los dispositivos y pasar los datos de cualquier otra aplicación por un canal seguro tunelizado mediante SSH.

ssh Nombre_usuario@IP_servidor o nombre_servidor

ssh user@192.168.0.240 // Asi se accede a un ordenador o servidor remoto, debemos poner el usuario que debe estar creado asi como la ip
del server, nos pedira la clave de session, una vez adentro tenemos acceso a los archivos y podemos pedir el root para tener acceso total.
ssh es muy usado por administradores de redes y de sistemas para acceder a las maquinas que arrojan los servidores y hacer cambios asi 
como monitorear los proyectos que esten ejecutando, especialmente en maquinas virtuales si varios proyectos corren en un mismo servidor.

echo "mensaje" > /dev/pts/2 // Enviar mensaje a traves del shell, se debe especificar 
el usuario, se puede hacer localmente para probar, enviando mensajes entre dos shells
abiertos. con (who) veremos la identificacion de cada shell.


--- COPIAR ARCHIVOS DE LOCAL A SERVIDOR ---
Si queremos subir el archivo archivo.txt de nuestro ordenador a la carpeta /home/usuario del servidor, hacemos lo siguiente:

$ scp archivo.txt usuario@dominio.com:/home/usuario // Se especifica el archivo a copia, luego el servidor y luego el directorio 
en el servidor donde copiaremos el archivo

--- COPIAR ARCHIVOS DE SERVIDOR A LOCAL ---
Si queremos copiar el fichero archivo.txt del servidor a nuestro ordenador en la carpeta Documentos, hacemos lo siguiente:

$ scp usuario@dominio.com:/home/usuario/archivo.txt /home/usuario/Documentos // Especificamos el servidor, luego la ruta y el archivo a copiar y luego el directorio local donde sera copiado el archivo.

--- COPIAR ARCHIVOS DE SERVIDOR A SERVIDOR ---

$ scp usuario1@dominio1.com:/home/usuario1/archivo.txt usuario2@dominio2.com:/home/usuario2/

--- COPIAR UN DIRECTORIO COMPLETO ---
Para copiar un directorio completo de mi ordenador al servidor, por ejemplo /home/mario/carpeta a /home/usuario, añadimos un -r en el comando:

$ scp -r /home/mario/carpeta usuario@dominio.com:/home/usuario

######################################################
########## Programación Shell-Script (bash) ##########
######################################################

Bash (y otros shells) permiten programar scripts
--Bash (Bourne again shell) es un programa informático cuya función consiste en interpretar órdenes.
Está basado en la shell de Unix.

Script o programa shell: Fichero de texto conteniendo comandos externos e internos
que se ejecutan línea por línea, el programa puede contener, además de comandos
variables, constructores lógicos (if...then, AND, OR, etc.) y lazos (while, for, etc.)
funciones comentarios

-- Ejecución de un script --

Los scripts deben empezar por el simbolo #! seguido del programa a usar para interpretar el script:

#!/bin/bash // Script de bash
#!/bin/sh // Script de shell
#!/usr/bin/perl // Script de perl

----------------------------

#Ejemplo de programa en bash para imprimir valores de variables
#!/bin/bash
VAL=10
VAL2=20
echo $VAL
echo $VAL2

----------------------------

Guardamos el script, ejemplo: prueba.sh, no es necesario ponerle
la extensión ya que la cabecera del script especifíca que programa
lo interpretará

Ejecución:

sh prueba.sh // Ejecutar un programa con bash.

sh prueba // Ejecutar un programa con bash, script guardado sin extension.

#################
##### RSYNC #####
#################

Es una aplicación que ofrece transmisión eficiente de datos, que opera también con datos comprimidos y cifrados.
Mediante una técnica de delta encoding, permite sincronizar archivos y directorios entre dos máquinas de una red
o entre dos ubicaciones en una misma máquina, minimizando el volumen de datos transferidos.
Muy recomendable para hacer respaldos en discos externos.

aptitude install rsync // Instalarlo desde los repositorios de debian

Parametros: -P para mostrar el progreso de la copia y -r cuando se van a copiar directorios

rsync -P ficehero /directorio/carpeta2 // Para copiar ficheros, archivos, etc. 

rsync -P -r /directorio/carpeta1 /directorio/carpeta2 // -r para copiar directorios
se ponen las dos rutas: origen y destino separados por un espacio.

##################################
##### Crear alias de comandos #####
##################################

Un alias es una palabra o frase que se asignara para 
remplazar un comando, por lo generalmente se usa para
remplazar comandos muy largos y dificiles de recordar
por lo que es una gran ventaja la creacion de alias.

Un alias Se pueden crear temporalmente, directamente en la consola
y durara hasta que cerremos ese shell, tambien asignar permanentemente
escribiendolo en el archivo .bashrc que esta en el /home 

$ alias nombre_alias='comando'

Ejemplo:
$ alias sa='aptitude search apache | grep rt4' // (sa) ahora es el alias de 
ese comando de busqueda en los repositorios de un paquete especifico.

$ unalias nombre_alias // Para eliminar el alias creado temporalmente

// Para que se haga efectivo algun cambio en .bashrc es necesario reiniciar
pero hay otra forma de actualizar el fichero sin reiniciar, entonces:

$ source .bashrc // Bastara para que se apliquen los cambios hechos

// Mensaje de bienvenida al usuario

Pegamos esto al final del .bashrc, reiniciamos el fichero
y ahora cada vez que iniciemos un shell nos saludará.

## Mensaje al iniciar
echo "Hola Usuario"

########################################################
### Saber la direccion ip de una pagina o un sevidor ###
########################################################

user@debian:~$ nslookup google.com // Saber la de google por ejemplo
Non-authoritative answer:
Name:   google.com
Address: 216.58.192.110 // Direccion ip de google

--- Otra forma ---

$ ping google.com // Haciendo ping al una pagina 
PING google.com (216.58.192.110) 56(84) bytes of data.
64 bytes from mia07s35-in-f14.1e100.net (216.58.192.110): icmp_req=1 ttl=49 time=69.6 ms // Ip de google
64 bytes from mia07s35-in-f14.1e100.net (216.58.192.110): icmp_req=2 ttl=49 time=70.4 ms

--- google.com ping statistics ---
3 packets transmitted, 2 received, 33% packet loss, time 2001ms
rtt min/avg/max/mdev = 69.645665/70.00475/470.48645/0.010 ms

########################################
##### Compilar e instalar paquetes #####
########################################

$ aptitude search build-essential // Este paquete es esencial para crear y manejar paquetes debian,
por consiguiente para la creación, compilacion e instalación de programas en debian, ubuntu etc.
Tambien se instala cuando se va a desarrollar con c y c++ puesto que la instalacion incluye
los compiladores y las librerias necesarias para comenzar a trabajar en estos lenguajes.

Descargámos el código fuente del programa que queremos compilar e instalar.
Normalmente lo encontraremos en un archivo comprimido, con extensión tar.bz2. 
Así que tendrás que descomprimirlo escribiendo en la consola:

$ tar xvzf paquete.tar.gz (o ver sección de Comprimir/Descomprimir archivos arriba)

//Ahora vamos al directorio donde hemos extraído el contenido del paquete:
$ cd path_del_paquete

// Confguramos el modo de compilación con:
./configure

Luego escribimos:
make

Y finalmente, instalamos con:
make install

// Si no hay errores ya deberíamos poder usar el programa instalado.

#################################
### DIA - Editor de diagramas ###
#################################

Es un editor de diagramas, grafos, gráficas, etc. Ofrece soporte para diagramas de estructuras
estáticas en UML (diagramas de clases), diagramas de  Entidad-Relación, diagramas de redes y mucho más.
Los diagramas se pueden exportar a postscript y a otros formatos.

$ aptitude install dia

################
##### Meld #####
################

Es una herramienta gráfica para hacer archivos diff y fusionarlos.
Permite al usuario ver los cambios entre, y fusionar, dos archivos, dos directorios, o dos archivos con un ancestro común.

$ aptitude install meld

########################################
##### Cambiar permisos de usuarios #####
########################################

Al ver los permisos de los ficehros o directorios nos encontramos con varios parametros:

En la primera columna se pueden ver una serie de letras y guiones (-rwxr-x---)
estas letras nos dicen quien en el sistema, y que clases de permisos tiene el fichero o carpeta.

Estas letras están agrupadas en tres grupos con tres posiciones cada uno
más una primera posición que nos dice de que clase de archivo se trata
(los mas normales (d) directorios, o (-) archivos de datos).

El primer grupo de tres (rwx en nuestro caso) nos dice que clase de permisos tiene el dueño del fichero (u)(user/owner)
El segundo grupo de tres (r-x en nuestro caso) nos dice que clase de permisos tiene el grupo del fichero (g)(group).
Y el último grupo de tres (--- en nuestro caso) nos dice que clase de permisos tienen todos los demás usuarios del sistema sobre este
fichero (o)(others).

r :significa permiso para leer 
w :significa permiso para escribir  
x :significa permiso para ejecutar

u :permisos para el usuario/dueño del fichero/directorio
g :permisos de grupos
o :permisos de los demás usuarios

Los permisos se pueden especificar de diferentes maneras, una serie de ejemplos, es lo mejor para comprenderlo:

chmod ugo+rwx test (da permisos rwx a todos, user,group,others)
chmod ugo-x test (quita permiso x (ejecucion) a todos, user,group,others) 
chmod o-rwx test (quita permisos rwx a others) 
chmod u=rwx,g=rx test (da permisos rwx a user, rx a group y ninguno a others)

chmod -R u=rwx,g=rx,o=rx /dir/dir2/dir3 // Ejemplo de como otorgar permisos a un directorio específico.

################################################
##### CCLive - Descargar videos de youtube #####
################################################

CCLive es una aplicación que nos permite descargar un vídeo que esté en YouTube
hacia nuestro ordenador mediante un simple comando. Por defecto guarda los vídeos en webm.

$ aptitude show cclive //Para ver si lo tenemos en los repos, y ver la descripción, si es así.

$ aptitude install cclive // Instalación, como root.

ó

$ sudo apt-get install cclive // Instalación, como root.

$ cclive https://www.youtube.com/watch?v=yWVrvce5R9 // Descargar un video pasando la url de youtube.

$ cclive URL1 URL2 URL3 URL4 // Soporta varias URLs a la vez, para bajar mas de 1 video.

$ cclive < urls.txt // Descargar un vídeo detrás de otro, desde un archivo de texto plano con todas las URLs (en líneas diferentes).

$ man cclive // Manual del paquete.

$ cclive -F https://www.youtube.com/watch?v=Lfj667lLLnE // Comprobar los formatos disponibles antes de descargar el video.
// Se podrá ver un listado de formatos disponibles separados por "|"

$ cclive -f fmt22_720p https://www.youtube.com/watch?v=LtzFg4JiL5E // Se elige el formato y se pasa en el comando.


##############
### Otros: ###
##############

$ export GIT_SSL_NO_VERIFY=True // Si un repostirotio git remoto no cuenta con el certificado
digital del servidor a veces se debe saltar chequeo de la firma para bajar las fuentes con este comando

~ // Para sacarlo usar AvPag en la consola
