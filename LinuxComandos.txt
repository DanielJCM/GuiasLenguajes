##### Guía de comandos en Linux by dM #####

###################################################################################
##### Probados en: Debian GNU/Linux 7 (wheezy) y algunos en Debian 8 (Jessie) #####
###################################################################################

Crtl + h // Mostrar archivos ocultos de un directorio, en el entorno grafico

$ cat /etc/issue.net  //Para saber la versión de SO que tenemos.

$ cat /etc/issue  //Para saber la versión de SO que tenemos.

!! // Repetir el ultimo comando ejecutado en consola

~ // Para sacarlo usar AvPag en la consola

comando && comando && comando... // Ejecucion multiple de comandos

Ctrl + u // Cortar el contenido de la linea de comandos desde la posicion del cursor hasta el principio

Ctrl + k // Cortar el contenido de la linea de comandos desde la posicion del cursor hasta el final

Ctrl + t // Intercambiar de posicion las letras que estan a cada lado del cursor

Alt + d // Borrar palabra

$ lsb_release -a //También tenemos un comando que nos va a dar muchos más detalles 

$ uname // Muestra información del sistema

$ uname -a // Version de Kernel

$ uname -mrs // Saber mi version de Kernel especifica, recomendada

$ cat /etc/*-release // Ver info del sistema (Probado en Debian GNU/Linux 7 wheezy)

$ ifconfig // Siendo root, permite desplegar numerosos parámetros de las interfaces de red residentes  en el núcleo,
como la dirección ip (dinámica o estática), o la máscara de red entre otros.

$ apt-get moo // Huevo de pascua, muestra una vaca.

--- ip publica ---

Una forma de averigar esa IP pública es haciendo uso del comando curl. Si no tenéis instalado el paquete habrá que instalarlo,

$ sudo apt-get install curl

$ curl ifconfig.me // Nos mostrará nuestra ip pública.

$ nmap -sT -O localhost // Ver que puertos estan escuchando 

$ user@debian:/media$ umount nombre_device // Desmontar un dispositivo, pendrive, disco externo etc.

$ who // Muestra usuarios conectados a nuestra máquina, tambien usado para ver las conexiones entrantes de un servidor

Ejemplo:
user tty7         2015-07-28 08:47 (:0)
user pts/0        2015-07-30 14:03 (:0.0)
user pts/1        2015-07-30 17:03 (:0.0)
user pts/2        2015-07-31 14:15 (:0.0)
user pts/3        2015-07-31 12:37 (:0.0)

//En este caso son los usuarios conectados a mi máquina, eso quiere decir que tengo shells
abiertos, por lo tanto todos son representados como usuarios, entre los diversos parametros
se puede apreciar la fecha y la hora en que se abrio el shell, en un servidor seria
el momento en que se conecto el usuario

$ whoami // Muestra que usuario soy, nombre de usuario

$ who am i // Nos dira cual usuario somos, si navegamos por los shells abiertos y ejecutamos el comando nos dira cual usuario es

$ who -u //Ver usuarios conectados

// Ejemplo:

user tty7         2015-07-28 08:47  antig       4257 (:0)
user pts/0        2015-07-30 14:03 03:22        8351 (:0.0)
user pts/1        2015-07-30 17:03 03:19        8351 (:0.0)
user pts/2        2015-07-31 14:15 00:08        8351 (:0.0)
user pts/3        2015-07-31 12:37 02:53        8351 (:192.168.0.240)

//Aqui observamos que hay una conexion externa a traves de ssh a nuestro servidor proveniente de la maquina
(192.168.0.240) demarcada por el id process 8351 la cual podemos cancelar, pero no refusar esa conexion, el usuario seguirá conectado por ssh.
$ kill -9 8351

# pkill -9 -t pts/3 // Acabar con una conexión externa, se envió la señal -9 que indica matar (KILL) el proceso, la opción -t indica que se basará
en un atributo de nombre de terminal y se indica después el nombre de la terminal en si pts/3. Este es el comando que sí funciona para 
refusar conexiones externas.

$ last // listar los ultimos usuarios conectados

$ clear // Limpia la pantalla

$ date // Muestra la fecha

$ man nombre_comando  // Muestra el manual de una comando donde como: ls, grep, aptitude etc...

// Dentro de los manuales podemos presionar "h" para ver las opciones tenemos del manual, ejemplo "/delete"
para hacer una busqueda de la cadena "delete" dentro del manual.

$ cal // Muestra un calendario

$ pwd // Muestra la ruta en la que te encuentras

$ ls // Muestra lo que hay en la carpeta en la que te encuentras

$ ls -l // Muestra los archivos, fecha, permisos, etc

$ ls -lh // Muestra los archivos, fecha, permisos, y el peso pero en kb,mg o gb según sea el caso.

$ ls -la // Muestra los archivos, los ocultos tambien, fecha, permisos, etc

$ ls -1 // Muestra los archivos en forma de lista

$ ls *.xxx // Listar todos los ficheros de un directorio que tengan las extension .xxx, donde xxx puede ser: txt, html, php, css, etc.
ejemplo: ls *.txt

$ ls -R // Listar los directorios y subdirectorios asi como ficehros de un directorio.

$ \du // Para ver la lista de carpetas y sub carpetas, los directorios que existen 
dentro de donde se encuentre situado

$ cd // Cambiar de directorio, nos lleva al home del usuario.

$ cd 'nombre carpeta' // Acceder a un directorio que tiene espacios en el nombre.

-- Si una carpeta se llama (a b c d e), para aceder a ella usamos:

$ cd a\ b\ c\ d\ e/ // Al final siempre lleva el / normal, los otros usan el invertido.

$ cd .. // retroceder un directorio

$ cd ../../ // Retroceder dos directorios (../) representa un directorio

$ mkdir // Crear carpeta

&& // El operador '&&' sirver para continuar con la ejecucion de comadnos en el shell, ejemplo:

$ mkdir carpetaFFF && cd carpetaFFF // Creamos una carpetaFFF y luego entramos en la carpeta creada
,&& nos permite poner varias instrucciones en una sola linea del shell, otro ejemplo:

$ mkdir carpetaZZZ && cd carpetaZZZ && touch archivo.txt // Creamos una carpeta, entramos en ella y creamos un archivo
en ese directorio en una sola instruccion.

$ touch Nombre_Fichero // Crear fichero

$ nano nombre_fichero // Modificar un fichero con el editor nano.

$ man nano // Leer el manual del editor de textos nano, muy útil, práctico y fácil de usar

$ cat nombre_fichero.xxx // Mostrar contenido de un fichero, concatenate files and print on the standard output.

$ cat -b nombre_fichero.xxx // Mostrar contenido de un fichero y numerar las líneas.

$ less nombre_fichero.xxx // Mostrar el contenido de un archivo, lector de ficheros, mayor movilidad que cat, con / permite buscar dentro
del fichero, como vim, q para salir.

$ tail nombre_fichero.xxx // El comando tail sirve para mostrar en pantalla las últimas líneas de un archivo.

$ tail -n X nombre_fichero.xxx // -n donde X es el número de lineas que queremos ver del fichero.

$ tail -c X nombre_fichero.xxx // -n donde X es el número caracteres desde el final, que queremos ver del fichero.

$ tail fichero_1.xxx fichero_2.xxx // Se pueden especificar 1 o más ficheros a la vez, los mostrara en el orden declarado.

$ stat nombre_fichero // Muestra el estado e información de un fichero

$ stat nombre_carpeta // Muestra información de un directorio

Ctrl + D // En el shell, cerrar sesion, salir del root, de maquinas virtuales o de sesiones de usuarios iniciadas

Ctrl + flecha derecha o izquierda // Moverse en el prompt palabra a palabra, no letra por letra.

Ctrl + w // Borrar la palabra que esta antes del cursor en el shell

$ top  // Listar los procesos de ejecución del sistema (y más cosas) en tiempo real, es una de las herramientas más importantes para un administrador.

// Cada proceso tiene un identificador (PID) proccess ID, entonces podemos matar ese proceso con:

$ kill -9 xxxx // Matar un proceso donde xxxx es el identificador del proceso.

$ ps // Muestra los procesos actuales del sistema y acepta varios parametros como:

$ ps -e // Visualiza información sobre "todos" los procesos del sistema.

$ ps -ef // Visualiza información sobre "todos" los procesos del sistema con mas detalles, así pues se puede detener un procello con kill -9 PID_number.

$ ps -l // Muestra algunos detalles de los procesos del sistema

$ ps l //  Muestra mas detalles de los procesos del sistema.

$ poweroff // Apagar la maquina, se debe ser root para ejecutarlo.

$ reboot // Reiniciar la maquina.

$ file xxx // donde xxx es el nombre de un fichero, nos dira el tipo de fichero que es.
    Ejemplo: file index.html
    index.html: HTML document, UTF-8 Unicode text

$ file * // Nos dira el tipo de archivo de todos los ficheros del directorio

$ diff /home/user/file.html /home/user/file2.html // Permite hacer una comparacion de dos archivos para apreciar sus diferencias
se debe especificar la ruta de ambos archivos y separarlos con un espacio, si estan en el mismo directorio no hace
falta especificar las rutas completas.

$ df // Muestra el espacio disponible del disco y demas dispositivos asi como el espacio usado

$ df -h // Muestra el espacio disponible del disco y demas dispositivos asi como el espacio usado, pero en mg o gb según sea el caso.

# fdisk -l // Ver informacion de los discos duros, particiones y dispositivos montados en el sistema.

$ lsusb // Este comando muestra todos los puertos USB y los detalles acerca de los dispositivos conectados a ellos.

$ lspci // Lista todos los componentes tipo pci (Peripheral Component Interconnec) como las tarjetas de red, de sonido o de televisión.

$ free // Muestra el estado de la memoria RAM, total, usado, disponible, cached, buffers 

$ vmstat // Muestra el estado de la memoria virtual

$ pstree // Muestra los procesos del sistema en forma de arbol

$ gnome-screenshot // Captura de pantalla del escritorio

$ pdfimages fichero.pdf nombre_imagene // Extrae las imagenes de un .pdf

$ du // Muestra una lista de los directorios y el espacio que ocupan en el disco

$ du * // Muestra todos directorios y ficheros y el espacio que ocupan en el disco

$ ping xxx // Donde xxx es el nombre de un host al cual enviaremos paquetes y comprobaremos si hay una conexion con ese host, util para saber si estamos conectados a internet por ejemplo:
    ping http://www.google.com.ve // Si hay conexion a internet enviara paquetes que seran recibidos, de lo contrario dara un error.

$ glxgears // Siendo root, Ver si hay aceleracion grafica en la maquina, muestra unos engranajes de colores rodando, si es así, está correcta la instalacion del video.

$ xrandr // Detectar las resoluciones de pantalla disponibles del sistema así como los hz correspondientes, la que
tenga (*) es la que está siendo usada.

$ adduser nombre_de_usuario // Como root, Agregar un usuario nuevo al sistema, una nueva sesion, nos pedira agregar el 
nombre de usuario y asignarle contraseña, la clave de root es la misma para todas las sesiones.

$ su nombre_de_usuario // Conectarse como otro usuario creado

$ userdel -r nombre_usuario // Como root, eliminar el usuario creado

$ deluser --remove-home nombre_usuario // Otra forma de eliminar un usuario creado

$ rename 's/\.txt/\.xls/' *.txt  //Cambiar extension a todos los ficheros de un directorio
//En el ejemplo vamos a sustituir los .txt por .xls y le decimos que se lo haga a todos los .txt

################
##### Less #####
################

// less es un visualizador de archivos de texto que funciona en intérpretes de comando.
// A diferencia de otros programas similares (como more), less permite una completa navegación
// por el contenido del archivo, utilizando un mínino de recursos del sistema.

***** Comandos basicos *****

man less // Manual de less

AvPag // Avanzar una página

RePag // Retroceder una página

space // Tecla espacio para avanzar, como page up

:q // Salir

:h // Ayuda

:/palabra // (/) Buscamos una palabra dentro del documento
// (n) para ir a la siguiente coincidencia.
// (N) para ir a la coincidencia anterior

:G // Ir al final del texto

:g // Ir al inicio del texto

:v //Invocar un editor de texto para el documento, por lo general usa vi pero puede usar nano automaticamente

########################################################
##### Comandos para copiar, mover, eliminar, otros #####
########################################################

cp // Copiar un fichero o carpeta

cp -r // Copiar un fichero o carpeta

cp Nombre_de_archivo.txt /Carpeta/destino/a/copiar // Copiar un fichero en un directorio
se debe estar situado en la carpeta del archivo a copiar

cp Nombre_carpeta -r /Carpeta/destino/a/copiar // Copiar un directorio en otro, 
se debe estar situado en la carpeta de la carpeta a copiar

cp -r /home/usuario/carpeta1/ /home/usuario/carpeta2/ //Se pueden copiar archivos o carpetas especificando las
rutas completas, en este caso la primera ruta es el directorio o archivo a copiar y la segunda es la ruta donde
se va a pegar lo copiado, ambas rutas separadas por un espacio en blanco.

cp -r carpeta/ carpeta2/ // Ambas carpetas estan en el mismo directorio donde estamos situados, por lo tanto
no hay que especificar las rutas completas de las carpetas involucradas

cp nombre_fichero.xxx nombre_fichero2.xxx // Hacer una copia de un fichero y cambiarle el nombre.

cp -r carpeta1 carpeta2 // Hacer una copia de un directorio y cambiarle el nombre.

mv // Mover un fichero o carpeta y/o cambiar su nombre

mv /home/carpeta/archivo1.txt /home/carpeta2/ // Mover una carpeta o archivo especificando el directorio
de salida y el de llegada, si estan en el mismo directorio no hace falta poner las rutas completas.

mv archivo1.txt archivo2.txt // Renombrar un archivo o carpeta 

rmdir // Borrar una carpeta

rm nombre_fichero // Borrar un fichero

rm fichero1 fichero2 fichero3 // Borrar varios ficheros

rm -r /directorio // Para borrar una carpeta, se le da la ruta del directorio a borrar

rm * // Borrar todos el contenido de una carpeta, se debe estar dentro del directorio

rm -r * // Borrar todo el contenido de una carpeta, incluyendo las carpetas de ese directorio
se debe estar dentro del directorio

sudo rm -rf /xxx/xxxx // rm: Comando "remove", eliminar. -rf: r de "recursivo" donde se borra todo y f de "force";
nunca solicita confirmación. /xxx/xxx indica la ruta de los ficehros o carpetas a borrar.

sudo -i // Pedir contraseña root, algunas versiones basadas en Debian

su // Pedir contraseña del root

root@debian:/home/user# Ctrl + d //Para salir del root, tambien exit, funciona en algunas consolas como python, ruby, entre otras.

Ctrl + r // En la consola, para hacer una busqueda de comandos usados baasndose en la palabra que se introduzca

Shift + Page up <--> Page down // Moverse a traves de los logs de la consola, simula el scroll up/down del mouse

####################################
##### Editor de texto VI o VIM #####
####################################

// Es un editor de texto poderoso, muy usado en la comunidad de desarrolladores de Software Libre para escribir scripts, modificar ficheros
de texto en el shell, programar etc. No posee botones y todas sus funcionalidades se usan a traves de comandos.
Por lo general viene preinstalado en la mayoria de distribuciones, si no es así solo basta con un:

# apt-get install vim // con apt-get

# aptitude install vim // con aptitude

----------------

--- Modos de uso ---

// Al entrar a VIM para editar un fichero por primera vez, estamos en modo de comandos, quiere decir que no podemos editar el texto
sino que solo podremos usar comandos.

vim // Abrir vim, un fichero en blanco sin nombre ni contenido

i // Tecleamos i para entrar en modo de edicion, podemos insertar texto

escape // Pulsamos la tecla escape para salir del modo edicion o de cualquier otro modo, y volvemos al modo comandos.

:q // En modo comandos escribimos :q para salir del editor sin guardar

:q! // Salir del editor sin guardar ni pedir confirmacion

:w nombre_fichero.xxx //Guardamos un fichero nuevo, le asignamos el nombre y la extension si es necesario.

vim nombre_archivo.xxx // Nos aparecerá una ventana en negro, donde nos aparecerá el contenido del fichero o en negro si está vacío
// En la parte inferior, nos aparecerán los mensajes o comandos que escribamos para manejar el editor, así como la línea en la que estamos, porcentaje del fichero, etc.

:w // Guardar un documento

:wq! // Guardar y salir, esta accion aplica a un fichero ya creado, que estemos editando.

:f // Para saber el nombre y extensión del fichero abierto.

u // Deshacer el ultimo cambio

Ctrl + R // Rehacer el ultimo cambio

yy // Copiar la linea

dd // Eliminar una linea, en tal caso la corta y esta lista para pegarse

p // Pegar una linea cortada

guu // Convertir la linea actual en minusculas

gUU // Convertir la linea actual en mayusculas

g // Ir al principio del archivo

G // Ir al final del documento

w // navegar palabra por palabra en el fichero

:/palabra // Para hacer una busqueda de una palabra dentro del archivo
n // Para ir a la siguiente coincidencia.
N // Para ir a la coincidencia anterior

:123 // Ir a la linea (x) donde 123 es el número de linea a la cual queremos ir.

:syntax on // Sirve para dar color al codigo que estemos editando, VIM reconoce la sintaxis de muchos lenguajes y
la resalta en colores como muchos otros editores graficos como gedit, sublime, ninja, komodo, Geany.

En /etc/vim en el fichero vimrc descomentamos la linea 
"syntax on // Quitamos las (") para que quede activado directamente la coloracion de codigos

##############################################
########## Cambiar el pass del root ##########
##############################################

su: ****** // Acceder como root
passwd // Nos pedira que introduzcamos la nueva contraseña y la confirmacion para cambiar la clave de root

root@debian:/home/user# passwd
Introduzca la nueva contraseña de UNIX: ****** 
Vuelva a escribir la nueva contraseña de UNIX: ***** 
passwd: contraseña actualizada correctamente
root@debian:/home/user#

#########################################################
########## Instalacion de programas y paquetes ##########
#########################################################

$ man aptitude // Ver el manual de aptitude.

$ man apt-get

# apt-get install Nombre_Paquete // Instalar paquetes

# aptitude install Nombre_Paquete // Instalar paquetes, otra forma

# apt-get build-dep Nombre_Paquete // Intentará satisfacer las dependencias de compilación de un paquete fuente, el comando build-dep
busca en los repositorios locales en el sistema e instala las dependencias de construcción para el paquete. Si el paquete no existe en
el repositorio local se devolverá un código de error.

$ aptitude install -s Nombre_Paquete // Hace una simulacion de la instalacion, podemos ver que procesos haría la instalación

$ apt-get install -s Nombre_Paquete // Simulacion de instalacion con  apt-get install

$ apt-get source Nombre_paquete // Descargar las fuentes del paquete, para compilar e instalar. 

$ sudo aptitude search Nombre_Paquete // Realizar una busqueda en los repositorios del paquete que se quiere encontrar

$ aptitude show Nombre_Paguete // Para ver la informacion del paquete, version, estado, tamaño, conflictos, dependencias, etc.

$ apt-cache show nombre_paquete // Ver informacion del paquete, version, dependencias, descripcion, tamaño, entre otros.

$ apt-cache search nombre_paquete // Buscar un paquete en los repositorios.

# aptitude remove Nombre_paquete // Elimina o Desinstala el paquete.

# aptitude purge Nombre_Paquete // Elimina el paquete y sus archivos de configuracion.

$ aptitude download nombre_paquete // Descarga el fichero .deb del paquete dado al directorio actual.

$ apt-get download nombre_paquete // Descarga el fichero .deb del paquete dado al directorio actual.

# aptitude reinstall nombre_paquete // Reinstalar un paquete

$ aptitude update // Actualizar la lista de paquetes disponibles.

$ dpkg -l | grep nombre_paquete // Saber si un paquete está instalado y su version.

####################################################
##### Saber la version instalada de un paquete #####
####################################################

xxx --version // Saber la version de algun paquete que tengamos instalado.

Ejemplo:
    bash --version
    gcc --version
    python --version
    ruby --version

#####################################################
########## Comprimir/Descomprimir archivos ##########
#####################################################

paquete.tar y paquete.tar.gz  // tar se refiere a un formato de archivos ampliamente usado en
entornos UNIX identificados por el sufijo de archivo .tar.. Además hace referencia al programa
para la manipulación de archivos que es estándar en estos entornos, pero no incluye la
compresión de los mismos.

tar -cvf paquete.tar directorio // Comprimir un directorio, le damos los parametros de compresion, asi como el nombre del paquete
y el directorio que vamos a comprimir.

-c : indica a tar que cree un archivo
-x : extraer un archivo
-t : listar los contenidos de un archivo
-v : indica a tar que muestre lo que va empaquetando.
-f : indica a tar que el siguiente argumento es el nombre del fichero.tar
-z : comprimir a la vez que se empaqueta

tar -cvf paquete.tar archivo.txt // Creara un paquete con el nombre que le dimos y contiene el archivo.txt 

tar -xvf paquete.tar // Descomprimir un paquete

Descomprimir paquetes.tar.bz2
tar -xjvf example.tar.bz2

Ficheros: .tar.gz:
Comprimir: $ tar -czvf paquete.tar.gz nombre_directorio
Comprimir: $ tar -czvf paquete.tar.gz nombre_fichero.xxx
Descomprimir: $ tar -xzvf paquete.tar.gz

Ficheros: .gz:
Comprimir: $ gzip -9 index.php
Descomprimir: $ gzip -d index.php.gz

Ficheros: .tar.xz
$ tar Jxvf fichero.tar.xz

-------------

Cuando nos iniciamos en Linux y buscamos un programa lo normal es que encontremos un .deb o .rpm y en muchos casos nos encontramos programas con
la extensión .tar.gz y .tar.bz2, estos archivos están comprimidos y por lo general contienen aparte del programa unas instrucciones para instalarlo.

La instalación para estos dos tipos de paquetes es exactamente igual, primero entramos a la carpeta donde tengamos el archivo.

$ cd directorio

$ tar -zxvf nombredelarchivo.tar.gz

$ tar -jxvf nombredelarchivo.tar.bz2

-Configuramos, con esta accion se configurara el paquete
para la posterior compilacion, si hacen falta paquetes "dependencias" para la compilacion
por lo general mostrara que paquetes faltan y fallará la configuracion.

$ ./configure

-Hacemos make (compilamos)

$ make

-Ahora make install

$ make install

################################
##### Descomprimir con RAR #####
################################

// Necesitamos instalar unrar

$ aptitude search unrar

Si no lo encuentra debemos bajar el source de http://www.unrarlib.org/
Nos bajara unrarsrc-3.7.8.tar.gz // Descomprimimos, nos dejara la carpeta (unrar)
luego: 
$ cd unrar
$ make -f makefile.unix
$ install -v -m755 unrar /usr/bin // Como root

// Ya deberíamos poder descomprimir .rar

Uso: unrar [OPTION...] ARCHIVE [FILE...] [DESTINATION]
-x, --extract              Extract files from archive (default)
-t, --list                 List files in archive
-f, --force                Overwrite files when extracting
    --extract-newer        Only extract newer files from the archive
    --extract-no-paths     Don't create directories while extracting
-p, --password             Decrypt archive using a password
-?, --help                 Give this help list
    --usage                Give a short usage message
-V, --version              Print program version

ejemplo:
$ unrar x archivo.rar // Para descomprimir un fichero .rar
$ unrar x archivo.rar /home/user/carpeta // Para descomprimir un fichero .rar dando la ruta

###########################################
##### Comprimir/ Descomprimir con ZIP #####
###########################################

$ sudo aptitude install zip // Instalar el paquete de zip

$ zip archivo.zip nombre_fichero.xxx

$ unzip archivo.zip // Descomprimir el fichero

$ zip -r carpeta.zip nombre_carpeta // Comprimir directorios y su contenido

#####################################
########## Instalar APACHE ##########
#####################################

$ sudo apt-get install apache2 // Instalar servidor apache, 127.0.0.1 o LocalHost es para iniciarlo

/var/www/ o /var/www/html // Es la carpeta de donde podemos guardar nuestros proyectos, ficheros etc 
puesto que es la carpeta por defecto de Apache para ese fin, varia según la version de Apache, probablemente
sea la segunda opción.

$ chmod -R 777 /var/www/html // Cambiar los permisos de /var/www puesto que solo tiene permisos root, 
-R para que los permisos se hagan de forma recursiva, esto se hace porque al pegar ficheros
o carpetas estas no tiene los permisos de lectura/escritura necesarios.

sudo aptitude search php // Realizar una búsqueda en los repositorios del paquete que se quiere encontrar

http://192.xxx.xx.xxx/ //La direccion ip sirve para acceder al directorio del servidor

127.0.0.1:80 // Apache cuando está en ejecucion siempre está escuchando por el puerto 80
por lo que si visitamos 127.0.0.1:80 accederemos al servicio

Sus archivos e configuracion están en etc/apache2

$ sudo service apache2 restart // Restart apache para guardar los cambios

###############################################
########## Instalar y configurar PHP ##########
###############################################

apt-get install php5 php5-mysql php5-gd libapache2-mod-php5

// Una vez que se hayan descargado e instalado los paquetes de PHP, solo tienes que reiniciar el 
servidor Apache para que el servicio esté disponible. Para hacerlo solo tienes que teclear los siguientes comandos:

/etc/init.d/apache2 restart

// Para probar que tu servicio esta trabajando puedes crear un pequeño archivo y verlo en tu navegador.
// Para hacer esto puedes teclear los siguientes comandos:

nano /var/www/testphp.php

// agrega las lineas siguientes

<?php
// Muestra toda la información, por defecto INFO_ALL
phpinfo();
?>

Para ver este archivo abre tu navegador web y teclea la IP de tu servidor seguido del archivo que acabas de crear, por ejemplo:

http://127.0.0.1/testphp.php //Si aparece la pagina azul pastel de PHP se instalo correctamente

######################################################
########## Instalar y configurar phpMyAdmin ##########
######################################################

aptitude install phpmyadmin // Instalar

http://localhost/phpmyadmin // Acceder al servicio

***After the installation has completed, add phpmyadmin to the apache configuration.**

# sudo nano /etc/apache2/apache2.conf //Agregar en este archivo la configuracion de abajo

***Add the phpmyadmin config to the file.

Include /etc/phpmyadmin/apache.conf //Esta linea se agrega al final de la configuracion del apache para que reconozca el phpMyAdmin

/etc/init.d/xxx restart // xxx mysql, apache etc... restart


###########################################
########## Instalar MySQL server ##########
###########################################

apt-get install mysql-server

root@debian:/home/user# aptitude search mysql | grep mysql

# mysql -p //acceder al mysql

#############################################################################
##### Comandos para buscar ficheros, directorios, paquetes, historiales #####
#############################################################################

$ history // Mostrar el historial de los comandos de la consola

$ fc -l // Mostrar los ultimos comandos usados por el usuario

$ history | grep xxx // Busqueda especifica de una comando usado, ejemplo: aptitude, alias, grep etc.

.bash_history // En los archivos ocultos del home, en este fichero se almacena el historial de los comandos usados

$ grep --color=always -n "mysql" /var/www/prueba/2/datos.php // --color para colorear la palabra a buscar, 
-n para listar la la linea del caracter buscado y al final ra ruta del archivo a buscar

$ grep cadena_texto ./* -rIn //Busca la cadena de manera recursiva en la carpeta en que se encuentre situado

$ grep --color=always -n "cadena_texto" ./* -Ir //Busca la cadena de manera recursiva en la carpeta en que se encuentre situado

$ grep --color -n "cadena_texto" -Ir // No hace falta poner =always

$ egrep -r "Saludo" . //Otra forma de busqueda.

| grep xxx // filtra la busqueda con el parametro que le demos ejemplo:

$ aptitude search python | grep 2.7 // Busca las versiones de python que coincidan con el patron 2.7

$ ps -e | grep ruby // Busca en los procesos del sistema las coincidencias con ruby

$ whereis python // Para saber donde esta instalado un programa, saber el directorio
$ whereis firefox
$ whereis apache2

su:
find / -type f -name NombreArchivo.html // Para mostrar el directorio del archivo que se 
//quiera buscar, se debe saber el nombre del archivo

$ locate nombre_del_archivo // Hacer una busqueda de un archivo en los directorios, se puede especificar un nombre con su extensión
//o solo especificar una palabra, la busqueda se hara en todos los archivos que contengan la palabra o nombre de archivo escrita.

$ locate "*.jpg" // Buscar todos los ficheros con la extension especificada

$ sudo locate -c hola // Muestra cuantos archivos contienen la palabra "hola" en el nombre.

$ sudo locate -i hola // Busca todos los archivos que contienen la palabra "hola" en el nombre tanto en mayúsculas como en minúsculas.

$ sudo locate nombre_archivo > /home/usuario/lista.txt // Para guardar el resultado de la búsqueda en un archivo de texto.

$ sudo find / -name nombre_carpeta // (/) es para hacer la busqueda desde ahi en adelante, puede ser (/home/user)

$ find /carpeta // Lista los archivos que componen el directorio introducido

$ type nombre_comando // Busca la ruta donde se encuentra el comando, ejemplo: aptitude, python, etc.

$ which nombre_programa // Buscar la ruta de un programa

$ sudo find / -name "*nombre_fichero*" // Buscar en todo el sistema los ficheros cuyo nombre contengan la expresion escrita.

$ sudo find / -name "*.xxx*" // Buscar en todo el sistema los ficheros cuyo nombre contengan la expresion escrita, en este caso,
una extensión de fichero, donde / puede ser /home/user etc y .xxx la extension: .jpg, .png, .txt, .py, etc.

$ sudo find /home/user ! -name "*xxx*" // Busca todos los archivos que NO contienen la palabra "xxx" en el nombre, se especifíca el directorio en el cual buscar.

$ sudo find /home/user -iname "*xxx*" // Busca todos los archivos que contienen la palabra "xxx" en el nombre tanto en mayúsculas como en minúsculas.

$ sudo find /home/user/ -iname "*xxx*" > /home/user/lista.txt // Si el resultado de la búsqueda anterior te ha proporcionado una gran cantidad de información, resulta
más cómodo almacenar el resultado de la búsqueda en un fichero de texto para revisarlo posteriormente.

# sudo find / -type f -name /home/user/fichero.c>>/home/user/x.txt // Crear un fichero (x.txt) que guardará la salida de la consola, en este caso
es una búsqueda, buscamos el fichero.c en el directorio user y guardaremos la salida del shell en el fichero x.txt que se creará.

########################################
##### wget para descargar ficheros #####
########################################

$ wget www.ejemplo_web.com // Descargar toda una página completa, wget no está limitado a solo descargas de archivos. Sitios completos pueden descargarse también.

$ wget -p www.ejemplo_web.com  // Lo mismo que lo anterior pero con esta opción -p descarga además todos los elementos extras necesarios de la página
como hojas de estilos, imágenes en línea, etc.

$ wget -c ftp://sunsite.doc.ic.ac.uk/ls-lR.Z // -c ó --continue, reanudar una descarga de wget si se detuvo por caída de red, cancelación de proceso, etc.

$ wget http://ejemplo.com/programa.tar.gz  ftp://otrositio.com/descargas/video.mpg // Indicar más de una descarga a la vez, incluso con distintos protocolos o extensiones

$ wget http://ejemplo.com/*.pdf // Descargar varios archivos, con extensión similar.

$ wget -i archivos.txt // Descargar varios archivos a traves de una lista.

Creamos una lista en archivos.txt que serán descargados:
http://ejemplo.com/programa.tar.gz
http://ejemplo.com/rpm/paquete.rpm
ftp://otrositio.com/descargas/distro.iso

$ wget -t 50 http://ejemplo.com/pelicula.mpg // Por defecto, wget realiza 20 intentos de establecer la conexión e iniciar la descarga, en sitios muy
saturados es posible que ni con 20 intentos se logré, con la opción -t (tries) aumenta a más intentos.

$ wget -r www.ejemplo.com // Con la opción -r se descarga recursivamente hasta 5 niveles del sitio.

$ wget --convert-links -r http://www.sitio.com/

ó

$ wget -k -r http://www.sitio.com/ // Por defecto, los enlaces dentro del sitio apuntan a la dirección del dominio completo. Si deseas descargar el sitio
recursivamente y después estudiarlo fuera de línea (off line) usa la opción convert-links que los convertirá en enlaces locales, apuntando a las páginas
dentro del sitio descargado.

$ wget --mirror http://ejemplo_web.com/    

ó

$ wget -m http://ejemplo_web.com/ // De este modo obtienes una copia (un espejo) completa del sitio.

#################
##### jigdo #####
#################

Jigsaw Download, o abreviadamente jigdo , se propone como la forma principal de distribuir imágenes de CD de Debian en el futuro. Actualmente, el sistema funciona, pero no es aún muy cómodo de usar porque la aplicación gestora de descargas no está terminada.

Página del paquete -> https://www.debian.org/CD/jigdo-cd/

# aptitude install jigdo-file

Aquí, por ejemplo, podemos buscar los .jigdo --> http://cdimage.debian.org/debian-cd/8.5.0/amd64/ en jigdo-dvd/

$ jigdo-lite http://cdimage.debian.org/debian-cd/8.5.0/amd64/jigdo-dvd/debian-8.5.0-amd64-DVD-1.jigdo

#########################################
########## Terminal Terminator ##########
#########################################

//Gran herramienta para los desarrolladores, permite abrir multiples terminales
y poder ordenarlos, muy personalizable, entre muchas otras cosas. **RECOMENDADO**

Paquete: terminator / multiple GNOME terminals in one window

aptitude install terminator // Para instalarlo
apt-get install terminator

Dentro de Terminator:
Ctrl + Shift + o // Abrir un terminal horizontal y paralelo
Ctrl + Shift + e // Abrir un terminal vertical y paralelo
Alt + flechas // Moverse por los terminales
Ctrl + Shift + w // Cerrar un terminal
Ctrl + Shift + x // Maximizar un terminal, igual para salir
Ctrl + Shift + z // Maximizar un terminal(aumentado), igual para salir
Ctrl + Shift + flechas // Cambiar el tamaño a voluntad de un terminal
Ctrl + (+) // Aumentar tamaño de fuente, el (+) del Qwerty
Ctrl + (-) // Minimizar tamaño de fuente, el (-) del Qwerty 
Ctrl + d // Si no hay sesion de usuario abierta, como root y otros cerrará la pestaña o ventana.

-----------------

################################################
########## Ambiente virtual en Python ##########
################################################

// Cuando se desarrollando software con Python, quizas se presente el problema de tener utilizar diferentes versiones de una mismo paquete en
diferentes proyectos, ya sea el mismo Python o diferentes versiones de un Framework como Django por ejemplo, el problema a solucionar radica
en como poder instalar las dos o mas versiones de la misma librería con el fin de poder desarrollar varios proyectos de forma simultánea.

La solución consiste en crear virtualenvs o entornos virtuales. Un entorno virtual de Python es un espacio completamente independiente
de otros entornos virtuales y de los paquetes instalados globalmente en el sistema. Esto significa que es posible instalar la versión
2.7 de Python en un entorno virtual y la versión 3.0 en otro diferente o de forma global sin problema alguno.

El porder tener diferentes entornos donde podemos instalar diferentes versiones de paquetes nos da la oportunidad de hacer un desarrollo simultaneo
así como poder hacer pruebas si afectar a los paquetes del sistema global.

--- Instalación: ---

Para crear un ambiente virtual instale las herramientas python-setuptools, python-dev, python-virtualenv, virtualenvwrapper

# aptitude install python-setuptools python-dev

# aptitude install python-virtualenv virtualenvwrapper

$ mkvirtualenv nombre_ambiente_virtual //  Con un usuario (diferente a root) cree un ambiente virtual para su proyecto.

$ workon nombre_ambiente_virtual // Para acceder al nombre del ambiente virtual creado

ejemplo: 
user@debian:/home$ workon proyecto // Accedemos al entorno virtual creado
(proyecto)user@debian:/home$ // Ya estamos en el entorno virtual creado, denotado por el nombre del entorno al inicio del prompt

$ deactivate nombre_ambiente_virtual // Para salir del entorno virtaul, o simplemente deactivate

$ lsvirtualenv // Para listar los entornos virtuales creados o disponibles.

$ rmvirtualenv nombre_virtualenv // Remover o borrar un entorno virtual.

// Los entornos virtuales se crean en el directorio /home/user/.virtualenvs

##### Usando virtualenv #####

Installation: Instala python-virtualenv.

-Crear un virtualenv:

$ virtualenv mi_env

-Activar el virtualenv:

$ source mi_env/bin/activate

-Instalar un paquete (p.ej. Django) en el virtualenv:

(mi_env)$ pip install django

-Trabajar en el proyecto.

-Salir del virtualenv:

(mi_env)$ deactivate

--- Using Python 3 in virtualenv ---

$ virtualenv -p python3 my_env

########################
##### Paquetes pip #####
########################

// Para desarrollar software con rapidez y calidad, es imprescindible utilizar paquetes externos que ayuden
con parte de la funcionalidad que se desea implementar. En el ambiente Python esto no es la excepción.

// Para solventar ésta necesidad, la comunidad Python ha puesto convenientemente a disposición de los desarrolladores
un repositorio de paquetes de fácil acceso llamado PyPi. Solo es necesario ejecutar un comando en la terminal
para poder instalar el paquete Python que necesitemos. Incluso es posible instalar paquetes que no se encuentren
en el mencionado repositorio.

// Para descargar paquetes del repositorio PyPi se pueden utilizar varias herramientas, pero en este caso se
va a usar pip. Es necesario instalar esta herramienta en el sistema en caso de no estar disponible, antes
de poder instalar un paquete Python.

// El comando pip equivale al apt-get de Debian pero para paquetes Python.

$ aptitude install python-pip python-dev python-setuptools python3-pip // Instalamos pip y otros necesarios, com python3 para pip, necesario en algunos proyectos.

// Una vez instalado ya podremos instalar paquetes de Python a traves de pip ejemplo:

$ pip install django // Nos instalara la ultima version de Django disponible en los paquetes pi

$ pip install django==1.7 // Instalar una versión específica de algun paquete.

// Tambien es posible crear ficheros que contengan rutinas para automatizar la instalacion
de varios paquetes ejemplo:

Creamos un requirements.txt y dentro escribimos como ejemplo:
django==1.5.12
pillow==2.4.0
Geraldo==0.4.17

// Luego podemos ejecutar un pip install sobre el fichero e instalará lo que contenga:

pip install -r requirements.txt

// Dentro de los .virtualenvs, dentro de nuestro entorno virtual en
lib/python2.7/site-packages podemos ver que se instalaron los paquetes de requirements.txt
de no ser así hay que revisar el fichero o el nombre de los paquetes a instalar, etc.

$ pip search nombre_paquete // Buscar un paquete.

$ pip uninstall package // Desinstalar un paquete.

#############################################
########## Conexion remota con ssh ##########
#############################################

# aptitude install ssh

--> configurarlo

# aptitude install openssh-server

SSH (Secure SHell) es el nombre de un protocolo y del programa que lo implementa, y sirve para acceder
a máquinas remotas a través de una red. Permite manejar por completo la computadora mediante un intérprete
de comandos, y también puede redirigir el tráfico de X para poder ejecutar programas gráficos si tenemos ejecutando un Servidor X (en sistemas Unix y Windows).

Además de la conexión a otros dispositivos, SSH nos permite copiar datos de forma segura
(tanto archivos sueltos como simular sesiones FTP cifradas), gestionar claves RSA para no escribir
claves al conectar a los dispositivos y pasar los datos de cualquier otra aplicación por un canal seguro tunelizado mediante SSH.

$ ssh Nombre_usuario@IP_servidor o nombre_servidor

ssh user@192.168.0.240 // Asi se accede a un ordenador o servidor remoto, debemos poner el usuario que debe estar creado asi como la ip
del server, nos pedira la clave de session, una vez adentro tenemos acceso a los archivos y podemos pedir el root para tener acceso total.
ssh es muy usado por administradores de redes y de sistemas para acceder a las maquinas y los servidores y hacer cambios asi 
como monitorear los procesos que esten ejecutando, especialmente en maquinas virtuales si varios proyectos corren en un mismo servidor.

Conectado al servidor, podemos enviar mensajes o abrir programas remotamente, ejemplo:

echo "mensaje" > /dev/pts/2 // Enviar mensaje a traves del shell a otro usuario, en el servidor o local, debe haber un shell abierto que sea receptor
Se puede hacer localmente para probar, con (who) veremos la identificacion de cada shell, si estamos conectados remotamente, comprobaremos si hay shells
abiertos en el local y el servidor, se identifican con los pts/0, pts/1, etc, y sabremos por la ip si son shells locales o del server  el mensaje sale en
el shell escogido.

$ export DISPLAY=:0.0 // Creamos la ventana virtual donde se abrira la aplicacion que ejecutemos, luego
$totem o $nautilus // Deberia abrir el programa en el servidor, ya esportada la ventana podemos:

DISPLAY=:0.0 totem // Abrir el reproductor totem en el servidor

DISPLAY=:0.0 nautilus // Abrir el explorador de archivos en el servidor

--- COPIAR ARCHIVOS DE LOCAL A SERVIDOR ---
Si queremos subir el archivo archivo.txt de nuestro ordenador a la carpeta /home/usuario del servidor, hacemos lo siguiente:

$ scp archivo.txt usuario@dominio.com:/home/usuario // Se especifica el archivo a copiar, luego el servidor y luego el directorio 
en el servidor donde copiaremos el archivo.

--- COPIAR ARCHIVOS DE SERVIDOR A LOCAL ---
Si queremos copiar el fichero archivo.txt del servidor a nuestro ordenador en la carpeta Documentos, hacemos lo siguiente:

$ scp usuario@dominio.com:/home/usuario/archivo.txt /home/usuario/Documentos // Especificamos el servidor, luego la ruta y el archivo a copiar y luego el directorio local donde sera copiado el archivo.

--- COPIAR ARCHIVOS DE SERVIDOR A SERVIDOR ---

$ scp usuario1@dominio1.com:/home/usuario1/archivo.txt usuario2@dominio2.com:/home/usuario2/

--- COPIAR UN DIRECTORIO COMPLETO DE LOCAL A SERVIDOR ---
Para copiar un directorio completo de mi ordenador al servidor, por ejemplo /home/mario/carpeta a /home/usuario, añadimos un -r en el comando:

$ scp -r /home/mario/carpeta usuario@dominio.com:/home/usuario

--- COPIAR UN DIRECTORIO COMPLETO DE SERVIDOR A LOCAL ---
Para copiar un directorio completo del servidor al local, por ejemplo /home/usuario/carpeta a /home/user/docs, añadimos un -r en el comando:

$ scp -r usuario@dominio.com:/home/usuario/carpeta /home/user/docs

####################################################################
##### Conexion por nautilus explorador de archivos/directorios #####
####################################################################

Usando el navegador de archivos de Debian, Ubuntu, etc, podemos acceder a ordenador remoto "servidor" para ver graficamente 
los directorios, es decir, desde nuestro navegador de archivos, navegaremos en los directorios del servidor, para acceder vamos a:

$ nautilus

Archivo > Conectar con el servidor // Nos saldrá una ventana para llenar con:

Servidor: 192.168.12.400 // Aqui va la ip del servidor
Puerto: 22 // El puerto que tiene habilitado el ssh_config
Tipo: SSH
Carpeta: /home // Carpeta que abrira al entrar en conexion
Nombre de usuario: // Nombre de usuario, de sesion de ese servidor
Contraseña: // Contraseña de la sesion de usuario del servidor

Si todo esta bien deberia entrar a explorar los directorios del servidor.

###########################################
##### X11 forwarding a través de ssh  #####
###########################################

X11, como supongo la mayoría de Uds. sabrá, es el servidor gráfico que usan casi todas las distribuciones Linux. Este servidor permite, entre otras cosas,
forwarding a través de SSH. Esto significa que es posible ejecutar apliaciones gráficas de una máquina remota exportando el display a nuestro escritorio.
Es decir, la aplicación se ejecuta en el servidor remoto, pero la interfaz gráfica la visualizamos en nuestro escritorio local.

Ejemplo:
1- En el servidor, editar el archivo /etc/ssh/ssh_config y modificar la opción X11Forwarding o ForwardX11 para que quede así:

X11Forwarding yes

ó

ForwardX11 yes

Luego de este cambio, posiblemente sea necesario reiniciar el demonio ssh. La forma de hacer esto varía de acuerdo a cada distribución Linux.
Lo más sencillo es reiniciar la máquina.

2- En el escritorio local, loguearse al servidor a través de ssh utilizando el parámetro -X:

$ ssh -X user@hostname

Donde user es el nombre de usuario utilizado para loguearse en el servidor y hostname es el ip o el alias del servidor.

3- Para ejecutar una aplicación, simplemente hay que hacerlo desde el terminal. Por ejemplo:

$ firefox

$ nautilus

$ evince

Cuando ejecutamos una aplicación gráficamente la consola se bloqueara con el proceso en ejecución, por lo que podemos usar &
para que se ejecute el proceso, construya el entorno grafico del programa y luego dezplace el proceso para poder seguir usando la
consola, ejemplo:

$ firefox

ó

$ firefox & nautilus &

#############################################
##### Programación shell-script (bash) ######
#############################################

--- ¿Qué es un "Script"? ---

Es un archivo que contiene código escrito en determinado lenguaje de programación que el sistema usa para determinada tarea.
No es necesario que tenga una entrada externa ni interfaz gráfica, pero sí que provoque una salida de datos procesados
(por más de que el usuario no los vea).

El lenguaje usado por Bash está definido por su propio intérprete y combina la sintaxis de otros Shells, como el Korn Shell (ksh) o el C Shell (csh).
Muchos de los comandos que usualmente se usan en la consola también pueden usarse en los scripts, salvo aquellos que pertenecen estrictamente a una
distribución en particular.

--- Estructura de un Script ---

Para empezar debemos contar con un editor de texto, los archivos que guardamos con extensión .sh podrán ser ejecutados (o interpretados) por la consola
siempre y cuando la primera línea sea la siguiente:

#!/bin/bash

Esto le dice al sistema que deberá usar la consola para ejecutar el archivo. Además, el carácter # permite escribir comentarios.

echo // muestra un mensaje en pantalla, en este caso el típico "Hola Mundo". Si lo guardamos y ejecutamos con la consola veremos el resultado.

Bash (y otros shells) permiten programar scripts
--Bash (Bourne again shell) es un programa informático cuya función consiste en interpretar órdenes.
Está basado en la shell de Unix.

Script o programa shell: Fichero de texto conteniendo comandos externos e internos
que se ejecutan línea por línea, el programa puede contener, además de comandos
variables, constructores lógicos (if...then, AND, OR, etc.) y lazos (while, for, etc.)
funciones comentarios

--- Ejecución de un script ---

Los scripts deben empezar por el simbolo #! seguido del programa a usar para interpretar el script:

#!/bin/bash // Script de bash
#!/bin/sh // Script de shell
#!/usr/bin/perl // Script de perl

----------------------------

#Ejemplo de programa en bash para imprimir valores de variables
#!/bin/bash
VAL=10
VAL2=20
echo $VAL
echo $VAL2

----------------------------

Guardamos el script, ejemplo: prueba.sh, no es necesario ponerle
la extensión ya que la cabecera del script especifíca que programa
lo interpretará

Ejecución:

sh prueba.sh // Ejecutar un programa con bash.

bash prueba.sh // Ejecutar un programa con bash.

./script.sh // Otra manera de ejecutar el script.

sh prueba // Ejecutar un programa con bash, script guardado sin extension.

------------------------

#Ejemplo de programa en bash para ejecutar aplicaciones instaladas en el SO.
#!/bin/bash
#val=10
val1='#########################\n'
val2='##### Abriendo Meld #####\n'
val3='#########################\n'
#echo $val1
#echo $val2
#echo $val3
echo $val1 $val2 $val3
/usr/bin/meld

------------------------

#Usando una funcion, y viendo el funcionamiento de variables locales y globales.
#!/bin/bash
HOLA=Hola_global
function hola {
    local HOLA=Mundo_local
    echo $HOLA
}
echo $HOLA
hola
echo $HOLA

-----------------------

#Llamado de una Funcion
#!/bin/bash
a='Estaba la pájara pinta'
function Imprimir {
    local a='sentada en un verde limón.'
    echo $a
}
echo $a
Imprimir
#echo $a

#################
##### RSYNC #####
#################

Es una aplicación que ofrece transmisión eficiente de datos, que opera también con datos comprimidos y cifrados.
Mediante una técnica de delta encoding, permite sincronizar archivos y directorios entre dos máquinas de una red
o entre dos ubicaciones en una misma máquina, minimizando el volumen de datos transferidos.
Muy recomendable para hacer respaldos en discos externos.

aptitude install rsync // Instalarlo desde los repositorios de debian

Parametros: -P para mostrar el progreso de la copia y -r cuando se van a copiar directorios

rsync -P ficehero /directorio/carpeta2 // Para copiar ficheros, archivos, etc. 

rsync -P -r /directorio/carpeta1 /directorio/carpeta2 // -r para copiar directorios
se ponen las dos rutas: origen y destino separados por un espacio.

##################################
##### Crear alias de comandos #####
##################################

Un alias es una palabra o frase que se asignara para 
remplazar un comando, por lo generalmente se usa para
remplazar comandos muy largos y dificiles de recordar
por lo que es una gran ventaja la creacion de alias.

Un alias Se pueden crear temporalmente, directamente en la consola
y durara hasta que cerremos ese shell, tambien asignar permanentemente
escribiendolo en el archivo .bashrc que esta en el /home 

$ alias nombre_alias='comando'

Ejemplo:
$ alias sa='aptitude search apache | grep rt4' // (sa) ahora es el alias de 
ese comando de busqueda en los repositorios de un paquete especifico.

$ unalias nombre_alias // Para eliminar el alias creado temporalmente

// Para que se haga efectivo algun cambio en .bashrc es necesario reiniciar
pero hay otra forma de actualizar el fichero sin reiniciar, entonces:

$ source .bashrc // Bastara para que se apliquen los cambios hechos

// Mensaje de bienvenida al usuario

Pegamos esto al final del .bashrc, reiniciamos el fichero
y ahora cada vez que iniciemos un shell nos saludará.

## Mensaje al iniciar
echo "Hola Usuario"

########################################################
### Saber la direccion ip de una pagina o un sevidor ###
########################################################

user@debian:~$ nslookup google.com // Saber la de google por ejemplo
Non-authoritative answer:
Name:   google.com
Address: 216.58.192.110 // Direccion ip de google

--- Otra forma ---

$ ping google.com // Haciendo ping al una pagina 
PING google.com (216.58.192.110) 56(84) bytes of data.
64 bytes from mia07s35-in-f14.1e100.net (216.58.192.110): icmp_req=1 ttl=49 time=69.6 ms // Ip de google
64 bytes from mia07s35-in-f14.1e100.net (216.58.192.110): icmp_req=2 ttl=49 time=70.4 ms

--- google.com ping statistics ---
3 packets transmitted, 2 received, 33% packet loss, time 2001ms
rtt min/avg/max/mdev = 69.645665/70.00475/470.48645/0.010 ms

########################################
##### Compilar e instalar paquetes #####
########################################

$ aptitude search build-essential // Este paquete es esencial para crear y manejar paquetes debian,
por consiguiente para la creación, compilacion e instalación de programas en debian, ubuntu etc.
Tambien se instala cuando se va a desarrollar con c y c++ puesto que la instalacion incluye
los compiladores y las librerias necesarias para comenzar a trabajar en estos lenguajes.

Descargámos el código fuente del programa que queremos compilar e instalar.
Normalmente lo encontraremos en un archivo comprimido, con extensión tar.bz2. 
Así que tendrás que descomprimirlo escribiendo en la consola:

$ tar xvzf paquete.tar.gz (o ver sección de Comprimir/Descomprimir archivos arriba)

//Ahora vamos al directorio donde hemos extraído el contenido del paquete:
$ cd path_del_paquete

// Confguramos el modo de compilación con:
./configure

Luego escribimos:
make

Y finalmente, instalamos con:
make install

// Si no hay errores ya deberíamos poder usar el programa instalado.

#################################
### DIA - Editor de diagramas ###
#################################

Es un editor de diagramas, grafos, gráficas, etc. Ofrece soporte para diagramas de estructuras
estáticas en UML (diagramas de clases), diagramas de  Entidad-Relación, diagramas de redes y mucho más.
Los diagramas se pueden exportar a postscript y a otros formatos.

$ aptitude install dia

################
##### Meld #####
################

Es una herramienta gráfica para hacer archivos diff y fusionarlos.
Permite al usuario ver los cambios entre, y fusionar, dos archivos, dos directorios, o dos archivos con un ancestro común.

$ aptitude install meld

########################################
##### Cambiar permisos de usuarios #####
########################################

Al ver los permisos de los ficehros o directorios nos encontramos con varios parametros:

En la primera columna se pueden ver una serie de letras y guiones (-rwxr-x---)
estas letras nos dicen quien en el sistema, y que clases de permisos tiene el fichero o carpeta.

Estas letras están agrupadas en tres grupos con tres posiciones cada uno
más una primera posición que nos dice de que clase de archivo se trata
(los mas normales (d) directorios, o (-) archivos de datos).

El primer grupo de tres (rwx en nuestro caso) nos dice que clase de permisos tiene el dueño del fichero (u)(user/owner)
El segundo grupo de tres (r-x en nuestro caso) nos dice que clase de permisos tiene el grupo del fichero (g)(group).
Y el último grupo de tres (--- en nuestro caso) nos dice que clase de permisos tienen todos los demás usuarios del sistema sobre este
fichero (o)(others).

r :significa permiso para leer 
w :significa permiso para escribir  
x :significa permiso para ejecutar

u :permisos para el usuario/dueño del fichero/directorio
g :permisos de grupos
o :permisos de los demás usuarios

Los permisos se pueden especificar de diferentes maneras, una serie de ejemplos, es lo mejor para comprenderlo:

chmod ugo+rwx (da permisos rwx a todos, user,group,others)
chmod ugo-x test (quita permiso x (ejecucion) a todos, user,group,others) 
chmod o-rwx test (quita permisos rwx a others) 
chmod u=rwx,g=rx (da permisos rwx a user, rx a group y ninguno a others)

chmod -R u=rwx,g=rx,o=rx /dir/dir2/dir3 // Ejemplo de como otorgar permisos a un directorio específico.

##### chmod en octal ######

Representación octal de chmod

Lectura tiene el valor de 4
Escritura tiene el valor de 2
Ejecución tiene el valor de 1

Entonces:

rwx |  7  | Lectura, escritura y ejecución
rw- |  6  | Lectura, escritura
r-x |  5  | Lectura y ejecución
r-- |  4  | Lectura
-wx |  3  | Escritura y ejecución
-w- |  2  | Escritura
--x |  1  | Ejecución
--- |  0  | Sin permisos

Por lo tanto:

chmod u=rwx,g=rwx,o=rx  | chmod 775 |
chmod u=rwx,g=rx,o=     | chmod 760 |
chmod u=rw,g=r,o=r      | chmod 644 |
chmod u=rw,g=r,o=       | chmod 640 |
chmod u=rw,go=          | chmod 600 |
chmod u=rwx,go=         | chmod 700 |

################################################
##### CCLive - Descargar videos de youtube #####
################################################

CCLive es una aplicación que nos permite descargar un vídeo que esté en YouTube
hacia nuestro ordenador mediante un simple comando. Por defecto guarda los vídeos en webm.

$ aptitude show cclive //Para ver si lo tenemos en los repos, y ver la descripción, si es así.

$ aptitude install cclive // Instalación, como root.

ó

$ sudo apt-get install cclive // Instalación, como root.

$ cclive https://www.youtube.com/watch?v=yWVrvce5R9 // Descargar un video pasando la url de youtube.

$ cclive URL1 URL2 URL3 URL4 // Soporta varias URLs a la vez, para bajar mas de 1 video.

$ cclive < urls.txt // Descargar un vídeo detrás de otro, desde un archivo de texto plano con todas las URLs (en líneas diferentes).

$ man cclive // Manual del paquete.

$ cclive -F https://www.youtube.com/watch?v=Lfj667lLLnE // Comprobar los formatos disponibles antes de descargar el video.
// Se podrá ver un listado de formatos disponibles separados por "|"

$ cclive -f fmt22_720p https://www.youtube.com/watch?v=LtzFg4JiL5E // Se elige el formato y se pasa en el comando.

###############################
##### Cifrado de ficheros #####
###############################

El cifrado simétrico y asimétrico.

-En el cifrado simétrico, ciframos el archivo con una clave X
Para descifrarlo y obtener el archivo original, utilizamos la misma clave X.

-El cifrado asimétrico es más complicado. Aquí no tenemos una sola clave común. En su lugar
cada persona tiene dos claves, una pública y una privada. Para enviarle un archivo a un amigo
lo cifras con su clave pública. De esta forma, sólo lo puede descifrar él con su clave privada.
Es más seguro que el cifrado simétrico, ya que la clave de descifrado (la privada) nunca se
comparte, siempre la tiene el receptor.

Ejemplo: Sabiendo lo anterior, si queremos que tres compañeros de trabajo nos manden un archivo
cifrado debemos de mandarle nuestra clave pública (que está vinculada a la privada) y nos
podrán mandar de forma confidencial ese archivo que solo nosotros podremos
descifrar con la clave privada.

--- ¿Qué es GnuPG? (GNU Privacy Guard) ---

Es un derivado libre de PGP y su utilidad es la de cifrar y firmar digitalmente, siendo además
multiplataforma (podéis descargarlo desde la página oficial) aunque viene incorporado en algunos
sistemas Linux, como en Ubuntu o Debian.

##### Cifrado simétrico #####

El cifrado simétrico es el tipo de cifrado más sencillo que hay, es más rápido de procesar y por desgracia
menos seguro que el cifrado asimétrico.

Crear un fichero cualquiera de ejemplo

$ touch prueba.txt

Dentro del fichero copiaremos algun texto de prueba para comprobar luego con el descifrado.

Luego en el shell escribimos el comando gpg con el parámetro -c para cifrar y -d para descifrar.

--- Parámetros básicos de gpg ---

-c // Encrypt with a symmetric cipher using a passphrase. The default symmetric cipher used is CAST5,

-d // Decrypt the file given on the command line

$ gpg -c prueba.txt // El comando gpg -c nombre_fichero nos aparecerá un cuadro que nos pide la contraseña
luego una confirmacion de la misma, luego  generará un archivo .gpg

Para descifrarlo usamos el comando gpg -d notas.txt.gpg introduciendo la contraseña correcta para poder decifrarlo.

$ gpg -d prueba.txt.gpg // Descifrar el fichero, nos permitira mirar el contenido.

$ man gpg // Ver el Manual de gpg

##### Cifrado asimétrico #####

--- Generar las claves---

Para poder cifrar asimétricamente primero tenemos que crear la pareja de claves
(pública y privada) con el comando gpg --gen-key

$ gpg --gen-key
gpg (GnuPG) 1.4.12; Copyright (C) 2012 Free Software Foundation, Inc.
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.

Por favor seleccione tipo de clave deseado:
   (1) RSA and RSA (default)
   (2) DSA and Elgamal
   (3) DSA (sólo firmar)
   (4) RSA (sólo firmar)
Su elección:

// GPG nos permite elegir el tipo de clave que queremos usar, hay opciones que solo permiten firmar
y otras que permiten firmar y cifrar, en este caso usaremos DSA y Elgamal.

las claves DSA pueden tener entre 1024 y 3072 bits de longitud.
¿De qué tamaño quiere la clave? (2048)

Nos pedirá el tamaño de la clave que puede variar entre 1024 bits y 3072, esto es de libre elección,
tomarémos el que propone por defecto (2048).

Nos pide la fecha en la que expirará la clave, la información del emisor de la clave
(nombre, mail y algunos datos extra que queramos dar) y por último nos pedirá la
contraseña que salvaguarda la clave privada.

Tras generar las claves podemos verlas con el comando gpg -k que nos muestra nuestro
anillo de claves, lo importante de este paso es que veremos la identificación de cada una
que es necesaria para poderlas exportar y enviar.

$ gpg -k // Visualizar anillo de claves
/home/user/.gnupg/pubring.gpg
--------------------------------

pub   1559C/88651986 2017-01-01
uid                  username_lastname (Enunciado de la clave) <username@email.com>
sub   2048g/55GD33FG 2017-01-01

--- Exportar y enviar la clave pública ---

El objetivo de esta pareja de claves es que cualquiera nos pueda mandar un archivo cifrado
que solo veremos nosotros y esto se hace difundiendo la clave pública que acabamos de crear
(la pública, nunca la privada), para exportarla en un archivo usaremos el comando:

$ gpg -output [archivo destino] --export [ID de a clave pública] (la clave pública generada antes tiene la ID 88651986).

$ gpg --output ClavePublica_username.gpg --export 88651986
$ ls
ClavePublica_username.gpg // Fichero generado que contiene la clave pública

Este archivo ahora se puede difundir por el medio que queramos.

#####################################
##### Configurar sudo en Debian #####
#####################################

En Debian no viene instalado y configurado por defecto.

$ aptitude install sudo

Una vez con el sudo instalado deberemos agregar nuestro usuario en la sección "User privilege specification"
en el archivo /etc/sudoers, de tal forma que la sección quede así:

User privilege specification
root ALL=(ALL) ALL
tu_usuario ALL=(ALL) ALL

Una vez configurado esto, ya podremos ejecutar acciones de administrador desde una terminal común, anteponiendo el sudo a la acción a realizar.

###################################################################
##### Lista de fuentes de los paquetes de debian sources.list #####
###################################################################

----- Apt -----

Apt (Advanced Package Tool) es un set de herramientas del núcleo de Debian. Apt hace posible:
instalar, eliminar, mantener sus aplicaciones al día y mucho más... 

Apt, que basicamente resuelve problemas de dependencias y busca los paquetes solicitados, trabaja con dpkg, otra herramienta
que maneja la instalación y eliminación de paquetes (aplicaciones). Apt es muy poderoso, y se usa frecuentemente desde la línea
de comandos o consola/terminal. Sin embargo, hay muchas herramientas GUI/Gráficas para ayudarle a usar Apt sin tener
que tocar la línea de comando.

Al presente, aptitude es la herramienta recomendada para interactuar con la suite APT. Las herramientas APT deben ser usadas
especificamente para manejar acciones que no puedan ser manejadas por aptitude, o dónde se necesite mayor control de las dependencias. 

/etc/apt/sources.list // APT utiliza un archivo que enlista las "fuentes" en donde se encuentran los paquetes. Este archivo es: /etc/apt/sources.list

El contenido de este archivo, normalmente sigue este formato:
    deb http://host/debian distribución sección1 sección2 sección3
    deb-src http://host/debian distribución sección1 sección2 sección3

Los renglones arriba mencionados son ficticios y no deberán ser usados. La primera palabra en cada línea, deb o deb-src, indican
el tipo del archivo: ya sea que contenga paquetes binarios (deb), esto es, los paquetes pre-compilados que normalmente se usan
o los paquetes fuente (deb-src), que son los códigos originales, más el archivo de control de Debian (.dsc) y el diff.gz que
contienen los cambios necesarios para "debianizar" el programa.

Generalmente se encuentra lo siguiente por defecto en el archivo sources.list:

     # See sources.list(5) for more information, especialy
     # Remember that you can only use http, ftp or file URIs
     # CDROMs are managed through the apt-cdrom tool.
     deb http://http.us.debian.org/debian stable main contrib non-free
     deb http://non-us.debian.org/debian-non-US stable/non-US main contrib non-free
     deb http://security.debian.org stable/updates main contrib non-free
     
     # Uncomment if you want the apt-get source function to work
     #deb-src http://http.us.debian.org/debian stable main contrib non-free
     #deb-src http://non-us.debian.org/debian-non-US stable/non-US main contrib non-free

Éstas son las líneas necesarias para una instalación básica de Debian. La primer línea deb apunta al archivo en el servidor oficial
la segunda línea apunta hacia el archivo del servidor non-US y la tercera línea apunta hacia el archivo del servidor de
actualizaciones de seguridad.

Las dos últimas líneas están deshabilitadas (con un "#" al inicio), así que apt-get las ignora. Éstas son las líneas de deb-src
esto es, apuntan hacia los paquetes fuente de Debian. Si frecuentemente descarga paquetes fuente para probar o recompilar
habilítelas (borrando el "#" al inicio de la línea).

El archivo /etc/apt/sources.list puede contener varios tipos de líneas. APT sabe como interpretar líneas del tipo http,
ftp, file (archivos locales, p.e., un directorio que contiene un CD-ROM) y ssh, según mis conocimientos.

No olvide ejecutar el comando apt-get update después de modificar el archivo /etc/apt/sources.list. Debe hacer
esto para permitir a APT obtener la lista de paquetes de las fuentes que especificó.

#########################
##### dpkg - debian #####
#########################

El programa dpkg es la base del sistema de gestión de paquetes de Debian GNU/Linux. Fue creado por Ian Jackson en 1993. Se utiliza para instalar
quitar, y proporcionar información sobre los paquetes .deb.

dpkg es en sí misma una herramienta de bajo nivel; se necesita un frontal de alto nivel para traer los paquetes desde lugares remotos o resolver
conflictos complejos en las dependencias de paquetes. Debian cuenta con apt para esta tarea.

Herramientas Dpkg, Debian posee una serie de herramientas que es necesario llamar para construir un paquete:

-dpkg-source Empaqueta y desempaqueta los archivos fuentes de un paquete Debian.
-dpkg-gencontrol Lee la información de un árbol fuente Debian desempaquetado y genera un paquete binario de control, generando una
entrada para éste en el fichero debian/files.
-dpkg-shlibdeps Calcula las dependencias de ejecutables respecto a bibliotecas.
-dpkg-genchanges Lee la información de un árbol fuente Debian desempaquetado y ya construido, generando un fichero de control de los últimos cambios (un.changes).
-dpkg-buildpackage Es un script de control que se puede utilizar para automatizar la construcción del paquete.
-dpkg-distaddfile Añade una entrada de un fichero a debian/files.
-dpkg-parsechangelog Lee el fichero de cambios changelog) de un árbol fuente Debian desempaquetado y genera una salida con la información
de estos cambios, convenientemente preparada.

###############
##### deb #####
###############

-Extensión de archivo: .deb
-Tipo de formato: Sistema de gestión de paquetes

.deb es la extensión del formato de paquetes de software de la distribución de Linux, Debian GNU/Linux y derivadas (e.j.Ubuntu), y
el nombre más usado para dichos paquetes. Como Debian, su nombre proviene de Deborah Murdock, ex-esposa del fundador de la distribución Ian Murdock.

El programa predeterminado para manejar estos paquetes es dpkg, generalmente usando apt/aptitude aunque también hay interfaces gráficas como Synaptic PackageKit, Gdebi o en Ubuntu Software Center (este último solo para Ubuntu), desde la versión 3.0. Es posible convertir un paquete deb a otros formatos de paquete (como RPM), y viceversa, usando la aplicación alien.

--- Estructura interna ---

Los paquetes deb son archivos estándar de Unix que incluyen dos archivos tar en formato gzip, bzip2 o lzma: uno de los cuales alberga la información de control y el otro los datos.

Estos paquetes contienen tres archivos:
-debian-binary - número de versión del formato deb. Este es "2.0" para las versiones actuales de Debian.
-control.tar.gz - toda la meta-información del paquete.
-data.tar, data.tar.gz, data.tar.bz2 o data.tar.lzma: - los archivos a instalar.

########################################
##### Instalación de paquetes .deb #####
########################################

Documentacion oficial de debian --> https://debian-handbook.info/browse/es-ES/stable/sect.manipulating-packages-with-dpkg.html

dpkg es la herramienta para instalar un paquete Debian, para hacer esto utilizamos su opción -i o --install.

--- Ejemplo de instalación de un paquete con dpkg ---

$ dpkg -c dsc-nombre-paquete-xxx_i386.deb // Listar o mostrar el contenido del paquete.

$ dpkg -L xxx // Lista los ficheros instalados en el sistema, que pertenecen al paquete xxx.

$ dpkg -x dsc-nombre-paquete-xxx_i386.deb /home/dir/ // Desempaquetamos el contenido del paquete en una ruta, necesario es crear la ruta antes.

# dpkg -i man-db_2.7.0.2-5_amd64.deb // El comando desempaquetara, configurara y comprobará las dependencias del paquete, si hay paquetes sin instalar, lo notificara, una vez instalados los paquetes necesarios, el paquete pendiente por configurar lo hará automaticamente, completando así la instalacion, se podrá comprobar con un aptitude show nombre_paquete.

# dpkg -l | grep nombre-del-paquete // Comprobar la instalación, Deberías ver ii delante del nombre del paquete en la salida en pantalla, ello significaría que el programa ha sido correctamente instalado.

# dpkg -r nombre-del-paquete // Desinstalar paquete con dpkg, Este comando removerá el paquete, pero dejara los archivos de configuracion intactos, esto es util en caso que hubieras realizado cambios en ellos y quieras una copia para usos posteriores. Pero si deseas quitar todo rastro del paquete debes usar purge.

$ dpkg -force -r xxx.deb // Forzar la desinstalación del paquete xxx.deb.

# dpkg -P nombre-del-paquete // Ahora no quedará rastro del paquete antes instalado.

$ dpkg --info nombre_paquete.deb // Muestra información sobre el paquete, sobre las dependencias y las versiones de las mismas, lo que mostrario con un aptitude show.

$ dpkg --get-selections // Para listar el total de paquetes instalados.

# dpkg --get-selections > /home/dir/mis_paquetes.txt // Gracias a este herramienta también es posible exportar la lista de paquetes instalados, crear el fichero

#dpkg --set-selections < /home/dir/mis_paquetes.txt // Luego podemos instalarlos en otra máquina pasandole la lista, obtención de la lista precedente.

# apt-get dselect-upgrade // Instalación de la lista

$ dpkg -l // Da la lista de paquetes instalados pero con mayor información. Sin embargo, no es posible utilizarlo para instalar una lista de paquetes. 

$ dpkg -l xxx // Lista los paquetes instalados que coincidan con el nombre xxx

$ dpkg -l *xxx* // Lista los paquetes que contienen la cadena xx en su nombre de paquete.

###########################################
##### Descargando los paquetes fuente #####
###########################################

Es muy común en el mundo del software libre estudiar el código fuente o corregir código erróneo. Para lograr esto, se necesita descargar el código fuente del programa.
El sistema APT provee de una manera fácil de obtener código fuente de muchos programas contenidos en la distribución, incluyendo todos los archivos necesarios
para crear un .deb para el programa.

Otro uso común de las fuentes de Debian es el de adaptar la versión más reciente de un programa, de la versión inestable. Compilar un programa en la versión estable
generará .debs con las dependencias ajustadas para acoplarse a los paquetes en la distribución.

Para lograr esto una entrada deb-src en el archivo /etc/apt/sources.list debe apuntar hacia "unstable". Esta línea debe estar habilitada (sin comentar).

Para descargar un paquete fuente, haga lo siguiente:

$ apt-get source packagename

Esto descargará tres archivos: un .orig.tar.gz, un .dsc y un .diff.gz. En el caso de paquetes especiales para Debian, el último de estos archivos no es descargado y el primero generalmente no tendrá el "orig" en el nombre.

El archivo .dsc es utilizado por dbpkg-source para descomprimir el paquete en el directorio packagename-version. Con cada paquete descargado existe un directorio debian/ que contiene los archivos necesarios para crear un paquete .deb.

Para automáticamente compilar el paquete cuando está siendo descargado, sólo agrega -b a la línea de comando así.

$ apt-get -b source packagename

Hay una diferencia entre el apt-get source y las otras opciones. La opción source puede ser utilizada por usuarios normales, sin necesitar de poderes especiales de root. Los archivos son descargados a un directorio desde el cual el comando apt-get source package es ejecutado.

###########################################
##### Estructura de un paquete fuente #####
###########################################

Un paquete fuente generalmente consiste de tres archivos: uno .dsc, uno .orig.tar.gz y uno .debian.tar.gz (o .diff.gz). Ellos permiten la creación de paquetes binarios (.deb) a partir de los archivos de código fuente del programa, escritos en un lenguaje de programación.

El archivo .dsc («Debian Source Control»: control de fuente Debian) es un archivo de texto corto que contiene una cabecera RFC 2822 que describe el paquete fuente e indica qué otros archivos forman parte del mismo. Está firmado por su encargado, lo que garantiza su autenticidad.

# Ejemplo 5.1. Un archivo .dsc

-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA256

Format: 3.0 (quilt)
Source: zim
Binary: zim
Architecture: all
Version: 0.62-3
Maintainer: Emfox Zhou <emfox@debian.org>
Uploaders: Raphaël Hertzog <hertzog@debian.org>
Homepage: http://zim-wiki.org
Standards-Version: 3.9.6
Vcs-Browser: http://anonscm.debian.org/gitweb/?p=collab-maint/zim.git
Vcs-Git: git://anonscm.debian.org/collab-maint/zim.git
Build-Depends: debhelper (>= 9), xdg-utils, python (>= 2.6.6-3~), libgtk2.0-0 (>= 2.6), python-gtk2, python-xdg
Package-List:
 zim deb x11 optional arch=all
Checksums-Sha1:
 ad8de170826682323c10195b65b9f1243fd75637 1772246 zim_0.62.orig.tar.gz
 a4f70d6f7fb404022c9cc4870a4e62ea3ca08388 14768 zim_0.62-3.debian.tar.xz
Checksums-Sha256:
 19d62aebd2c1a92d84d80720c6c1dcdb779c39a2120468fed01b7f252511bdc2 1772246 zim_0.62.orig.tar.gz
 fc2e827e83897d5e33f152f124802c46c3c01c5158b75a8275a27833f1f6f1de 14768 zim_0.62-3.debian.tar.xz
Files:
 43419efba07f7086168442e3d698287a 1772246 zim_0.62.orig.tar.gz
 725a69663a6c2961f07673ae541298e4 14768 zim_0.62-3.debian.tar.xz

-----BEGIN PGP SIGNATURE-----
Version: GnuPG v2
Comment: Signed by Raphael Hertzog

iQEcBAEBCAAGBQJUR2jqAAoJEAOIHavrwpq5WFcH/RsdzCHc1oXXxHitU23hEqMj
T6ok29M1UFDJDowMXW75jQ1nT4WPUtvEGygkCHeoO/PvjEvB0sjU8GQlX+N9ddSB
aHfqfAYmVhADNGxrXQT5inZXUa8qGeeq2Sqf6YcWtsnuD56lDbvxkyf/XYopoIEl
oltfl05z/AI+vYsW482YrCz0fxNAKAvkyuPhDebYI8jnKWeAANoqmKpsNc/HYyvT
+ZiA5o57OiGdOKT6XGy3/FiF3dkHiRY8lXW7xdr1BbIgulwl9UmiUNwuxwOYbQO7
edtjiTJqOaFUA0x1zB/XGv5tHr1MjP8naT+kfVoVHTOox51CDbeu5D3DZY4imcY=
=Wtoa
-----END PGP SIGNATURE-----

Note que el paquete fuente también tiene dependencias (Build-Depends) completamente distintas de aquellas del paquete binario ya que
indican las herramientas necesarias para compilar el software en cuestión y construir su paquete binario. 

--- PRECAUCIÓN Espacios de nombres distintos ---

Es importante saber que no hay una correspondencia necesaria entre el nombre de un paquete fuente y el de el o los paquetes binarios que genera. Es suficientemente fácil de entender si sabe que cada paquete fuente puede generar varios paquetes binarios. Es por esto que el archivo .dsc tiene los campos Source y Binary para nombrar explícitamente el paquete fuente y almacenar la lista de paquetes binarios que genera, respectivamente.

--- CULTURA Porqué dividir en varios paquetes ---

Frecuentemente un paquete fuente (para un programa dado) puede generar varios paquetes binarios. La división es justificada por la posibilidad de utilizar (partes de) el mismo en varios contextos. Si consideramos una biblioteca compartida, ésta puede ser instalada para hacer funcionar una aplicación (por ejemplo, libc6) o para desarrollar un nuevo programa (libc6-dev sería el paquete correcto). Encontramos la misma lógica para servicios cliente/servidor donde deseamos instalar el servidor en una máquina y la parte cliente en otras (este es el caso, por ejemplo, de openssh-server y openssh-client).
Tan frecuentemente también se provee la documentación en un paquete dedicado: el usuario puede instalarla independientemente del software y puede elegir eliminarla en cualquier momento para ahorrar espacio en disco. Adicionalmente, esto también ahorra espacio en disco en las réplicas Debian ya que todas las arquitecturas comparten los paquetes de documentación (en lugar de tener la documentación duplicada en los paquetes para cada arquitectura).

--- PERSPECTIVA Diferentes formatos de paquetes fuente ---

Originalmente sólo existía un formato de paquete fuente. Este es el formato 1.0 que asocia un compendio .orig.tar.gz con un parche de «debianización» .diff.gz (también hay una variante que consiste de un simple compendio .tar.gz, utilizada automáticamente si hay disponible un archivo .orig.tar.gz).
Desde Debian Squeeze, los desarrolladores Debian tienen la opción de utilizar nuevos formatos que corrigen varios problemas del formato histórico. El formato 3.0 (quilt) puede combinar varios compendios de origen en el mismo paquete fuente: puede incluir compendios .orig-componente.tar.gz además del .orig.tar.gz usual. Esto es útil con el software distribuido desde origen en varios componentes pero para el que se desea sólo un paquete fuente. Estos compendios también puede comprimirse con bzip2 o xz en lugar de gzip, lo que ahorra espacio en disco y recursos de red. Finalmente, se reemplaza el parche monolítico .diff.gz por un compendio .debian.tar.gz que contiene las instrucciones de compilación y un conjunto de parches al origen contribuidos por el desarrollador del paquete. Estos últimos son registrados en un formato compatible con quilt — una herramienta que facilita la gestión de una serie de parches. 

--- HERRAMIENTA Descomprimiendo un paquete fuente ---

Si tiene un paquete fuente, puede utilizar dpkg-source (del paquete role="pkg") para descomprimirlo:

$ dpkg-source -x package_0.7-1.dsc

##########################################
##### Trabajando con paquetes Debian #####
##########################################

Gonz-*alo help - ***Pendiente***
./configure

dpkg-source

dpkg-source -x evince_3.14.1-2+deb8u1.dsc

cd evince-3.14.1/

dpkg-buildpackage -rfakeroot

########################
##### Dependencias #####
########################

Una dependencia es un paquete accesorio requerido por un paquete instalador para hacer funcionar correctamente un programa después de instalarlo.
Generalmente son bibliotecas de código o programas accesorios. Un programa puede tener múltiples dependencias, las cuales no siempre vienen instaladas
en la distribución Linux elegida por diversas razones, por no ser necesarias, por aumentar demasiado el tamaño del archivo ISO, etc. Algunas distros, por ser una
distribuciones minimalistas, de tamaño ligero, encaminan con frecuencia al usuario  tener que buscar dependencias de programas que no se suelen ofrecer en los
repositorios o en los foros, por eso el administrador de paquetes incluye una herramienta para detectar y descargar las dependencias junto con el programa principal.
Aunque es posible ofrecer un solo paquete que incluya el programa principal más las dependencias, muchos compiladores y desarrolladores optan por ofrecer esos
componentes por separado para facilitar la descarga a través de conexiones lentas, o para darle al usuario la opción de instalar sólo los componentes que sabe
que están ausentes en su sistema. Por eso, siempre es recomendable investigar cuáles son las dependencias del programa que se desea instalar, así como verificar
que se tiene suficiente espacio para la instalación. No todas las dependencias son absolutamente necesarias, algunas sólo dan soporte adicional para ciertas
funciones o efectos visuales que extienden las características del programa en sí mismo.

########################
##### Metapaquetes #####
########################

Un metapaquete es un como un paquete que enlaza varios paquetes, es decir, es un paquete que contiene referencias a
varios paquetes pero no realiza ninguna funcionalidad.

Los metapaquetes sirven para poder instalar fácilmente varios paquetes con una sola orden. Estos paquetes guardan entre
sí una cierta coherencia.

El funcionamiento de un metapaquete es el siguiente:

Imaginemos que tenemos el metapaquete A, que contiene a B, C , D y E. Cuando instalamos el metapaquete A, lo que en realidad estamos instalando
son los paquetes B, C, D y E.

--- Estructura de un metapaquete ---

Tal como los paquetes comunes, los metapaquetes deben ser generados a partir de un código fuente basado en las políticas de Debian.

metapaquete
    |-- AUTHORS                (opcional)
    |-- COPYING                (opcional)
    |-- debian
    |    |-- changelog
    |    |-- compat
    |    |-- control
    |    |-- copyright
    |    |-- postinst
    |    |-- postrm
    |    |-- preinst
    |    |-- prerm
    |    |-- rules
    |    `-- source
    |        `-- format
    |-- LICENSE                (opcional)
    |-- Makefile               (opcional)
    |-- README                 (opcional)
    |-- THANKS                 (opcional)
    `-- TODO                   (opcional)

La carpeta debian contiene los siguientes archivos:

-changelog: Lista cronológica de versiones del metapaquete, que además contiene una descripción significativa de los cambios hechos en cada una de ellas.
-compat: versión de debhelper utilizada.
-control: El archivo más importante en un metapaquete. Especifica las dependencias, el nombre del paquete, el responsable (mantenedor),
descripción, entre otros campos.
-copyright: Declaración de derechos de autor (si los hubiere) y licencia de distribución del paquete.
-postinst, postrm, preinst, prerm: Los scripts del mantenedor permiten configurar o modificar partes del sistema en diferentes momentos de la instalación del paquete.
-rules: El archivo rules especifica las reglas para el empaquetado de la aplicación.
-source/format: Especifica el formato del código fuente, el más recomendado es 3.0 (quilt).

Los siguientes son archivos opcionales que pueden o no ser incluidos a gusto del desarrollador. Normalmente se incluyen, pero en el caso de los
metapaquetes no hay código que compilar, ni copiar dentro del paquete (que es para lo que sirve el Makefile), ni tampoco hay
código que documentar o describir.

-AUTHORS: Contiene el o los autores del código fuente.
-COPYING: Declaración de derechos de autor (si los hubiere) y licencia de distribución del código fuente.
-LICENSE: Una copia exacta de la licencia con que se distribuye el código fuente.
-Makefile: Son el conjunto de instrucciones necesarias para que el código fuente se organice, (compile si es necesario) e instale en
el sistema. También contiene instrucciones para limpiar y desinstalar.
-README: Descripción detallada del software. Se responden preguntas como: ¿Para que sirve? ¿Cómo se instala? ¿Cómo se desinstala? ¿Donde consigo ayuda?
-THANKS: Agradecimientos a las personas que contribuyeron contigo.
-TODO: Cosas que quisieras hacer en el futuro con tu software.

#########################################################
##### Quemar o grabar una imagen iso en un pendrive #####
#########################################################

# dd if=[imagen] of=[dispositivo]

En donde imagen es la ruta completa a la imagen ISO que deseas grabar y dispositivo la ruta completa hacia el pendrive, no la ruta con el nombre del pendrive, por ejemplo:

dd if=/home/user/Descargas/debian-testing-i386-businesscard.iso of=/dev/media/sdb

-----

$ export GIT_SSL_NO_VERIFY=True // Si un repostirotio git remoto no cuenta con el certificado
digital del servidor a veces se debe saltar chequeo de la firma para bajar las fuentes con este comando.

###########################################
##### Formatear pendrives desde linux #####
###########################################

# aptitude install dosfstools

Luego de instalar el paquede, montamos el pendrive, solo esta montado si aparece el nombre de la unidad en /media, luego escribimos:

$ df -h

Visualizamos la ruta de nuestro usb, ejemplo /dev/sdc1 que es el puerto donde está montado, luego desmontamos el pendrive.

$ umount /media/nombre_usb

Luego, estando desmontado la unidad usb, pero conectado al puerto

# mkfs.vfat -F 32 -n Nombre_usb /dev/sdc1

Esperamos y listo. Con la opción -F 32 le decimos que será formateada como Fat32, y con la opción -n le ponemos una etiqueta o nombre al dispositivo y
al final ponemos la ruta hasta nuestro dispositivo, la que vimos con df -h

################################
##### source.list example  #####
################################

#Debian GNU/Linux 8 (Jessie) Estable

#Repositorio Oficial
deb http://http.us.debian.org/debian/ jessie main contrib non-free
deb-src http://http.us.debian.org/debian/ jessie main contrib non-free

deb http://httpredir.debian.org/debian/ jessie main
deb-src http://httpredir.debian.org/debian/ jessie main

# jessie-updates, previously known as 'volatile'
deb http://httpredir.debian.org/debian/ jessie-updates main
deb-src http://httpredir.debian.org/debian/ jessie-updates main

#Repositorio de Seguridad
deb http://security.debian.org/ jessie/updates main contrib non-free
deb-src http://security.debian.org/ jessie/updates main contrib non-free
deb http://security.debian.org/ jessie/updates main
deb-src http://security.debian.org/ jessie/updates main

#Repositorio Multimedia
#aptitude install deb-multimedia-keyring
#deb http://www.deb-multimedia.org testing main non-free
#deb http://www.deb-multimedia.org jessie main non-free
#deb-src http://www.deb-multimedia.org jessie main non-free

#----------------------------------

#Debian GNU/Linux 7 (Wheezy) Estable

#Repositorio Oficial
deb http://ftp.us.debian.org/debian/ wheezy main contrib
deb-src http://ftp.us.debian.org/debian/ wheezy main contrib

#Actualizaciones de Seguridad
deb http://security.debian.org/ wheezy/updates main contrib
deb-src http://security.debian.org/ wheezy/updates main contrib

#Actualizaciones de Wheezy
deb http://ftp.debian.org/debian wheezy-updates main contrib non-free
deb-src http://ftp.debian.org/debian wheezy-updates main contrib non-free

#Backports
deb http://ftp.debian.org/debian/ wheezy-backports main

########################################################
##### Recommended installation packages for Debian #####
########################################################
Actualizar el source.list 

# apt-get update

Si da problemas con el fichero dir/dir/lock por ejemplo, lo borramos

# rm -f dir/dir/lock

No se pudo bloquear /var/lib/dpkg/lock - open (11: Recurso no disponible temporalmente)

$ sudo fuser -vki  /var/lib/dpkg/lock // Solución

luego seguimos con...

terminator
aptitude
apache
postgresql
ssh
Sudo
vlc player
gcc
build-essential
dpkg-dev
fakeroot
cmake
meld
git
vim
Virtual Box
Sublime
    -Instalar el .deb de la página o buscar en los repos, > a v2.
python-pip
virtualenv
virtualenvwrapper
curl
qpdfview
python
python-requests
django
ruby
ruby on rails
Paquete para dar formatos a unidades usb
firefox
Adblock
Private Tab
Firebug
Youtube Video Downloader

