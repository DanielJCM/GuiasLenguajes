##### Guía de comandos en Linux by dM #####

###################################################################################
##### Probados en: Debian GNU/Linux 7 (wheezy) y algunos en Debian 8 (Jessie) #####
###################################################################################

Crtl + h // Mostrar archivos ocultos de un directorio, en el entorno grafico

$ cat /etc/issue.net  //Para saber la versión de SO que tenemos.

$ cat /etc/issue  //Para saber la versión de SO que tenemos.

!! // Repetir el ultimo comando ejecutado en consola

~ // Para sacarlo usar AvPag en la consola

comando && comando && comando... // Ejecucion multiple de comandos

Ctrl + u // Cortar el contenido de la linea de comandos desde la posicion del cursor hasta el principio

Ctrl + k // Cortar el contenido de la linea de comandos desde la posicion del cursor hasta el final

Ctrl + t // Intercambiar de posicion las letras que estan a cada lado del cursor

Alt + d // Borrar palabra

$ lsb_release -a //También tenemos un comando que nos va a dar muchos más detalles 

$ uname // Muestra información del sistema

$ uname -a // Version de Kernel

$ uname -mrs // Saber mi version de Kernel especifica, recomendada

$ cat /etc/*-release // Ver info del sistema (Probado en Debian GNU/Linux 7 wheezy)

$ ifconfig // Siendo root, permite desplegar numerosos parámetros de las interfaces de red residentes  en el núcleo,
como la dirección ip (dinámica o estática), o la máscara de red entre otros.

$ apt-get moo // Huevo de pascua, muestra una vaca.

--- ip publica ---

Una forma de averigar esa IP pública es haciendo uso del comando curl. Si no tenéis instalado el paquete habrá que instalarlo,

$ sudo apt-get install curl

$ curl ifconfig.me // Nos mostrará nuestra ip pública.

$ nmap -sT -O localhost // Ver que puertos estan escuchando 

$ user@debian:/media$ umount nombre_device // Desmontar un dispositivo, pendrive, disco externo etc.

$ who // Muestra usuarios conectados a nuestra máquina, tambien usado para ver las conexiones entrantes de un servidor

Ejemplo:
user tty7         2015-07-28 08:47 (:0)
user pts/0        2015-07-30 14:03 (:0.0)
user pts/1        2015-07-30 17:03 (:0.0)
user pts/2        2015-07-31 14:15 (:0.0)
user pts/3        2015-07-31 12:37 (:0.0)

//En este caso son los usuarios conectados a mi máquina, eso quiere decir que tengo shells
abiertos, por lo tanto todos son representados como usuarios, entre los diversos parametros
se puede apreciar la fecha y la hora en que se abrio el shell, en un servidor seria
el momento en que se conecto el usuario

$ whoami // Muestra que usuario soy, nombre de usuario

$ who am i // Nos dira cual usuario somos, si navegamos por los shells abiertos y ejecutamos el comando nos dira cual usuario es

$ who -u //Ver usuarios conectados

// Ejemplo:

user tty7         2015-07-28 08:47  antig       4257 (:0)
user pts/0        2015-07-30 14:03 03:22        8351 (:0.0)
user pts/1        2015-07-30 17:03 03:19        8351 (:0.0)
user pts/2        2015-07-31 14:15 00:08        8351 (:0.0)
user pts/3        2015-07-31 12:37 02:53        8351 (:192.168.0.240)

//Aqui observamos que hay una conexion externa a traves de ssh a nuestro servidor proveniente de la maquina
(192.168.0.240) demarcada por el id process 8351 la cual podemos cancelar, es decir refusar esa conexion con
$ kill -9 8351

# pkill -9 -t pts/3 // Acabar con una conexión externa, se envió la señal -9 que indica matar (KILL) el proceso, la opción -t indica que se basará
en un atributo de nombre de terminal y se indica después el nombre de la terminal en si pts/3.

$ last // listar los ultimos usuarios conectados

$ clear // Limpia la pantalla

$ date // Muestra la fecha

$ man nombre_comando  // Muestra el manual de una comando donde como: ls, grep, aptitude etc...

// Dentro de los manuales podemos presionar "h" para ver las opciones tenemos del manual, ejemplo "/delete"
para hacer una busqueda de la cadena "delete" dentro del manual.

$ cal // Muestra un calendario

$ pwd // Muestra la ruta en la que te encuentras

$ ls // Muestra lo que hay en la carpeta en la que te encuentras

$ ls -l // Muestra los archivos, fecha, permisos, etc

$ ls -la // Muestra los archivos, los ocultos tambien, fecha, permisos, etc

$ ls -1 // Muestra los archivos en forma de lista

$ ls *.xxx // Listar todos los ficheros de un directorio que tengan las extension .xxx, donde xxx puede ser: txt, html, php, css, etc.
ejemplo: ls *.txt

$ ls -R // Listar los directorios y subdirectorios asi como ficehros de un directorio.

$ \du // Para ver la lista de carpetas y sub carpetas, los directorios que existen 
dentro de donde se encuentre situado

$ cd // Cambiar de directorio, nos lleva al home del usuario.

$ cd 'nombre carpeta' // Acceder a un directorio que tiene espacios en el nombre.

-- Si una carpeta se llama (a b c d e), para aceder a ella usamos:

$ cd a\ b\ c\ d\ e/ // Al final siempre lleva el / normal, los otros usan el invertido.

$ cd .. // retroceder un directorio

$ cd ../../ // Retroceder dos directorios (../) representa un directorio

$ mkdir // Crear carpeta

&& // El operador '&&' sirver para continuar con la ejecucion de comadnos en el shell, ejemplo:

$ mkdir carpetaFFF && cd carpetaFFF // Creamos una carpetaFFF y luego entramos en la carpeta creada
,&& nos permite poner varias instrucciones en una sola linea del shell, otro ejemplo:

$ mkdir carpetaZZZ && cd carpetaZZZ && touch archivo.txt // Creamos una carpeta, entramos en ella y creamos un archivo
en ese directorio en una sola instruccion.

$ touch Nombre_Fichero // Crear fichero

$ nano nombre_fichero // Modificar un fichero con el editor nano.

$ man nano // Leer el manual del editor de textos nano, muy útil, práctico y fácil de usar

$ cat nombre_fichero // Mostrar contenido de un fichero

$ less nombre_fichero // Mostrar el contenido de un archivo, mayor movilidad que cat.

$ tail nombre_fichero.xxx // El comando tail sirve para mostrar en pantalla las últimas líneas de un archivo.

$ tail -n X nombre_fichero.xxx // -n donde X es el número de lineas que queremos ver del fichero.

$ tail -c X nombre_fichero.xxx // -n donde X es el número caracteres desde el final, que queremos ver del fichero.

$ tail fichero_1.xxx fichero_2.xxx // Se pueden especificar 1 o más ficheros a la vez, los mostrara en el orden declarado.

$ stat nombre_fichero // Muestra el estado e información de un fichero

$ stat nombre_carpeta // Muestra información de un directorio

Ctrl + D // En el shell, cerrar sesion, salir del root, de maquinas virtuales o de sesiones de usuarios iniciadas

Ctrl + flecha derecha o izquierda // Moverse en el prompt palabra a palabra, no letra por letra.

Ctrl + w // Borrar la palabra que esta antes del cursor en el shell

$ top  // Listar los procesos de ejecución del sistema (y más cosas) en tiempo real, es una de las herramientas más importantes para un administrador.

// Cada proceso tiene un identificador (PID) proccess ID, entonces podemos matar ese proceso con:

$ kill -9 xxxx // Matar un proceso donde xxxx es el identificador del proceso.

$ ps // Muestra los procesos actuales del sistema y acepta varios parametros como:

$ ps -e // Visualiza información sobre "todos" los procesos del sistema.

$ ps -l // Muestra algunos detalles de los procesos del sistema

$ ps l //  Muestra mas detalles de los procesos del sistema.

$ poweroff // Apagar la maquina, se debe ser root para ejecutarlo.

$ reboot // Reiniciar la maquina.

$ file xxx // donde xxx es el nombre de un fichero, nos dira el tipo de fichero que es.
    Ejemplo: file index.html
    index.html: HTML document, UTF-8 Unicode text

$ file * // Nos dira el tipo de archivo de todos los ficheros del directorio

$ diff /home/user/file.html /home/user/file2.html // Permite hacer una comparacion de dos archivos para apreciar sus diferencias
se debe especificar la ruta de ambos archivos y separarlos con un espacio, si estan en el mismo directorio no hace
falta especificar las rutas completas.

$ df // Muestra el espacio disponible del disco y demas dispositivos asi como el espacio usado

$ df -h // Muestra el espacio disponible del disco y demas dispositivos asi como el espacio usado, pero en mg o gb según sea el caso.

# fdisk -l // Ver informacion de los discos duros, particiones y dispositivos montados en el sistema.

$ lsusb // Este comando muestra todos los puertos USB y los detalles acerca de los dispositivos conectados a ellos.

$ free // Muestra el estado de la memoria RAM, total, usado, disponible, cached, buffers 

$ vmstat // Muestra el estado de la memoria virtual

$ pstree // Muestra los procesos del sistema en forma de arbol

$ gnome-screenshot // Captura de pantalla del escritorio

$ pdfimages fichero.pdf nombre_imagene // Extrae las imagenes de un .pdf

$ du // Muestra una lista de los directorios y el espacio que ocupan en el disco

$ du * // Muestra todos directorios y ficheros y el espacio que ocupan en el disco

$ ping xxx // Donde xxx es el nombre de un host al cual enviaremos paquetes y comprobaremos si hay una conexion con ese host, util para saber si estamos conectados a internet por ejemplo:
    ping http://www.google.com.ve // Si hay conexion a internet enviara paquetes que seran recibidos, de lo contrario dara un error.

$ glxgears // Siendo root, Ver si hay aceleracion grafica en la maquina, muestra unos engranajes de colores rodando, si es así, está correcta la instalacion del video.

$ xrandr // Detectar las resoluciones de pantalla disponibles del sistema así como los hz correspondientes, la que
tenga (*) es la que está siendo usada.

$ adduser nombre_de_usuario // Como root, Agregar un usuario nuevo al sistema, una nueva sesion, nos pedira agregar el 
nombre de usuario y asignarle contraseña, la clave de root es la misma para todas las sesiones.

$ su nombre_de_usuario // Conectarse como otro usuario creado

$ userdel -r nombre_usuario // Como root, eliminar el usuario creado

$ deluser --remove-home nombre_usuario // Otra forma de eliminar un usuario creado

$ rename 's/\.txt/\.xls/' *.txt  //Cambiar extension a todos los ficheros de un directorio
//En el ejemplo vamos a sustituir los .txt por .xls y le decimos que se lo haga a todos los .txt

################
##### Less #####
################

// less es un visualizador de archivos de texto que funciona en intérpretes de comando.
// A diferencia de otros programas similares (como more), less permite una completa navegación
// por el contenido del archivo, utilizando un mínino de recursos del sistema.

***** Comandos basicos *****

man less // Manual de less

AvPag // Avanzar una página

RePag // Retroceder una página

space // Tecla espacio para avanzar, como page up

:q // Salir

:h // Ayuda

:/palabra // (/) Buscamos una palabra dentro del documento
// (n) para ir a la siguiente coincidencia.
// (N) para ir a la coincidencia anterior

:G // Ir al final del texto

:g // Ir al inicio del texto

:v //Invocar un editor de texto para el documento, por lo general usa vi pero puede usar nano automaticamente

########################################################
##### Comandos para copiar, mover, eliminar, otros #####
########################################################

cp // Copiar un fichero o carpeta

cp -r // Copiar un fichero o carpeta

cp Nombre_de_archivo.txt /Carpeta/destino/a/copiar // Copiar un fichero en un directorio
se debe estar situado en la carpeta del archivo a copiar

cp Nombre_carpeta -r /Carpeta/destino/a/copiar // Copiar un directorio en otro, 
se debe estar situado en la carpeta de la carpeta a copiar

cp -r /home/usuario/carpeta1/ /home/usuario/carpeta2/ //Se pueden copiar archivos o carpetas especificando las
rutas completas, en este caso la primera ruta es el directorio o archivo a copiar y la segunda es la ruta donde
se va a pegar lo copiado, ambas rutas separadas por un espacio en blanco.

cp -r carpeta/ carpeta2/ // Ambas carpetas estan en el mismo directorio donde estamos situados, por lo tanto
no hay que especificar las rutas completas de las carpetas involucradas

cp nombre_fichero.xxx nombre_fichero2.xxx // Hacer una copia de un fichero y cambiarle el nombre.

cp -r carpeta1 carpeta2 // Hacer una copia de un directorio y cambiarle el nombre.

mv // Mover un fichero o carpeta y/o cambiar su nombre

mv /home/carpeta/archivo1.txt /home/carpeta2/ // Mover una carpeta o archivo especificando el directorio
de salida y el de llegada, si estan en el mismo directorio no hace falta poner las rutas completas.

mv archivo1.txt archivo2.txt // Renombrar un archivo o carpeta 

rmdir // Borrar una carpeta

rm nombre_fichero // Borrar un fichero

rm fichero1 fichero2 fichero3 // Borrar varios ficheros

rm -r /directorio // Para borrar una carpeta, se le da la ruta del directorio a borrar

rm * // Borrar todos el contenido de una carpeta, se debe estar dentro del directorio

rm -r * // Borrar todo el contenido de una carpeta, incluyendo las carpetas de ese directorio
se debe estar dentro del directorio

sudo rm -rf /xxx/xxxx // rm: Comando "remove", eliminar. -rf: r de "recursivo" donde se borra todo y f de "force";
nunca solicita confirmación. /xxx/xxx indica la ruta de los ficehros o carpetas a borrar.

sudo -i // Pedir contraseña root, algunas versiones basadas en Debian

su // Pedir contraseña del root

root@debian:/home/user# Ctrl + d //Para salir del root, tambien exit, funciona en algunas consolas como python, ruby, entre otras.

Ctrl + r // En la consola, para hacer una busqueda de comandos usados baasndose en la palabra que se introduzca

Shift + Page up <--> Page down // Moverse a traves de los logs de la consola, simula el scroll up/down del mouse

####################################
##### Editor de texto VI o VIM #####
####################################

// Es un editor de texto poderoso, muy usado en la comunidad de desarrolladores de Software Libre para escribir scripts, modificar ficheros
de texto en el shell, programar etc. No posee botones y todas sus funcionalidades se usan a traves de comandos.
Por lo general viene preinstalado en la mayoria de distribuciones, si no es así solo basta con un:

# apt-get install vim // con apt-get

# aptitude install vim // con aptitude

----------------

--- Modos de uso ---

// Al entrar a VIM para editar un fichero por primera vez, estamos en modo de comandos, quiere decir que no podemos editar el texto
sino que solo podremos usar comandos.

vim // Abrir vim, un fichero en blanco sin nombre ni contenido

i // Tecleamos i para entrar en modo de edicion, podemos insertar texto

escape // Pulsamos la tecla escape para salir del modo edicion o de cualquier otro modo, y volvemos al modo comandos.

:q // En modo comandos escribimos :q para salir del editor sin guardar

:q! // Salir del editor sin guardar ni pedir confirmacion

:w nombre_fichero.xxx //Guardamos un fichero nuevo, le asignamos el nombre y la extension si es necesario.

vim nombre_archivo.xxx // Nos aparecerá una ventana en negro, donde nos aparecerá el contenido del fichero o en negro si está vacío
// En la parte inferior, nos aparecerán los mensajes o comandos que escribamos para manejar el editor, así como la línea en la que estamos, porcentaje del fichero, etc.

:w // Guardar un documento

:wq! // Guardar y salir, esta accion aplica a un fichero ya creado, que estemos editando.

:f // Para saber el nombre y extensión del fichero abierto.

u // Deshacer el ultimo cambio

Ctrl + R // Rehacer el ultimo cambio

yy // Copiar la linea

dd // Eliminar una linea, en tal caso la corta y esta lista para pegarse

p // Pegar una linea cortada

guu // Convertir la linea actual en minusculas

gUU // Convertir la linea actual en mayusculas

g // Ir al principio del archivo

G // Ir al final del documento

w // navegar palabra por palabra en el fichero

:/palabra // Para hacer una busqueda de una palabra dentro del archivo
n // Para ir a la siguiente coincidencia.
N // Para ir a la coincidencia anterior

:123 // Ir a la linea (x) donde 123 es el número de linea a la cual queremos ir.

:syntax on // Sirve para dar color al codigo que estemos editando, VIM reconoce la sintaxis de muchos lenguajes y
la resalta en colores como muchos otros editores graficos como gedit, sublime, ninja, komodo, Geany.

En /etc/vim en el fichero vimrc descomentamos la linea 
"syntax on // Quitamos las (") para que quede activado directamente la coloracion de codigos

##############################################
########## Cambiar el pass del root ##########
##############################################

su: ****** // Acceder como root
passwd // Nos pedira que introduzcamos la nueva contraseña y la confirmacion para cambiar la clave de root

root@debian:/home/user# passwd
Introduzca la nueva contraseña de UNIX: ****** 
Vuelva a escribir la nueva contraseña de UNIX: ***** 
passwd: contraseña actualizada correctamente
root@debian:/home/user#

#########################################################
########## Instalacion de programas y paquetes ##########
#########################################################

$ man aptitude // Ver el manual de aptitude.

$ man apt-get

# apt-get install Nombre_Paquete // Instalar paquetes

# aptitude install Nombre_Paquete // Instalar paquetes, otra forma

# apt-get build-dep Nombre_Paquete // Intentará satisfacer las dependencias de compilación de un paquete fuente, el comando build-dep
busca en los repositorios locales en el sistema e instala las dependencias de construcción para el paquete. Si el paquete no existe en
el repositorio local se devolverá un código de error.

$ aptitude install -s Nombre_Paquete // Hace una simulacion de la instalacion, podemos ver que procesos haría la instalación

$ apt-get install -s Nombre_Paquete // Simulacion de instalacion con  apt-get install

$ apt-get source Nombre_paquete // Descargar las fuentes del paquete, para compilar e instalar. 

$ sudo aptitude search Nombre_Paquete // Realizar una busqueda en los repositorios del paquete que se quiere encontrar

$ aptitude show Nombre_Paguete // Para ver la informacion del paquete, version, estado, tamaño, conflictos, dependencias, etc.

$ apt-cache show nombre_paquete // Ver informacion del paquete, version, dependencias, descripcion, tamaño, entre otros.

$ apt-cache search nombre_paquete // Buscar un paquete en los repositorios.

# aptitude remove Nombre_paquete // Elimina o Desinstala el paquete.

# aptitude purge Nombre_Paquete // Elimina el paquete y sus archivos de configuracion.

$ aptitude download nombre_paquete // Descarga el fichero .deb del paquete dado al directorio actual.

# aptitude reinstall nombre_paquete // Reinstalar un paquete

$ aptitude update // Actualizar la lista de paquetes disponibles.

$ dpkg -l | grep nombre_paquete // Saber si un paquete está instalado y su version.

####################################################
##### Saber la version instalada de un paquete #####
####################################################

xxx --version // Saber la version de algun paquete que tengamos instalado.

Ejemplo:
    bash --version
    gcc --version
    python --version
    ruby --version


#####################################################
########## Comprimir/Descomprimir archivos ##########
#####################################################

paquete.tar y paquete.tar.gz  // tar se refiere a un formato de archivos ampliamente usado en
entornos UNIX identificados por el sufijo de archivo .tar.. Además hace referencia al programa
para la manipulación de archivos que es estándar en estos entornos, pero no incluye la
compresión de los mismos.

tar -cvf paquete.tar directorio // Comprimir un directorio, le damos los parametros de compresion, asi como el nombre del paquete
y el directorio que vamos a comprimir.

-c : indica a tar que cree un archivo
-x : extraer un archivo
-t : listar los contenidos de un archivo
-v : indica a tar que muestre lo que va empaquetando.
-f : indica a tar que el siguiente argumento es el nombre del fichero.tar
-z : comprimir a la vez que se empaqueta

tar -cvf paquete.tar archivo.txt // Creara un paquete con el nombre que le dimos y contiene el archivo.txt 

tar -xvf paquete.tar // Descomprimir un paquete

Descomprimir paquetes.tar.bz2
tar -xjvf example.tar.bz2

Ficheros o Directorios con .tar.gz:
Comprimir: tar -czvf paquete.tar.gz nombre_directorio
Comprimir: tar -czvf paquete.tar.gz nombre_fichero.xxx
Descomprimir: tar -xzvf paquete.tar.gz

Archivos .gz:
Comprimir: gzip -9 index.php
Descomprimir: gzip -d index.php.gz

-------------

Cuando nos iniciamos en Linux y buscamos un programa lo normal es que encontremos un .deb o .rpm y en muchos casos nos encontramos programas con
la extensión .tar.gz y .tar.bz2, estos archivos están comprimidos y por lo general contienen aparte del programa unas instrucciones para instalarlo.

La instalación para estos dos tipos de paquetes es exactamente igual, primero entramos a la carpeta donde tengamos el archivo.

$ cd directorio

$ tar -zxvf nombredelarchivo.tar.gz

$ tar -jxvf nombredelarchivo.tar.bz2

-Configuramos, con esta accion se configurara el paquete
para la posterior compilacion, si hacen falta paquetes "dependencias" para la compilacion
por lo general mostrara que paquetes faltan y fallará la configuracion.

$ ./configure

-Hacemos make (compilamos)

$ make

-Ahora make install

$ make install

################################
##### Descomprimir con RAR #####
################################

// Necesitamos instalar unrar

$ aptitude search unrar

Si no lo encuentra debemos bajar el source de http://www.unrarlib.org/
Nos bajara unrarsrc-3.7.8.tar.gz // Descomprimimos, nos dejara la carpeta (unrar)
luego: 
$ cd unrar
$ make -f makefile.unix
$ install -v -m755 unrar /usr/bin // Como root

// Ya deberíamos poder descomprimir .rar

Uso: unrar [OPTION...] ARCHIVE [FILE...] [DESTINATION]
-x, --extract              Extract files from archive (default)
-t, --list                 List files in archive
-f, --force                Overwrite files when extracting
    --extract-newer        Only extract newer files from the archive
    --extract-no-paths     Don't create directories while extracting
-p, --password             Decrypt archive using a password
-?, --help                 Give this help list
    --usage                Give a short usage message
-V, --version              Print program version

ejemplo:
$ unrar x archivo.rar // Para descomprimir un fichero .rar
$ unrar x archivo.rar /home/user/carpeta // Para descomprimir un fichero .rar dando la ruta

###########################################
##### Comprimir/ Descomprimir con ZIP #####
###########################################

$ sudo aptitude install zip // Instalar el paquete de zip

$ zip archivo.zip nombre_fichero.xxx

$ unzip archivo.zip // Descomprimir el fichero

$ zip -r carpeta.zip nombre_carpeta // Comprimir directorios y su contenido

#####################################
########## Instalar APACHE ##########
#####################################

$ sudo apt-get install apache2 // Instalar servidor apache, 127.0.0.1 o LocalHost es para iniciarlo

/var/www/ // Es la carpeta de donde podemos guardar nuestros proyectos, ficheros etc 
puesto que es la carpeta por defecto de Apache para ese fin.

$ chmod -R 777 /var/www/ // Cambiar los permisos de /var/www puesto que solo tiene permisos root, 
-R para que los permisos se hagan de forma recursiva, esto se hace porque al pegar ficheros
o carpetas estas no tiene los permisos de lectura/escritura necesarios.

sudo aptitude search php // Realizar una búsqueda en los repositorios del paquete que se quiere encontrar

http://192.xxx.xx.xxx/ //La direccion ip sirve para acceder al directorio del servidor

127.0.0.1:80 // Apache cuando está en ejecucion siempre está escuchando por el puerto 80
por lo que si visitamos 127.0.0.1:80 accederemos al servicio

Sus archivos e configuracion están en etc/apache2

$ sudo service apache2 restart // Restart apache para guardar los cambios

###############################################
########## Instalar y configurar PHP ##########
###############################################

apt-get install php5 php5-mysql php5-gd libapache2-mod-php5

// Una vez que se hayan descargado e instalado los paquetes de PHP, solo tienes que reiniciar el 
servidor Apache para que el servicio esté disponible. Para hacerlo solo tienes que teclear los siguientes comandos:

/etc/init.d/apache2 restart

// Para probar que tu servicio esta trabajando puedes crear un pequeño archivo y verlo en tu navegador.
// Para hacer esto puedes teclear los siguientes comandos:

nano /var/www/testphp.php

// agrega las lineas siguientes

<?php
// Muestra toda la información, por defecto INFO_ALL
phpinfo();
?>

Para ver este archivo abre tu navegador web y teclea la IP de tu servidor seguido del archivo que acabas de crear, por ejemplo:

http://127.0.0.1/testphp.php //Si aparece la pagina azul pastel de PHP se instalo correctamente

######################################################
########## Instalar y configurar phpMyAdmin ##########
######################################################

aptitude install phpmyadmin // Instalar

http://localhost/phpmyadmin // Acceder al servicio

***After the installation has completed, add phpmyadmin to the apache configuration.**

# sudo nano /etc/apache2/apache2.conf //Agregar en este archivo la configuracion de abajo

***Add the phpmyadmin config to the file.

Include /etc/phpmyadmin/apache.conf //Esta linea se agrega al final de la configuracion del apache para que reconozca el phpMyAdmin

/etc/init.d/xxx restart // xxx mysql, apache etc... restart


###########################################
########## Instalar MySQL server ##########
###########################################

apt-get install mysql-server

root@debian:/home/user# aptitude search mysql | grep mysql

# mysql -p //acceder al mysql

#############################################################################
##### Comandos para buscar ficheros, directorios, paquetes, historiales #####
#############################################################################

$ history // Mostrar el historial de los comandos de la consola

$ fc -l // Mostrar los ultimos comandos usados por el usuario

$ history | grep xxx // Busqueda especifica de una comando usado, ejemplo: aptitude, alias, grep etc.

.bash_history // En los archivos ocultos del home, en este fichero se almacena el historial de los comandos usados

$ grep --color=always -n "mysql" /var/www/prueba/2/datos.php // --color para colorear la palabra a buscar, 
-n para listar la la linea del caracter buscado y al final ra ruta del archivo a buscar

$ grep cadena_texto ./* -rIn //Busca la cadena de manera recursiva en la carpeta en que se encuentre situado

$ grep --color=always -n "cadena_texto" ./* -Ir //Busca la cadena de manera recursiva en la carpeta en que se encuentre situado

$ grep --color -n "cadena_texto" -Ir // No hace falta poner =always

$ egrep -r "Saludo" . //Otra forma de busqueda.

| grep xxx // filtra la busqueda con el parametro que le demos ejemplo:

$ aptitude search python | grep 2.7 // Busca las versiones de python que coincidan con el patron 2.7

$ ps -e | grep ruby // Busca en los procesos del sistema las coincidencias con ruby

$ whereis python // Para saber donde esta instalado un programa, saber el directorio
$ whereis firefox
$ whereis apache2

su:
find / -type f -name NombreArchivo.html // Para mostrar el directorio del archivo que se 
//quiera buscar, se debe saber el nombre del archivo

$ locate nombre_del_archivo // Hacer una busqueda de un archivo en los directorios, se puede especificar un nombre con su extensión
//o solo especificar una palabra, la busqueda se hara en todos los archivos que contengan la palabra o nombre de archivo escrita.

$ locate "*.jpg" // Buscar todos los ficheros con la extension especificada

$ sudo locate -c hola // Muestra cuantos archivos contienen la palabra "hola" en el nombre.

$ sudo locate -i hola // Busca todos los archivos que contienen la palabra "hola" en el nombre tanto en mayúsculas como en minúsculas.

$ sudo locate nombre_archivo > /home/usuario/lista.txt // Para guardar el resultado de la búsqueda en un archivo de texto.

$ sudo find / -name nombre_carpeta // (/) es para hacer la busqueda desde ahi en adelante, puede ser (/home/user)

$ find /carpeta // Lista los archivos que componen el directorio introducido

$ type nombre_comando // Busca la ruta donde se encuentra el comando, ejemplo: aptitude, python, etc.

$ which nombre_programa // Buscar la ruta de un programa

$ sudo find / -name "*nombre_fichero*" // Buscar en todo el sistema los ficheros cuyo nombre contengan la expresion escrita.

$ sudo find / -name "*.xxx*" // Buscar en todo el sistema los ficheros cuyo nombre contengan la expresion escrita, en este caso,
una extensión de fichero, donde / puede ser /home/user etc y .xxx la extension: .jpg, .png, .txt, .py, etc.

$ sudo find /home/user ! -name "*xxx*" // Busca todos los archivos que NO contienen la palabra "xxx" en el nombre, se especifíca el directorio en el cual buscar.

$ sudo find /home/user -iname "*xxx*" // Busca todos los archivos que contienen la palabra "xxx" en el nombre tanto en mayúsculas como en minúsculas.

$ sudo find /home/user/ -iname "*xxx*" > /home/user/lista.txt // Si el resultado de la búsqueda anterior te ha proporcionado una gran cantidad de información, resulta
más cómodo almacenar el resultado de la búsqueda en un fichero de texto para revisarlo posteriormente.

----------

$ wget -r www.host.com // Descargar el contenido de una web, los archivos del directorio

$ wget -r www.programador-de-software.blogspot.com

$ wget -c ftp://sunsite.doc.ic.ac.uk/ls-lR.Z // -c ó --continue, reanudar una descarga de wget si se detuvo por caída de red, cancelación de proceso, etc.

######################################################
####### GIT - Software de Control de Versiones #######
######################################################

Software de control de versiones diseñado por Linus Torvalds, pensando en la eficiencia
y la confiabilidad del mantenimiento de versiones de aplicaciones cuando éstas tienen un gran número de
archivos de código fuente. Hay algunos proyectos de mucha relevancia que ya usan Git
en particular, el grupo de programación del núcleo Linux.

$ aptitude install git // fast, scalable, distributed revision control system 

$ git // Con este comando nos listara la lista de comandos Git que podemos usar en un proyecto

$ git --version // Para saber que versión tenemos instalada.

//Lo primero que debemos hacer despues de la instalacion es configurar nuestro Git

$ git config --global user.name "Argenis Osorio" // Asignamos el nombre de usuario que será la firma del usuario en cada commit

$ git config --global user.email aosorio@example.com // igualmente el correo que siempre acompañara al autor de cada commit

$ git init // Crear un directorio, dentro del directorio ejecutar
para crear un nuevo repositorio de git.

$ git status // Muestra el estado actual de la rama, como los cambios que hay sin commitear.

$ git status -s // Lista los archivos del proyecto y se visualiza si fueron agregados al seguimiento de Git.
//Tambien podemos ver si un archivo fue modificado y no a sido agregado al seguimiento de Git.

$ git add * // Agregar todos los archivos al seguimiento de Git.

$ git commit -m "Primer commit del proyecto" //Hacer un commit al proyecto, se activara la rama master por defecto.

$ git log // Podemos ver todos los commits que se han hehco a un proyecto, fecha, autor, etc...

$ git branch // Lista todas las ramas locales.

$ git branch -a // Lista todas las ramas locales y remotas

// Ejemplo de archivos agregados al seguimiento de git:
A  gris.jpg // Agregado
A  principal.html // Agregado
AM principal2.html // Agregado y modificado, se debe agregar otra ver para aceptar los cambios
?? principal3.html // Archivo agregado al directorio pero no agregado al seguimiento de Git

$ git add Nombre_archivo.xxx // Agregar un fichero específico al seguimiento de Git

$ git rm Nombre_fichero.xxx // Borrar un fichero de manera segura, puesto que lo borra del directorio y del seguimiento de git, es un error
común borrar los archivos directamente y estos siguen estando en el seguimiento de git por lo que se lia bastantes veces
al subir los cambios, recomendable borrarlos desde git.

$ git rm -f Nombre_fichero.xxx // Forzar el borrado del fichero.

$ git rm --cached Nombre_archivo.xxx // Si un archivo fue modificado queda un registro de su nombre anterior en el cache
para borrarlo se esa este comando

$ git commit --amend -m "comentario commit corregido" // Corregir algun error en el texto del último commit

$ git commit --amend // Corregir un error en el commit, abrira un editor de texto

$ git reset --hard HEAD~1 // Borrar el ultimo commit hecho.

$ git checkout -b Nombre_Rama // Crear una rama y cambiarse a ella.

$ git branch -d Nombre_Rama // Borrar una rama, se debe estar en otra rama para borrarla

$ git branch -D Nombre_Branch // Forzar el borrado de una rama, a veces no se dejan borrar si hay cambios sin guardar.

$ git checkout Nombre_Rama // Cambiarse de rama

$ git branch -v // Para ver los ultimos commits de cada rama.

----- Mezclando Ramas -----

Para fusionar dos ramas, en este caso una rama de desarrollo con la rama master se hace un git merge, para realizar la mezcla vamos
a situarnos en la rama master escribimos el comando donde especificamos que rama queremos mezclar con master.

$ git checkout master // Cambiarsa a la rama master

$ git merge desarrollo // Mezclar la rama desarrollo con master

---------------------------

$ git checkout XXXXXX123456 // Este comando sirve para moverse entre los commits, cada commit genera una
etiqueta, un identificador muy largo alfanumerico, estas etiquetas identifican una version del proyecto
lo que permite restaurar el proyecto a estados anteriores donde XXXXXX123456 representa la etiqueta del commit al que queremos ir.

//Una vez movidos a ese commit especifico del historial se puede crear una nueva rama desde ese punto, si hacemos git log nos mostrara
los commits que habian hasta ese momento y el ultimo es en el que nos encontramos, si queremos volver a tener los commits anteriores 
solo hacemos git checkout a la rama en que estabamos antes o a alguna rama especifica.

$ git checkout -f master // Para forzar volver a la rama master por ejemplo, a veces no nos deja porque no commitemos algunos cambios, como logs, etc.

$ git diff // Si se hacen cambios o se agregaron archivos al proyecto este comando nos hará mostrara una comparacion entre los
ultimos cambios hechos el ultimo commit hecho, es recomendable revisar esos cambios antes de agregarlos al seguimiento de git
y por supuesto antes de hacer un commit.

---------

//Luego de hacer el commit en la rama master y luego de haber creado la rama desarrollo y hacer el commit
se pueden listar los commits de las ramas existentes y asi poder realizar comparacaiones entre las
diferentes versiones del codigo. En este caso se agregaron 2 lineas al <div id="cabecera"> de una plantilla del proyecto
//Usando los identificadores de cada commit se pueden comparar las versiones del software.

$ git branch -v
* desarrollo e6dcbf4 Modificacion de texto de la cabecera
  master     a537ef5 Primer commit
user@debian:~/DIV$ git diff a537ef5 e6dcbf4
diff --git a/principal.html b/principal.html
index 554fd4f..94b3eac 100755
--- a/principal.html
+++ b/principal.html
@@ -14,6 +14,8 @@
 
                <div id="cabecera">
                        CabeceraXXX
+                       CabeceraXXX
+                       CabeceraXXX
                </div>  
 
                <div id="cuerpo1">


$ git clone /home/directorio/proyecto/proyecto //Crea una copia local del repositorio se debe situar en la carpeta
donde se quiere hacer la copia y luego se le da la ruta del proyecto a copiar 

git clone https://xxx.xxx.gob.ve/xxx/xxx/xxx.git // Si esta subido en algun servidor 

---Recomendado---

*Cada desarrollador o equipo de desarrollo puede hacer uso de Git de la forma que le parezca
 conveniente. Sin embargo una buena práctica es la siguiente:

Se deben utilizar 4 tipos de ramas: Master, Development, Features, y Hotfix.

-Master: Es la rama principal. Contiene el repositorio que se encuentra publicado
en producción, por lo que debe estar siempre estable.

-Development: Es una rama sacada de master. Es la rama de integración, todas las nuevas
funcionalidades se deben integrar en esta rama. Luego que se realice la integración y se
 corrijan los errores (en caso de haber alguno), es decir que la rama se encuentre estable,
 se puede hacer un merge de development sobre la rama master.

-Features: Cada nueva funcionalidad se debe realizar en una rama nueva, específica para
esa funcionalidad. Estas se deben sacar de development. Una vez que la funcionalidad
esté pronta, se hace un merge de la rama sobre development, donde
se integrará con las demás funcionalidades.

-Hotfix: Son bugs que surgen en producción, por lo que se deben arreglar y publicar
de forma urgente. Es por ello, que son ramas sacadas de master. Una vez corregido
el error, se debe hacer un merge de la rama sobre master. Al final, para que no
quede desactualizada, se debe realizar el merge de master sobre development.

#############################################
######### Subir proyectos a GitHub ##########
#############################################

// Repositorio: Un repositorio, depósito o archivo es un sitio centralizado donde
se almacena y mantiene información digital, habitualmente bases de datos o archivos informáticos.

1- Crearnos una cuenta en GitHub

2- Crear un repositorio, desde la intefáz gráfica de github nos pedirá el nombre para el repositorio
ese repo tendra una URL asignada, ejem: https://github.com/name_user/name_repo

3- La forma mas rápida de subir un proyecto al repositorio creado es bajando ese repositorio creado, clonandolo en nuestro directorio,
al clonarlo ya viene configurado con los ficheros de git lo que nos permitira hacer push directamente sin hacer mayores esfuerzos.

$ git clone https://github.com/name_user/name_repo.git // Clonamos el repositorio del proyecto, se guardará en nuestro directorio

$ cd name_repo/ //Nos cambiamos a la carpeta del proyecto, 

4- Una vez hecho es veremos una carpeta local con el nombre de nuestro repositorio de GitHub
esta carpeta estará vacía, dentro de la carpeta irá el proyecto que queremos subir. Ahora metemos dentro de la carpeta
todos los directorios y ficehros de nuestro proyecto.

$ git add . // Para agregar todos los archivos que pegamos al seguimiento de git.

$ git commit -m "Comentario" // Hacemos el primer commit del proyecto, ejemplo: "Primer commit" o "Caga inicial del proyecto"

$ git push origin master // Este comando es para subir el proyecto directamente a la rama master de nuestro repo.

// Cabe mencionar que en el directorio .git descargado, en el archivo config estará por defecto
escrita la URL de nuestro repo, lo que facilita subir los proyectos y los cambios directamente, por ello 
el paso de la clonacion del repo.

// Antes de subir los cambios nos pedira el user y pass de la cuenta github para realizar la autenticación

user@debian:~/MiProyecto$ git push origin master
Username for 'https://github.com': user
Password for 'https://user@github.com': ************
Counting objects: 14, done.
Delta compression using up to 4 threads.
Compressing objects: 100% (13/13), done.
Writing objects: 100% (13/13), 45.99 KiB, done.
Total 13 (delta 0), reused 0 (delta 0)
To https://github.com/user/proyecto.git
   af47064..228246e  master -> master

// Listo ya deberias porder ver tu proyecto en github

$ git push origin --delete your_branch // Eliminar una rama en tu GitHub o en tu repositorio remoto.

$ git push origin :your_branch // Eliminar una rama, alternativa al anterior.

$ git push origin +master // Para borrar o deshacer un commit en github, se debe primero borrar el commit 
de manera local, luego volvemos a subir el proyecto con este comando para que quede como estaba.

#########################################
########## Terminal Terminator ##########
#########################################

//Gran herramienta para los desarrolladores, permite abrir multiples terminales
y poder ordenarlos, muy personalizable, entre muchas otras cosas. **RECOMENDADO**

Paquete: terminator / multiple GNOME terminals in one window

aptitude install terminator // Para instalarlo
apt-get install terminator

Dentro de Terminator:
Ctrl + Shift + o // Abrir un terminal horizontal y paralelo
Ctrl + Shift + e // Abrir un terminal vertical y paralelo
Alt + flechas // Moverse por los terminales
Ctrl + Shift + w // Cerrar un terminal
Ctrl + Shift + x // Maximizar un terminal, igual para salir
Ctrl + Shift + z // Maximizar un terminal(aumentado), igual para salir
Ctrl + Shift + flechas // Cambiar el tamaño a voluntad de un terminal
Ctrl + (+) // Aumentar tamaño de fuente, el (+) del Qwerty
Ctrl + (-) // Minimizar tamaño de fuente, el (-) del Qwerty 
Ctrl + d // Si no hay sesion de usuario abierta, como root y otros cerrará la pestaña o ventana.

-----------------

################################################
########## Ambiente virtual en Python ##########
################################################

// Cuando se desarrollando software con Python, quizas se presente el problema de tener utilizar diferentes versiones de una mismo paquete en
diferentes proyectos, ya sea el mismo Python o diferentes versiones de un Framework como Django por ejemplo, el problema a solucionar radica
en como poder instalar las dos o mas versiones de la misma librería con el fin de poder desarrollar varios proyectos de forma simultánea.

La solución consiste en crear virtualenvs o entornos virtuales. Un entorno virtual de Python es un espacio completamente independiente
de otros entornos virtuales y de los paquetes instalados globalmente en el sistema. Esto significa que es posible instalar la versión
2.7 de Python en un entorno virtual y la versión 3.0 en otro diferente o de forma global sin problema alguno.

El porder tener diferentes entornos donde podemos instalar diferentes versiones de paquetes nos da la oportunidad de hacer un desarrollo simultaneo
así como poder hacer pruebas si afectar a los paquetes del sistema global.

--- Instalación: ---

$ aptitude install python-virtualenv virtualenvwrapper // Para crear un ambiente virtual instale las herramientas
python-virtualenv y virtualenvwrapper

$ mkvirtualenv nombre_ambiente_virtual //  Con un usuario (diferente a root) cree un ambiente virtual para su proyecto.

$ workon nombre_ambiente_virtual // Para acceder al nombre del ambiente virtual creado

ejemplo: 
user@debian:/home$ workon proyecto // Accedemos al entorno virtual creado
(proyecto)user@debian:/home$ // Ya estamos en el entorno virtual creado, denotado por el nombre del entorno al inicio del prompt

$ deactivate nombre_ambiente_virtual // Para salir del entorno virtaul, o simplemente deactivate

$ lsvirtualenv // Para listar los entornos virtuales creados o disponibles.

$ rmvirtualenv nombre_virtualenv // Remover o borrar un entorno virtual.

// Los entornos virtuales se crean en el directorio /home/user/.virtualenvs

########################
##### Paquetes pip #####
########################

// Para desarrollar software con rapidez y calidad, es imprescindible utilizar paquetes externos que ayuden
con parte de la funcionalidad que se desea implementar. En el ambiente Python esto no es la excepción.

// Para solventar ésta necesidad, la comunidad Python ha puesto convenientemente a disposición de los desarrolladores
un repositorio de paquetes de fácil acceso llamado PyPi. Solo es necesario ejecutar un comando en la terminal
para poder instalar el paquete Python que necesitemos. Incluso es posible instalar paquetes que no se encuentren
en el mencionado repositorio.

// Para descargar paquetes del repositorio PyPi se pueden utilizar varias herramientas, pero en este caso se
va a usar pip. Es necesario instalar esta herramienta en el sistema en caso de no estar disponible, antes
de poder instalar un paquete Python.

// El comando pip equivale al apt-get de Debian pero para paquetes Python.

$ aptitude install python-pip python-dev python-setuptools // Instalamos PIP y otros necesarios

// Una vez instalado ya podremos instalar paquetes de Python a traves de pip ejemplo:

$ pip install django // Nos instalara la ultima version de Django disponible en los paquetes pi

$ pip install django==1.7 // Instalar una versión específica de algun paquete.

// Tambien es posible crear ficheros que contengan rutinas para automatizar la instalacion
de varios paquetes ejemplo:

Creamos un requirements.txt y dentro escribimos como ejemplo:
django==1.5.12
pillow==2.4.0
Geraldo==0.4.17

// Luego podemos ejecutar un pip install sobre el fichero e instalará lo que contenga:

pip install -r requirements.txt

// Dentro de los .virtualenvs, dentro de nuestro entorno virtual en
lib/python2.7/site-packages podemos ver que se instalaron los paquetes de requirements.txt
de no ser así hay que revisar el fichero o el nombre de los paquetes a instalar, etc.

$ pip search nombre_paquete // Buscar un paquete.

#############################################
########## Conexion remota con ssh ##########
#############################################

SSH (Secure SHell) es el nombre de un protocolo y del programa que lo implementa, y sirve para acceder
a máquinas remotas a través de una red. Permite manejar por completo la computadora mediante un intérprete
de comandos, y también puede redirigir el tráfico de X para poder ejecutar programas gráficos si tenemos ejecutando un Servidor X (en sistemas Unix y Windows).

Además de la conexión a otros dispositivos, SSH nos permite copiar datos de forma segura
(tanto archivos sueltos como simular sesiones FTP cifradas), gestionar claves RSA para no escribir
claves al conectar a los dispositivos y pasar los datos de cualquier otra aplicación por un canal seguro tunelizado mediante SSH.

$ ssh Nombre_usuario@IP_servidor o nombre_servidor

ssh user@192.168.0.240 // Asi se accede a un ordenador o servidor remoto, debemos poner el usuario que debe estar creado asi como la ip
del server, nos pedira la clave de session, una vez adentro tenemos acceso a los archivos y podemos pedir el root para tener acceso total.
ssh es muy usado por administradores de redes y de sistemas para acceder a las maquinas y los servidores y hacer cambios asi 
como monitorear los procesos que esten ejecutando, especialmente en maquinas virtuales si varios proyectos corren en un mismo servidor.

Conectado al servidor, podemos enviar mensajes o abrir programas remotamente, ejemplo:

echo "mensaje" > /dev/pts/2 // Enviar mensaje a traves del shell a otro usuario, en el servidor o local, debe haber un shell abierto que sea receptor
Se puede hacer localmente para probar, con (who) veremos la identificacion de cada shell, si estamos conectados remotamente, comprobaremos si hay shells
abiertos en el local y el servidor, se identifican con los pts/0, pts/1, etc, y sabremos por la ip si son shells locales o del server  el mensaje sale en
el shell escogido.

$ export DISPLAY=:0.0 // Creamos la ventana virtual donde se abrira la aplicacion que ejecutemos, luego
$totem o $nautilus // Deberia abrir el programa en el servidor, ya esportada la ventana podemos:

DISPLAY=:0.0 totem // Abrir el reproductor totem en el servidor

DISPLAY=:0.0 nautilus // Abrir el explorador de archivos en el servidor

--- COPIAR ARCHIVOS DE LOCAL A SERVIDOR ---
Si queremos subir el archivo archivo.txt de nuestro ordenador a la carpeta /home/usuario del servidor, hacemos lo siguiente:

$ scp archivo.txt usuario@dominio.com:/home/usuario // Se especifica el archivo a copiar, luego el servidor y luego el directorio 
en el servidor donde copiaremos el archivo.

--- COPIAR ARCHIVOS DE SERVIDOR A LOCAL ---
Si queremos copiar el fichero archivo.txt del servidor a nuestro ordenador en la carpeta Documentos, hacemos lo siguiente:

$ scp usuario@dominio.com:/home/usuario/archivo.txt /home/usuario/Documentos // Especificamos el servidor, luego la ruta y el archivo a copiar y luego el directorio local donde sera copiado el archivo.

--- COPIAR ARCHIVOS DE SERVIDOR A SERVIDOR ---

$ scp usuario1@dominio1.com:/home/usuario1/archivo.txt usuario2@dominio2.com:/home/usuario2/

--- COPIAR UN DIRECTORIO COMPLETO DE LOCAL A SERVIDOR ---
Para copiar un directorio completo de mi ordenador al servidor, por ejemplo /home/mario/carpeta a /home/usuario, añadimos un -r en el comando:

$ scp -r /home/mario/carpeta usuario@dominio.com:/home/usuario

--- COPIAR UN DIRECTORIO COMPLETO DE SERVIDOR A LOCAL ---
Para copiar un directorio completo del servidor al local, por ejemplo /home/usuario/carpeta a /home/user/docs, añadimos un -r en el comando:

$ scp -r usuario@dominio.com:/home/usuario/carpeta /home/user/docs

####################################################################
##### Conexion por nautilus explorador de archivos/directorios #####
####################################################################

Usando el navegador de archivos de Debian, Ubuntu, etc, podemos acceder a ordenador remoto "servidor" para ver graficamente 
los directorios, es decir, desde nuestro navegador de archivos, navegaremos en los directorios del servidor, para acceder vamos a:

$ nautilus

Archivo > Conectar con el servidor // Nos saldrá una ventana para llenar con:

Servidor: 192.168.12.400 // Aqui va la ip del servidor
Puerto: 22 // El puerto que tiene habilitado el ssh_config
Tipo: SSH
Carpeta: /home // Carpeta que abrira al entrar en conexion
Nombre de usuario: // Nombre de usuario, de sesion de ese servidor
Contraseña: // Contraseña de la sesion de usuario del servidor

Si todo esta bien deberia entrar a explorar los directorios del servidor.

###########################################
##### X11 forwarding a través de ssh  #####
###########################################

X11, como supongo la mayoría de Uds. sabrá, es el servidor gráfico que usan casi todas las distribuciones Linux. Este servidor permite, entre otras cosas,
forwarding a través de SSH. Esto significa que es posible ejecutar apliaciones gráficas de una máquina remota exportando el display a nuestro escritorio.
Es decir, la aplicación se ejecuta en el servidor remoto, pero la interfaz gráfica la visualizamos en nuestro escritorio local.

Ejemplo:
1- En el servidor, editar el archivo /etc/ssh/ssh_config y modificar la opción X11Forwarding o ForwardX11 para que quede así:

X11Forwarding yes

ó

ForwardX11 yes

Luego de este cambio, posiblemente sea necesario reiniciar el demonio ssh. La forma de hacer esto varía de acuerdo a cada distribución Linux.
Lo más sencillo es reiniciar la máquina.

2- En el escritorio local, loguearse al servidor a través de ssh utilizando el parámetro -X:

$ ssh -X user@hostname

Donde user es el nombre de usuario utilizado para loguearse en el servidor y hostname es el ip o el alias del servidor.

3- Para ejecutar una aplicación, simplemente hay que hacerlo desde el terminal. Por ejemplo:

$ firefox

$ nautilus

$ evince

#############################################
##### Programación shell-script (bash) ######
#############################################

--- ¿Qué es un "Script"? ---

Es un archivo que contiene código escrito en determinado lenguaje de programación que el sistema usa para determinada tarea.
No es necesario que tenga una entrada externa ni interfaz gráfica, pero sí que provoque una salida de datos procesados
(por más de que el usuario no los vea).

El lenguaje usado por Bash está definido por su propio intérprete y combina la sintaxis de otros Shells, como el Korn Shell (ksh) o el C Shell (csh).
Muchos de los comandos que usualmente se usan en la consola también pueden usarse en los scripts, salvo aquellos que pertenecen estrictamente a una
distribución en particular.

--- Estructura de un Script ---

Para empezar debemos contar con un editor de texto, los archivos que guardamos con extensión .sh podrán ser ejecutados (o interpretados) por la consola
siempre y cuando la primera línea sea la siguiente:

#!/bin/bash

Esto le dice al sistema que deberá usar la consola para ejecutar el archivo. Además, el carácter # permite escribir comentarios.

echo // muestra un mensaje en pantalla, en este caso el típico "Hola Mundo". Si lo guardamos y ejecutamos con la consola veremos el resultado.

Bash (y otros shells) permiten programar scripts
--Bash (Bourne again shell) es un programa informático cuya función consiste en interpretar órdenes.
Está basado en la shell de Unix.

Script o programa shell: Fichero de texto conteniendo comandos externos e internos
que se ejecutan línea por línea, el programa puede contener, además de comandos
variables, constructores lógicos (if...then, AND, OR, etc.) y lazos (while, for, etc.)
funciones comentarios

--- Ejecución de un script ---

Los scripts deben empezar por el simbolo #! seguido del programa a usar para interpretar el script:

#!/bin/bash // Script de bash
#!/bin/sh // Script de shell
#!/usr/bin/perl // Script de perl

----------------------------

#Ejemplo de programa en bash para imprimir valores de variables
#!/bin/bash
VAL=10
VAL2=20
echo $VAL
echo $VAL2

----------------------------

Guardamos el script, ejemplo: prueba.sh, no es necesario ponerle
la extensión ya que la cabecera del script especifíca que programa
lo interpretará

Ejecución:

sh prueba.sh // Ejecutar un programa con bash.

bash prueba.sh // Ejecutar un programa con bash.

./script.sh // Otra manera de ejecutar el script.

sh prueba // Ejecutar un programa con bash, script guardado sin extension.

------------------------

#Ejemplo de programa en bash para ejecutar aplicaciones instaladas en el SO.
#!/bin/bash
#val=10
val1='#########################\n'
val2='##### Abriendo Meld #####\n'
val3='#########################\n'
#echo $val1
#echo $val2
#echo $val3
echo $val1 $val2 $val3
/usr/bin/meld

------------------------

#Usando una funcion, y viendo el funcionamiento de variables locales y globales.
#!/bin/bash
HOLA=Hola_global
function hola {
    local HOLA=Mundo_local
    echo $HOLA
}
echo $HOLA
hola
echo $HOLA

-----------------------

#Llamado de una Funcion
#!/bin/bash
a='Estaba la pájara pinta'
function Imprimir {
    local a='sentada en un verde limón.'
    echo $a
}
echo $a
Imprimir
#echo $a

#################
##### RSYNC #####
#################

Es una aplicación que ofrece transmisión eficiente de datos, que opera también con datos comprimidos y cifrados.
Mediante una técnica de delta encoding, permite sincronizar archivos y directorios entre dos máquinas de una red
o entre dos ubicaciones en una misma máquina, minimizando el volumen de datos transferidos.
Muy recomendable para hacer respaldos en discos externos.

aptitude install rsync // Instalarlo desde los repositorios de debian

Parametros: -P para mostrar el progreso de la copia y -r cuando se van a copiar directorios

rsync -P ficehero /directorio/carpeta2 // Para copiar ficheros, archivos, etc. 

rsync -P -r /directorio/carpeta1 /directorio/carpeta2 // -r para copiar directorios
se ponen las dos rutas: origen y destino separados por un espacio.

##################################
##### Crear alias de comandos #####
##################################

Un alias es una palabra o frase que se asignara para 
remplazar un comando, por lo generalmente se usa para
remplazar comandos muy largos y dificiles de recordar
por lo que es una gran ventaja la creacion de alias.

Un alias Se pueden crear temporalmente, directamente en la consola
y durara hasta que cerremos ese shell, tambien asignar permanentemente
escribiendolo en el archivo .bashrc que esta en el /home 

$ alias nombre_alias='comando'

Ejemplo:
$ alias sa='aptitude search apache | grep rt4' // (sa) ahora es el alias de 
ese comando de busqueda en los repositorios de un paquete especifico.

$ unalias nombre_alias // Para eliminar el alias creado temporalmente

// Para que se haga efectivo algun cambio en .bashrc es necesario reiniciar
pero hay otra forma de actualizar el fichero sin reiniciar, entonces:

$ source .bashrc // Bastara para que se apliquen los cambios hechos

// Mensaje de bienvenida al usuario

Pegamos esto al final del .bashrc, reiniciamos el fichero
y ahora cada vez que iniciemos un shell nos saludará.

## Mensaje al iniciar
echo "Hola Usuario"

########################################################
### Saber la direccion ip de una pagina o un sevidor ###
########################################################

user@debian:~$ nslookup google.com // Saber la de google por ejemplo
Non-authoritative answer:
Name:   google.com
Address: 216.58.192.110 // Direccion ip de google

--- Otra forma ---

$ ping google.com // Haciendo ping al una pagina 
PING google.com (216.58.192.110) 56(84) bytes of data.
64 bytes from mia07s35-in-f14.1e100.net (216.58.192.110): icmp_req=1 ttl=49 time=69.6 ms // Ip de google
64 bytes from mia07s35-in-f14.1e100.net (216.58.192.110): icmp_req=2 ttl=49 time=70.4 ms

--- google.com ping statistics ---
3 packets transmitted, 2 received, 33% packet loss, time 2001ms
rtt min/avg/max/mdev = 69.645665/70.00475/470.48645/0.010 ms

########################################
##### Compilar e instalar paquetes #####
########################################

$ aptitude search build-essential // Este paquete es esencial para crear y manejar paquetes debian,
por consiguiente para la creación, compilacion e instalación de programas en debian, ubuntu etc.
Tambien se instala cuando se va a desarrollar con c y c++ puesto que la instalacion incluye
los compiladores y las librerias necesarias para comenzar a trabajar en estos lenguajes.

Descargámos el código fuente del programa que queremos compilar e instalar.
Normalmente lo encontraremos en un archivo comprimido, con extensión tar.bz2. 
Así que tendrás que descomprimirlo escribiendo en la consola:

$ tar xvzf paquete.tar.gz (o ver sección de Comprimir/Descomprimir archivos arriba)

//Ahora vamos al directorio donde hemos extraído el contenido del paquete:
$ cd path_del_paquete

// Confguramos el modo de compilación con:
./configure

Luego escribimos:
make

Y finalmente, instalamos con:
make install

// Si no hay errores ya deberíamos poder usar el programa instalado.

###########################################
##### Estructura de un paquete fuente #####
###########################################

Un paquete fuente generalmente consiste de tres archivos: uno .dsc, uno .orig.tar.gz y uno .debian.tar.gz (o .diff.gz). Ellos permiten la creación
de paquetes binarios (.deb) a partir de los archivos de código fuente del programa, escritos en un lenguaje de programación.
El archivo .dsc («Debian Source Control»: control de fuente Debian) es un archivo de texto corto que contiene una cabecera RFC 2822 que describe el paquete
fuente e indica qué otros archivos forman parte del mismo. Está firmado por su encargado, lo que garantiza su autenticidad.

# Ejemplo 5.1. Un archivo .dsc

-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA256

Format: 3.0 (quilt)
Source: zim
Binary: zim
Architecture: all
Version: 0.62-3
Maintainer: Emfox Zhou <emfox@debian.org>
Uploaders: Raphaël Hertzog <hertzog@debian.org>
Homepage: http://zim-wiki.org
Standards-Version: 3.9.6
Vcs-Browser: http://anonscm.debian.org/gitweb/?p=collab-maint/zim.git
Vcs-Git: git://anonscm.debian.org/collab-maint/zim.git
Build-Depends: debhelper (>= 9), xdg-utils, python (>= 2.6.6-3~), libgtk2.0-0 (>= 2.6), python-gtk2, python-xdg
Package-List:
 zim deb x11 optional arch=all
Checksums-Sha1:
 ad8de170826682323c10195b65b9f1243fd75637 1772246 zim_0.62.orig.tar.gz
 a4f70d6f7fb404022c9cc4870a4e62ea3ca08388 14768 zim_0.62-3.debian.tar.xz
Checksums-Sha256:
 19d62aebd2c1a92d84d80720c6c1dcdb779c39a2120468fed01b7f252511bdc2 1772246 zim_0.62.orig.tar.gz
 fc2e827e83897d5e33f152f124802c46c3c01c5158b75a8275a27833f1f6f1de 14768 zim_0.62-3.debian.tar.xz
Files:
 43419efba07f7086168442e3d698287a 1772246 zim_0.62.orig.tar.gz
 725a69663a6c2961f07673ae541298e4 14768 zim_0.62-3.debian.tar.xz

-----BEGIN PGP SIGNATURE-----
Version: GnuPG v2
Comment: Signed by Raphael Hertzog

iQEcBAEBCAAGBQJUR2jqAAoJEAOIHavrwpq5WFcH/RsdzCHc1oXXxHitU23hEqMj
T6ok29M1UFDJDowMXW75jQ1nT4WPUtvEGygkCHeoO/PvjEvB0sjU8GQlX+N9ddSB
aHfqfAYmVhADNGxrXQT5inZXUa8qGeeq2Sqf6YcWtsnuD56lDbvxkyf/XYopoIEl
oltfl05z/AI+vYsW482YrCz0fxNAKAvkyuPhDebYI8jnKWeAANoqmKpsNc/HYyvT
+ZiA5o57OiGdOKT6XGy3/FiF3dkHiRY8lXW7xdr1BbIgulwl9UmiUNwuxwOYbQO7
edtjiTJqOaFUA0x1zB/XGv5tHr1MjP8naT+kfVoVHTOox51CDbeu5D3DZY4imcY=
=Wtoa
-----END PGP SIGNATURE-----

Note que el paquete fuente también tiene dependencias (Build-Depends) completamente distintas de aquellas del paquete binario ya que
indican las herramientas necesarias para compilar el software en cuestión y construir su paquete binario. 

PRECAUCIÓN Espacios de nombres distintos

Es importante saber que no hay una correspondencia necesaria entre el nombre de un paquete fuente y el de el o los paquetes binarios que genera. Es suficientemente fácil de entender si sabe que cada paquete fuente puede generar varios paquetes binarios. Es por esto que el archivo .dsc tiene los campos Source y Binary para nombrar explícitamente el paquete fuente y almacenar la lista de paquetes binarios que genera, respectivamente.

CULTURA Porqué dividir en varios paquetes
Frecuentemente un paquete fuente (para un programa dado) puede generar varios paquetes binarios. La división es justificada por la posibilidad de utilizar (partes de) el mismo en varios contextos. Si consideramos una biblioteca compartida, ésta puede ser instalada para hacer funcionar una aplicación (por ejemplo, libc6) o para desarrollar un nuevo programa (libc6-dev sería el paquete correcto). Encontramos la misma lógica para servicios cliente/servidor donde deseamos instalar el servidor en una máquina y la parte cliente en otras (este es el caso, por ejemplo, de openssh-server y openssh-client).
Tan frecuentemente también se provee la documentación en un paquete dedicado: el usuario puede instalarla independientemente del software y puede elegir eliminarla en cualquier momento para ahorrar espacio en disco. Adicionalmente, esto también ahorra espacio en disco en las réplicas Debian ya que todas las arquitecturas comparten los paquetes de documentación (en lugar de tener la documentación duplicada en los paquetes para cada arquitectura).

PERSPECTIVA Diferentes formatos de paquetes fuente
Originalmente sólo existía un formato de paquete fuente. Este es el formato 1.0 que asocia un compendio .orig.tar.gz con un parche de «debianización» .diff.gz (también hay una variante que consiste de un simple compendio .tar.gz, utilizada automáticamente si hay disponible un archivo .orig.tar.gz).
Desde Debian Squeeze, los desarrolladores Debian tienen la opción de utilizar nuevos formatos que corrigen varios problemas del formato histórico. El formato 3.0 (quilt) puede combinar varios compendios de origen en el mismo paquete fuente: puede incluir compendios .orig-componente.tar.gz además del .orig.tar.gz usual. Esto es útil con el software distribuido desde origen en varios componentes pero para el que se desea sólo un paquete fuente. Estos compendios también puede comprimirse con bzip2 o xz en lugar de gzip, lo que ahorra espacio en disco y recursos de red. Finalmente, se reemplaza el parche monolítico .diff.gz por un compendio .debian.tar.gz que contiene las instrucciones de compilación y un conjunto de parches al origen contribuidos por el desarrollador del paquete. Estos últimos son registrados en un formato compatible con quilt — una herramienta que facilita la gestión de una serie de parches. 

HERRAMIENTA Descomprimiendo un paquete fuente
Si tiene un paquete fuente, puede utilizar dpkg-source (del paquete role="pkg") para descomprimirlo:

$ dpkg-source -x package_0.7-1.dsc

También puede utilizar apt-get para descargar un paquete fuente y descomprimirlo inmediatamente. Necesita, sin embargo, que las líneas deb-src apropiadas estén presentes
en el archivo /etc/apt/sources.list. Éstas son utilizadas para listar los orígenes de los paquetes fuente (los servidores en los que se encuentran un grupo de paquetes fuente).

$ apt-get source package

#################################
### DIA - Editor de diagramas ###
#################################

Es un editor de diagramas, grafos, gráficas, etc. Ofrece soporte para diagramas de estructuras
estáticas en UML (diagramas de clases), diagramas de  Entidad-Relación, diagramas de redes y mucho más.
Los diagramas se pueden exportar a postscript y a otros formatos.

$ aptitude install dia

################
##### Meld #####
################

Es una herramienta gráfica para hacer archivos diff y fusionarlos.
Permite al usuario ver los cambios entre, y fusionar, dos archivos, dos directorios, o dos archivos con un ancestro común.

$ aptitude install meld

########################################
##### Cambiar permisos de usuarios #####
########################################

Al ver los permisos de los ficehros o directorios nos encontramos con varios parametros:

En la primera columna se pueden ver una serie de letras y guiones (-rwxr-x---)
estas letras nos dicen quien en el sistema, y que clases de permisos tiene el fichero o carpeta.

Estas letras están agrupadas en tres grupos con tres posiciones cada uno
más una primera posición que nos dice de que clase de archivo se trata
(los mas normales (d) directorios, o (-) archivos de datos).

El primer grupo de tres (rwx en nuestro caso) nos dice que clase de permisos tiene el dueño del fichero (u)(user/owner)
El segundo grupo de tres (r-x en nuestro caso) nos dice que clase de permisos tiene el grupo del fichero (g)(group).
Y el último grupo de tres (--- en nuestro caso) nos dice que clase de permisos tienen todos los demás usuarios del sistema sobre este
fichero (o)(others).

r :significa permiso para leer 
w :significa permiso para escribir  
x :significa permiso para ejecutar

u :permisos para el usuario/dueño del fichero/directorio
g :permisos de grupos
o :permisos de los demás usuarios

Los permisos se pueden especificar de diferentes maneras, una serie de ejemplos, es lo mejor para comprenderlo:

chmod ugo+rwx (da permisos rwx a todos, user,group,others)
chmod ugo-x test (quita permiso x (ejecucion) a todos, user,group,others) 
chmod o-rwx test (quita permisos rwx a others) 
chmod u=rwx,g=rx (da permisos rwx a user, rx a group y ninguno a others)

chmod -R u=rwx,g=rx,o=rx /dir/dir2/dir3 // Ejemplo de como otorgar permisos a un directorio específico.

##### chmod en octal ######

Representación octal de chmod

Lectura tiene el valor de 4
Escritura tiene el valor de 2
Ejecución tiene el valor de 1

Entonces:

rwx |  7  | Lectura, escritura y ejecución
rw- |  6  | Lectura, escritura
r-x |  5  | Lectura y ejecución
r-- |  4  | Lectura
-wx |  3  | Escritura y ejecución
-w- |  2  | Escritura
--x |  1  | Ejecución
--- |  0  | Sin permisos

Por lo tanto:

chmod u=rwx,g=rwx,o=rx  | chmod 775 |
chmod u=rwx,g=rx,o=     | chmod 760 |
chmod u=rw,g=r,o=r      | chmod 644 |
chmod u=rw,g=r,o=       | chmod 640 |
chmod u=rw,go=          | chmod 600 |
chmod u=rwx,go=         | chmod 700 |

################################################
##### CCLive - Descargar videos de youtube #####
################################################

CCLive es una aplicación que nos permite descargar un vídeo que esté en YouTube
hacia nuestro ordenador mediante un simple comando. Por defecto guarda los vídeos en webm.

$ aptitude show cclive //Para ver si lo tenemos en los repos, y ver la descripción, si es así.

$ aptitude install cclive // Instalación, como root.

ó

$ sudo apt-get install cclive // Instalación, como root.

$ cclive https://www.youtube.com/watch?v=yWVrvce5R9 // Descargar un video pasando la url de youtube.

$ cclive URL1 URL2 URL3 URL4 // Soporta varias URLs a la vez, para bajar mas de 1 video.

$ cclive < urls.txt // Descargar un vídeo detrás de otro, desde un archivo de texto plano con todas las URLs (en líneas diferentes).

$ man cclive // Manual del paquete.

$ cclive -F https://www.youtube.com/watch?v=Lfj667lLLnE // Comprobar los formatos disponibles antes de descargar el video.
// Se podrá ver un listado de formatos disponibles separados por "|"

$ cclive -f fmt22_720p https://www.youtube.com/watch?v=LtzFg4JiL5E // Se elige el formato y se pasa en el comando.

###############################
##### Cifrado de ficheros #####
###############################

El cifrado simétrico y asimétrico.

-En el cifrado simétrico, ciframos el archivo con una clave X
Para descifrarlo y obtener el archivo original, utilizamos la misma clave X.

-El cifrado asimétrico es más complicado. Aquí no tenemos una sola clave común. En su lugar
cada persona tiene dos claves, una pública y una privada. Para enviarle un archivo a un amigo
lo cifras con su clave pública. De esta forma, sólo lo puede descifrar él con su clave privada.
Es más seguro que el cifrado simétrico, ya que la clave de descifrado (la privada) nunca se
comparte, siempre la tiene el receptor.

Ejemplo: Sabiendo lo anterior, si queremos que tres compañeros de trabajo nos manden un archivo
cifrado debemos de mandarle nuestra clave pública (que está vinculada a la privada) y nos
podrán mandar de forma confidencial ese archivo que solo nosotros podremos
descifrar con la clave privada.

--- ¿Qué es GnuPG? (GNU Privacy Guard) ---

Es un derivado libre de PGP y su utilidad es la de cifrar y firmar digitalmente, siendo además
multiplataforma (podéis descargarlo desde la página oficial) aunque viene incorporado en algunos
sistemas Linux, como en Ubuntu o Debian.

##### Cifrado simétrico #####

El cifrado simétrico es el tipo de cifrado más sencillo que hay, es más rápido de procesar y por desgracia
menos seguro que el cifrado asimétrico.

Crear un fichero cualquiera de ejemplo

$ touch prueba.txt

Dentro del fichero copiaremos algun texto de prueba para comprobar luego con el descifrado.

Luego en el shell escribimos el comando gpg con el parámetro -c para cifrar y -d para descifrar.

--- Parámetros básicos de gpg ---

-c // Encrypt with a symmetric cipher using a passphrase. The default symmetric cipher used is CAST5,

-d // Decrypt the file given on the command line

$ gpg -c prueba.txt // El comando gpg -c nombre_fichero nos aparecerá un cuadro que nos pide la contraseña
luego una confirmacion de la misma, luego  generará un archivo .gpg

Para descifrarlo usamos el comando gpg -d notas.txt.gpg introduciendo la contraseña correcta para poder decifrarlo.

$ gpg -d prueba.txt.gpg // Descifrar el fichero, nos permitira mirar el contenido.

$ man gpg // Ver el Manual de gpg

##### Cifrado asimétrico #####

--- Generar las claves---

Para poder cifrar asimétricamente primero tenemos que crear la pareja de claves
(pública y privada) con el comando gpg --gen-key

$ gpg --gen-key
gpg (GnuPG) 1.4.12; Copyright (C) 2012 Free Software Foundation, Inc.
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.

Por favor seleccione tipo de clave deseado:
   (1) RSA and RSA (default)
   (2) DSA and Elgamal
   (3) DSA (sólo firmar)
   (4) RSA (sólo firmar)
Su elección:

// GPG nos permite elegir el tipo de clave que queremos usar, hay opciones que solo permiten firmar
y otras que permiten firmar y cifrar, en este caso usaremos DSA y Elgamal.

las claves DSA pueden tener entre 1024 y 3072 bits de longitud.
¿De qué tamaño quiere la clave? (2048)

Nos pedirá el tamaño de la clave que puede variar entre 1024 bits y 3072, esto es de libre elección,
tomarémos el que propone por defecto (2048).

Nos pide la fecha en la que expirará la clave, la información del emisor de la clave
(nombre, mail y algunos datos extra que queramos dar) y por último nos pedirá la
contraseña que salvaguarda la clave privada.

Tras generar las claves podemos verlas con el comando gpg -k que nos muestra nuestro
anillo de claves, lo importante de este paso es que veremos la identificación de cada una
que es necesaria para poderlas exportar y enviar.

$ gpg -k // Visualizar anillo de claves
/home/user/.gnupg/pubring.gpg
--------------------------------

pub   1559C/88651986 2017-01-01
uid                  username_lastname (Enunciado de la clave) <username@email.com>
sub   2048g/55GD33FG 2017-01-01

--- Exportar y enviar la clave pública ---

El objetivo de esta pareja de claves es que cualquiera nos pueda mandar un archivo cifrado
que solo veremos nosotros y esto se hace difundiendo la clave pública que acabamos de crear
(la pública, nunca la privada), para exportarla en un archivo usaremos el comando:

$ gpg -output [archivo destino] --export [ID de a clave pública] (la clave pública generada antes tiene la ID 88651986).

$ gpg --output ClavePublica_username.gpg --export 88651986
$ ls
ClavePublica_username.gpg // Fichero generado que contiene la clave pública

Este archivo ahora se puede difundir por el medio que queramos.

#####################################
##### Configurar sudo en Debian #####
#####################################

En Debian no viene instalado y configurado por defecto.

$ aptitude install sudo

Una vez con el sudo instalado deberemos agregar nuestro usuario en la sección "User privilege specification"
en el archivo /etc/sudoers, de tal forma que la sección quede así:

User privilege specification
root ALL=(ALL) ALL
tu_usuario ALL=(ALL) ALL

Una vez configurado esto, ya podremos ejecutar acciones de administrador desde una terminal común, anteponiendo el sudo a la acción a realizar.

###################################################################
##### Lista de fuentes de los paquetes de debian sources.list #####
###################################################################

----- Apt -----

Apt (Advanced Package Tool) es un set de herramientas del núcleo de Debian. Apt hace posible:
instalar, eliminar, mantener sus aplicaciones al día y mucho más... 

Apt, que basicamente resuelve problemas de dependencias y busca los paquetes solicitados, trabaja con dpkg, otra herramienta
que maneja la instalación y eliminación de paquetes (aplicaciones). Apt es muy poderoso, y se usa frecuentemente desde la línea
de comandos o consola/terminal. Sin embargo, hay muchas herramientas GUI/Gráficas para ayudarle a usar Apt sin tener
que tocar la línea de comando.

Al presente, aptitude es la herramienta recomendada para interactuar con la suite APT. Las herramientas APT deben ser usadas
especificamente para manejar acciones que no puedan ser manejadas por aptitude, o dónde se necesite mayor control de las dependencias. 

/etc/apt/sources.list // APT utiliza un archivo que enlista las "fuentes" en donde se encuentran los paquetes. Este archivo es: /etc/apt/sources.list

El contenido de este archivo, normalmente sigue este formato:
    deb http://host/debian distribución sección1 sección2 sección3
    deb-src http://host/debian distribución sección1 sección2 sección3

Los renglones arriba mencionados son ficticios y no deberán ser usados. La primera palabra en cada línea, deb o deb-src, indican
el tipo del archivo: ya sea que contenga paquetes binarios (deb), esto es, los paquetes pre-compilados que normalmente se usan
o los paquetes fuente (deb-src), que son los códigos originales, más el archivo de control de Debian (.dsc) y el diff.gz que
contienen los cambios necesarios para "debianizar" el programa.

Generalmente se encuentra lo siguiente por defecto en el archivo sources.list:

     # See sources.list(5) for more information, especialy
     # Remember that you can only use http, ftp or file URIs
     # CDROMs are managed through the apt-cdrom tool.
     deb http://http.us.debian.org/debian stable main contrib non-free
     deb http://non-us.debian.org/debian-non-US stable/non-US main contrib non-free
     deb http://security.debian.org stable/updates main contrib non-free
     
     # Uncomment if you want the apt-get source function to work
     #deb-src http://http.us.debian.org/debian stable main contrib non-free
     #deb-src http://non-us.debian.org/debian-non-US stable/non-US main contrib non-free

Éstas son las líneas necesarias para una instalación básica de Debian. La primer línea deb apunta al archivo en el servidor oficial
la segunda línea apunta hacia el archivo del servidor non-US y la tercera línea apunta hacia el archivo del servidor de
actualizaciones de seguridad.

Las dos últimas líneas están deshabilitadas (con un "#" al inicio), así que apt-get las ignora. Éstas son las líneas de deb-src
esto es, apuntan hacia los paquetes fuente de Debian. Si frecuentemente descarga paquetes fuente para probar o recompilar
habilítelas (borrando el "#" al inicio de la línea).

El archivo /etc/apt/sources.list puede contener varios tipos de líneas. APT sabe como interpretar líneas del tipo http,
ftp, file (archivos locales, p.e., un directorio que contiene un CD-ROM) y ssh, según mis conocimientos.

No olvide ejecutar el comando apt-get update después de modificar el archivo /etc/apt/sources.list. Debe hacer
esto para permitir a APT obtener la lista de paquetes de las fuentes que especificó.

###################################################################
##### Visión General del Árbol de Directorios de GNU - Linux  #####
###################################################################

El árbol de directorios completo está pensado para poder ser dividido en partes más pequeñas, que pueden estar en su propio disco
o partición y acomodarse así a los límites del tamaño del disco, así como para facilitar la realización de copias de seguridad y
otras tareas de la administración de sistemas. Las partes principales son los sistemas de archivos raíz (/) , /usr, /var , y /home.
Cada parte tiene un propósito diferente. El árbol de directorios se ha diseñado para funcionar bien en una red de máquinas GNU/Linux
las cuales pueden compartir algunas partes del sistema de archivos sobre un dispositivo de solo-lectura (CD-ROM por ejemplo) o sobre
la red a través de NFS.

Los roles de las diferentes secciones del árbol de directorios son:

- El sistema de archivos raíz es específico para cada máquina (generalmente se encuentra almacenado en el disco local, aunque puede estar
también en un disco RAM o en una unidad de red) y contiene los archivos que son necesarios para arrancar el sistema y dejarlo en un estado
en el que se puedan montar los demás sistemas de archivos. El contenido del sistema de archivos raíz es por lo tanto suficiente para el nivel
de ejecución de usuario individual. También contiene herramientas para reparar un sistema dañado y para recuperar archivos perdidos desde
las copias de seguridad.

- El sistema de archivos /usr contiene todos los comandos, librerías, páginas de manual, y otros archivos que no serán modificados durante el
funcionamiento normal del sistema. No deben existir archivos bajo /usr que sean específicos para una máquina en particular, ni que deban ser
modificados durante la utilización normal del sistema. Esto permite que los archivos sean compartidos a través de la red, lo cual puede ser
efectivo en cuanto a costes, puesto que se obtiene un ahorro de espacio en disco (/usr puede ocupar fácilmente miles de megabytes) y puede
facilitar la administración, ya que sólo el /usr maestro necesita ser modificado cuando actualizamos una aplicación, y no en cada máquina por
separado. Aún cuando el sistema de archivos resida en el disco local, este puede ser montado en modo solo lectura, para eliminar el riesgo
de que se corrompa durante un fallo.

- El sistema de archivos /var contiene archivos que sí cambian durante el funcionamiento normal del sistema, tales como directorios spool
( para correo, noticias (news), impresoras, etc), archivos de log, páginas de manual formateadas y archivos temporales. Tradicionalmente
todo en /var es algo que debería estar en /usr, pero que haría imposible montar dicho sistema de archivos como solo lectura.

- El sistema de archivos /home contiene los directorios específicos de los usuarios, P.Ej., todos los datos reales del sistema. Separar los
directorios home a su propio árbol de directorios o sistema de archivos hace más fácil la tarea de realizar copias de seguridad; los demás
sistemas de archivos no necesitan que se les haga copias de seguridad, o al menos no tan frecuentemente, puesto que rara vez cambian.
Un gran directorio /home puede ser dividido en varios sistemas de archivos, lo cual requiere agregar niveles de nombres extra, como por ejemplo
/home/estudiantes y /home/staff.

- Si bien las diferentes partes del árbol de directorios se han llamado hasta ahora sistemas de archivos, no se requiere necesariamente que se
encuentren en particiones separadas. Se pueden mantener fácilmente en una única partición si se trata de un sistema pequeño de un solo usuario
y este sólo desea mantener las cosas de manera simple. El árbol de directorios puede también ser dividido en diferentes particiones dependiendo
del tamaño de los discos, y de como el espacio se destine a los distintos propósitos. Lo importante, no obstante, es que todos los nombres estándar
funcionen; Aún cuando, digamos,/var y /usr se encuentren de hecho en la misma partición, los nombres /usr/lib/libc.a y /var/log/messages deben funcionar.
Incluso si, por ejemplo, moviéramos los archivos que se encuentren en /var dentro de /usr/var, y hagamos a /var un enlace simbólico a /usr/var.

La estructura del sistema de archivos en UNIX agrupa a los archivos de acuerdo a su propósito. Por lo tanto, todos los comandos están en un mismo lugar
todos los archivos de datos en otro, la documentación en un tercer lugar, etc. Otra alternativa podría ser la de agrupar los archivos de acuerdo al programa
al que pertenezcan, P.Ej., todos los archivos de Emacs podrían colocarse en un mismo directorio, todos los de Tex en otro, etc. El problema con esta última
aproximación es que dificulta compartir archivos (el directorio del programa frecuentemente contiene archivos no cambiantes y compartibles, y cambiantes y no
compartibles), y algunas veces incluso encontrar archivos (por ejemplo, las páginas de manual se encuentran ubicadas en una gran cantidad de lugares
y hacer que los programas que leen tales páginas de manual las encuentren sería una pesadilla de mantenimiento).

--- Descripcion detallada ---

El estándar de jerarquía del sistema de archivos (o FHS, del inglés Filesystem Hierarchy Standard) es una norma que define los directorios principales y
sus contenidos en el sistema operativo GNU/Linux y otros sistemas de la familia Unix. Se diseñó originalmente en 1994 para estandarizar el sistema de archivos
de las distribuciones de Linux, basándose en la tradicional organización de directorios de los sistemas Unix. En 1995 se amplió el ámbito del estándar a cualquier
Unix que se adhiriese voluntariamente.

# Estructura de los directorios

En UNIX y sistemas similares como BSD, GNU/Linux, todos los archivos y directorios aparecen bajo el directorio raíz, /, aun cuando se encuentren
en distintos dispositivos físicos.

La mayoría de estos directorios existe en todos los sistemas operativos tipo UNIX, y generalmente son usados de igual forma; sin embargo, las descripciones
presentes aquí son aquellas que son usadas específicamente por el FHS, y no son consideradas obligatorias por otras plataformas GNU/Linux.

# Estructura de los directorios general

En el sistema de ficheros de UNIX (y similares), existen varias sub-jerarquías de directorios que poseen múltiples y diferentes funciones de almacenamiento
y organización en todo el sistema.1 Estos directorios pueden clasificarse en:

-Estáticos: Contiene archivos que no cambian sin la intervención del administrador (root), sin embargo, pueden ser leídos por cualquier otro usuario. (/bin, /sbin, /opt, /boot, /usr/bin...)
-Dinámicos: Contiene archivos que son cambiantes, y pueden leerse y escribirse (algunos sólo por su respectivo usuario y el root).
Contienen configuraciones, documentos, etc. Para estos directorios, es recomendable una copia de seguridad con frecuencia, o mejor aún, deberían ser montados
en una partición aparte en el mismo disco, como por ejemplo, montar el directorio /home en otra partición del mismo disco, independiente de la partición principal
del sistema; de esta forma, puede repararse el sistema sin afectar o borrar los documentos de los usuarios. (/var/mail, /var/spool, /var/run, /var/lock, /home...)
-Compartidos: Contiene archivos que se pueden encontrar en un ordenador y utilizarse en otro, o incluso compartirse entre usuarios.
-Restringidos: Contiene ficheros que no se pueden compartir, solo son modificables por el administrador. (/etc, /boot, /var/run, /var/lock...)

/ Jerarquía primaria, la raíz o root, y directorio raíz o contenedor de todo el sistema de jerarquía.

/bin/ Aplicaciones binarias de comando que son esenciales para que estén disponibles para una sesión de usuario único, o bien, para todos los usuarios (multiusuario). Incluyen, por ejemplo, cat, ls, cp, rm, mkdir, etc.

/boot/ Archivos cargadores de arranque (por ejemplo, los núcleos, el initrd). A menudo en una partición o disco aparte.

/dev/ Contiene los portales a Dispositivos esenciales (por ejemplo, /dev/null), incluso a los que no se les ha asignado (montado) un directorio.
Contiene incluso los portales a dispositivos que son virtuales y también a los que no proporcionan almacenamiento (p.e. micrófonos, impresoras, etc).
Se trata de la parte más cruda o de más bajo nivel del sistema operativo hacia el hardware, aunque es extremadamente útil para tener un acceso
directo a los dispositivos.

/etc/ Contiene archivos de configuración del sistema específicos del Host de todo el sistema. Ha habido controversia sobre el significado del nombre, en las primeras versiones del Documento de Implementación de UNIX de los laboratorios Bell, /etc se conoce como el directorio /etcetra, todo lo que históricamente este directorio consideró que no pertenecía en otra parte (sin embargo, restringe la ESF / etc a los archivos de configuración estáticos y no puede contener archivos binarios). Desde la publicación de la documentación temprana, el nombre de la guía ha sido re-designados de varias maneras. Interpretaciones más recientes incluyen Backronyms como "Configuración de texto editable".

/etc/opt/ Archivos de configuración para los programas alojados dentro del directorio /opt.

/etc/X11/ Archivos de configuración para el X Window System, versión 11.

/etc/sgml/ Archivos de configuración para SGML.

/etc/xml/ Archivos de configuración para XML.

/home/ Contiene los directorios de trabajo de todos los usuarios, excepto el del superusuario (administrador, root). Contiene archivos guardados, ajustes personales, etc. A menudo es instalada en un disco o partición separada. Cada usuario tiene su propio directorio dentro de esta carpeta.

/lib/ Contiene todas las bibliotecas (mal traducidas como librerías) esenciales compartidas de los programas alojados, es decir, para los binarios en /bin/ y /sbin/. Contiene también las bibliotecas para el núcleo.

/media/ Contiene los puntos de montaje de los medios extraíbles de almacenamiento, tales como lectores de CD-ROM (aparecido en la versión 2.3 de FHS), Pendrives (memoria USB), e incluso sirve para montar otras particiones del mismo disco duro, como por ejemplo, alguna partición que sea utilizada por otro sistema operativo.

/mnt/ Sistema de archivos montados temporalmente. Es una directorio semejante a /media, pero es usado mayoritariamente por los usuarios. Sirve para montar discos duros y particiones de forma temporal en el sistema; no necesita contraseña, a diferencia del directorio /media.

/opt/ Contiene Paquetes de programas opcionales de aplicaciones estáticas, es decir, que pueden ser compartidas entre los usuarios. Dichas aplicaciones no guardan sus configuraciones en este directorio; de esta manera, cada usuario puede tener una configuración diferente de una misma aplicación, de manera que se comparte la aplicación pero no las configuraciones de los usuarios, las cuales se guardan en su respectivo directorio en /home.

/proc/ Contiene principalmente archivos de texto, sistema de archivos virtuales que documentan al núcleo y el estado de los procesos en archivos de texto (por ejemplo, uptime, network).

/root/ Directorio raíz del usuario root. Funciona como las carpetas en /home, pero en este caso, es solo para el superusuario (administrador del sistema).
/sbin/ 	Sistema de binarios esencial, comandos y programas exclusivos del superusuario (root), por ejemplo, init, route, ifup). Un usuario puede ejecutar alguno de estas aplicaciones de comandos, si tiene los permisos suficientes, o bien, si tiene la contraseña del superusuario.

/srv/ Lugar específico de datos que son servidos por el sistema.

/sys/ Evolución de proc. Sistema de archivos virtuales que documentan al núcleo pero localizados de forma jerarquizada. En proc se disponen de forma anárquica. Su nombre correcto es Sysfs.

/tmp/ Archivos temporales (véase también /var/tmp). Aquí generalmente se guardan los archivos temporales guardados -por ejemplo- por el navegador de internet.

/usr/ jerarquía secundaria de los datos de usuario; contiene la mayoría de las utilidades y aplicaciones multiusuario, es decir, accesibles para todos los usuarios. En otras palabras, contiene los archivos compartidos, pero que no obstante son de sólo lectura. Este directorio puede incluso ser compartido con otras computadoras de red local.

/usr/bin/ Comandos binarios no-administrativos para todos los usuarios. Son de solo lectura, pero pueden tener su propia configuración para cada usuario en /home.

/usr/include/ Archivos de cabecera (Header files o Include files), es decir, archivos de inclusión estándar.

/usr/lib/ Bibliotecas compartidas de los binarios en /usr/bin/. Algunos ejecutables comparten las mismas librerías que comparten las demás aplicaciones, de manera que generalmente no hay dos librerías idénticas en un mismo sistema, lo cual ahorra memoria y proporciona más orden.

/usr/sbin/ Sistema de binarios no esenciales; por ejemplo, demonios para varios servicios de red. Es decir, contiene programas que no proporcionan una interfaz de usuario y gerneralmente se ejecutan al inicio del sistema o en ciertas circunstancias. No son directamente manejados por el usuario mientras se ejecutan, aunque sí pueden ser configurados antes de que sean ejecutados.

/usr/share/ Arquitectura independiente y compartida de datos. En otras palabras, contiene los datos compartidos que no dependen de la arquitectura del sistema. Esto puede incluir imágenes, sonidos, etc., para la disponibilidad en el sistema y sus aplicaciones. Pueden ser plantillas, por ejemplo, aunque generalmente son archivos que el sistema utiliza directamente.

/usr/src/ Códigos fuente de algunas aplicaciones. Al igual que /mnt, esta carpeta es manejada por los usuarios directamente para que éstos puedan guardar en él el código fuente de programas y bibliotecas y así puedan accederlo fácilmente, sin problemas con permisos. Permite que el código fuente tenga un espacio propio, accesible pero apartado de todos los usuarios.

/usr/X11R6/ Sistema X Window System, Versión 11, Release 6. Este directorio se relaciona con el entorno gráfico.

/usr/local/ Jerarquía terciaria para los datos locales, específicos a este host. Usualmente tiene subdirectorios, por ejemplo bin/, lib/, share/, de datos compartidos de sólo lectura específicos del ordenador o servidor que los comparte.

/var/ Archivos variables, tales como logs, archivos spool, bases de datos, archivos de e-mail temporales, y algunos archivos temporales en general. Generalmente actúa como un registro del sistema. Ayuda a encontrar los orígenes de un problema.

/var/cache/ Memoria caché de las aplicaciones, aunque también se utiliza el directorio /tmp para lo mismo.

/var/crash/ Se depositan datos e información, referentes a las caídas o errores del sistema operativo. Es más específico que /var en general.

/var/games/ atos variables de los juegos del sistema. Este directorio no es imprescindible y muchas veces es omitido por las propias aplicaciones de juegos, pues utilizan la carpeta de usuario en /home para guardar datos variables como configuraciones, por poner un ejemplo. De todas maneras, los juegos de gnome utilizan este directorio.

/var/lock/ Archivos Lock. Archivos que hacen el seguimiento de los recursos que se utilizan actualmente.

/var/log/ Archivos de registro, Log. Varios registros, logs.

/var/mail/ Buzón correos o mensajes de los usuarios. Si no utiliza cifrado, generalmente se utiliza entonces la carpeta personal para la misma labor por parte de programas que manejen correos electrónicos.

/var/opt/ Posee los datos variables de /opt.

/var/run/ Información reciente. Trata acerca del funcionamiento del sistema desde el último arranque. Por ejemplo, los usuarios actualmente registrados o logueados, que han ingresado; y los demonios que están en ejecución.

/var/spool/ Bobinas o carretes (Spool), de tareas a la espera de ser procesados (por ejemplo, colas de impresión y correo no leído).

/var/spool/mail/ Ubicación de los correos de usuario desaprobados. Si no utiliza cifrado, generalmente se utiliza entonces la carpeta personal para la misma labor por parte de programas que manejen correos electrónicos.

/var/tmp/ Archivos temporales que, a diferencia de /tmp, no se borran entre sesiones o reinicios del sistema, pero que de todas maneras siguen siendo prescindibles.

#######################################
##### El sistema de archivos /usr #####
#######################################

El sistema de archivos /usr es con frecuencia grande, debido a que todos los programas están instalados allí. Normalmente, todos los archivos en /usr provienen
de la distribución Linux que hayamos instalado; los programas instalados localmente y algunas otras cosas se encuentran bajo /usr/local. De esta manera es posible
actualizar el sistema desde una nueva versión de la distribución, o incluso desde una distribución completamente nueva, sin tener que instalar todos los programas
nuevamente. Algunos de los directorios de /usr están explicados aquí debajo (algunos de los menos importantes se han omitido, se puede encontrar información
adicional en el Estándar del Sistema de Ficheros).

/usr/X11R6
    Se encuentran aquí todos los archivos del Sistema X-Windows. Para simplificar el desarrollo y la instalación de X, sus archivos no fueron integrados
dentro del resto del sistema. Existe un árbol de directorios bajo /usr/X11R6 similar al que está bajo /usr.

/usr/bin
    En este directorio se encuentran la gran mayoría de los comandos para los usuarios. Algunos otros comandos pueden encontrarse
en /bin o en /usr/local/bin. 

/usr/sbin
    Comandos para la administración del sistema que no son necesarios en el sistema de archivos raíz, como por ejemplo la mayoría de los
programas que proveen servicios.

/usr/share/man, /usr/share/info, /usr/share/doc
    Páginas de manual, documentos de información GNU, y archivos de documentación de los programas instalados. 

/usr/include
    Archivos cabecera para el lenguaje de programación C. Estos deberían estar de hecho debajo de /usr/lib por coherencia, pero tradicionalmente
se ha apoyado de forma mayoritaria esta ubicación.

/usr/lib
    Archivos de datos de programas y subsistemas que no sufren cambios, incluyendo algunos archivos de configuración globales. El nombre lib viene
de librería; originariamente las librerías de las subrutinas de programación se almacenaban en /usr/lib.

/usr/local
    Es la ubicación para el software instalado localmente y para algunos otros archivos. Las distribuciones no deben colocar archivos bajo este
directorio. Se reserva para ser utilizado únicamente por el administrador local del sistema. De esta manera, aquel se asegura totalmente de que
ninguna actualización de su distribución sobreescribirá el software que él mismo haya instalado localmente.

##############################
##### El directorio /etc #####
##############################

El directorio /etc contiene gran cantidad de archivos. Muchos archivos de configuración de red se encuentran también en /etc.

/etc/rc o /etc/rc.d o /etc/rc?.d
	Scripts o directorios de scripts que se ejecutan durante el arranque del sistema o al cambiar el nivel de ejecución. Se puede encontrar
información adicional en el capítulo dedicado a Init.

/etc/passwd
    La base de datos de los usuarios, que incluye campos como el nombre de usuario, nombre real, directorio home, password encriptada y otra información
acerca de cada usuario. El formato de este archivo se encuentra documentado en la página de manual del comando passwd. Sin embargo, hoy día es muy común
encontrar las contraseñas encriptadas en /etc/shadow. Esto significa que en tal caso, los datos de los usuarios excepto la password encriptada se
encontrarían almacenados en passwd.

/etc/fdprm
    Tabla de parámetros para los discos flexibles. Describe cómo son los diferentes formatos de estos discos. Este archivo es utilizado por el programa setfdprm. Se puede encontrar información adicional en la página de manual de setfdprm. 

/etc/fstab
    Lista los sistemas de archivos montados automáticamente en el arranque del sistema por el comando mount -a (en /etc/rc o archivo de inicio equivalente). En Linux, este archivo también contiene información acerca de áreas de swap utilizadas automáticamente por swapon -a. Se puede encontrar información adicional en “Montar y desmontar”, la página de manual del comando mount. 

/etc/group
    Este archivo es similar a /etc/passwd , pero describe grupos en vez de usuarios. Se puede encontrar información adicional en la página de manual del comando group. 

/etc/inittab
    Archivo de configuración para init. 

/etc/issue
    Archivos que utiliza getty como salida antes de que el sistema pida el nombre de usuario. Usualmente contiene una descripción corta o mensaje de bienvenida al sistema. El contenido es establecido por el administrador del sistema. 

/etc/magic
    El archivo de configuración para el programa file. Contiene las descripciones de varios formatos de archivos que utiliza file para determinar el tipo de archivo. Se puede encontrar información adicional en las páginas de manual para magic y file. 

/etc/motd
    Contiene el mensaje del día, que se emite automáticamente tras iniciar una sesión con éxito. El contenido es definido por el administrador del sistema. Con frecuencia se utiliza para dar información a todos los usuarios, como por ejemplo, mensajes de advertencias acerca de la hora en que está planeada una parada técnica del servidor. 

/etc/mtab
    Contiene un listado de los sistemas de archivos actualmente montados. Se establece Inicialmente por los scripts del arranque del sistema, y se actualiza automáticamente por el comando mount. Se utiliza cuando se necesita un listado de los sistemas de archivos que estén actualmente montados (por ejemplo por el comando df). 

/etc/shadow
    Archivo de contraseñas ocultas en sistemas donde se encuentre instalado el software de contraseñas ocultas. Al utilizar contraseñas ocultas la password encriptada de cada usuario es eliminada de /etc/passwd y colocada en el archivo /etc/shadow; este último no puede ser leído por nadie a excepción del usuario root. De esta manera se dificulta el proceso de descifrado de las contraseñas de los usuarios. Si la distribución GNU/Linux que estemos utilizando nos permite elegir utilizar o no contraseñas ocultas (muchas lo hacen), está altamente recomendado hacerlo. 

/etc/login.defs
    Archivo de configuración para el comando login. El archivo login.defs se describe en el capítulo 5. 

/etc/printcap
    Similar a /etc/termcap, con la excepción de que está destinado a la configuración de colas de impresión. La sintaxis también es diferente. printcap se describe en el capitulo 5. 

/etc/profile, /etc/csh.login, /etc/csh.cshrc
    Archivos que se ejecutan en el momento de iniciar los intérpretes de comandos C o Bourne. Permite al administrador del sistema establecer parámetros globales por defecto para todos los usuarios. Se puede encontrar información adicional en las páginas de manual para los respectivos intérpretes de comandos. 

/etc/securetty
    Identifica las terminales seguras, esto es, las terminales por las cuales el usuario root tiene permitido iniciar una sesión. Típicamente sólo las consolas virtuales se encuentran listadas en este archivo, con lo que se hace imposible (o al menos mas difícil) obtener privilegios de superusuario accediendo a través de un módem o la red. No se debe permitir iniciar una sesión como usuario root desde la red. Es preferible iniciar una sesión con un usuario sin privilegios y utilizar después su o sudo para obtener privilegios de superusuario. 

/etc/shells
    Listado de intérpretes de comandos admitidos. El comando chsh permite a los usuarios cambiar su intérprete de comandos por defecto a otro que se encuentre listado en este archivo. Ftpd, el proceso servidor que proporciona servicios FTP en una máquina, comprueba que los intérpretes de comandos de los usuarios estén listados en /etc/shells y no permite que nadie inicie una sesión si el intérprete de comandos no se encuentra en dicho listado. 

/etc/termcap
    La base de datos de capacidades del terminal. Describe las “secuencias de escape” por medio de las cuales se pueden controlar diversos tipos de terminales. Los programas se escriben para que, en lugar de generar directamente una secuencia de escape que solo funcione en un tipo de terminal, busquen la secuencia correcta para hacer lo que necesiten en /etc/termcap. Como resultado, la mayoría de los programas trabajan con la mayoría de los tipos de terminales existentes. Se puede encontrar información adicional en las páginas de manual de termcap, curs_termcap, y de terminfo. 

################
##### dpkg #####
################

El programa dpkg es la base del sistema de gestión de paquetes de Debian GNU/Linux. Fue creado por Ian Jackson en 1993. Se utiliza para instalar
quitar, y proporcionar información sobre los paquetes .deb.

dpkg es en sí misma una herramienta de bajo nivel; se necesita un frontal de alto nivel para traer los paquetes desde lugares remotos o resolver
conflictos complejos en las dependencias de paquetes. Debian cuenta con apt para esta tarea.

Herramientas Dpkg, Debian posee una serie de herramientas que es necesario llamar para construir un paquete:

-dpkg-source Empaqueta y desempaqueta los archivos fuentes de un paquete Debian.
-dpkg-gencontrol Lee la información de un árbol fuente Debian desempaquetado y genera un paquete binario de control, generando una
entrada para éste en el fichero debian/files.
-dpkg-shlibdeps Calcula las dependencias de ejecutables respecto a bibliotecas.
-dpkg-genchanges Lee la información de un árbol fuente Debian desempaquetado y ya construido, generando un fichero de control de los últimos cambios (un.changes).
-dpkg-buildpackage Es un script de control que se puede utilizar para automatizar la construcción del paquete.
-dpkg-distaddfile Añade una entrada de un fichero a debian/files.
-dpkg-parsechangelog Lee el fichero de cambios changelog) de un árbol fuente Debian desempaquetado y genera una salida con la información
de estos cambios, convenientemente preparada.

--- Instalación de paquetes ---

Documentacion oficial de debian --> https://debian-handbook.info/browse/es-ES/stable/sect.manipulating-packages-with-dpkg.html

dpkg es la herramienta para instalar un paquete Debian, para hacer esto utilizamos su opción -i o --install.

Ejemplo de instalación de un paquete con dpkg

# dpkg -i man-db_2.7.0.2-5_amd64.deb // El comando desempaquetara, configurara y comprobará las dependencias del paquete, si hay paquetes sin instalar,
lo notificara, una vez instalados los paquetes necesarios, el paquete pendiente por configurar lo hará automaticamente, completando así la instalacion,
se podrá comprobar con un aptitude show nombre_paquete.

# dpkg -l | grep nombre-del-paquete // Comprobar la instalación, Deberías ver ii delante del nombre del paquete en la salida en pantalla, ello
significaría que el programa ha sido correctamente instalado.

# dpkg -r nombre-del-paquete // Desinstalar paquete con dpkg, Este comando removerá el paquete, pero dejara los archivos de configuracion intactos, esto es util en
caso que hubieras realizado cambios en ellos y quieras una copia para usos posteriores. Pero si deseas quitar todo rastro del paquete debes usar purge.

# dpkg -P nombre-del-paquete // Ahora no quedará rastro del paquete antes instalado.

--- Descargando los paquetes fuente ---

Es muy común en el mundo del software libre estudiar el código fuente o corregir código erróneo. Para lograr esto, necesita descargar el código fuente del programa.
El sistema APT provee de una manera fácil de obtener código fuente de muchos programas contenidos en la distribución, incluyendo todos los archivos necesarios
para crear un .deb para el programa.

Otro uso común de las fuentes de Debian es el de adaptar la versión más reciente de un programa, de la versión inestable. Compilar un programa en la versión estable
generará .debs con las dependencias ajustadas para acoplarse a los paquetes en la distribución.

Para lograr esto una entrada deb-src en el archivo /etc/apt/sources.list debe apuntar hacia "unstable". Esta línea debe estar habilitada (sin comentar). Vea a la sección El archivo /etc/apt/sources.list, Sección 2.1.

Para descargar un paquete fuente, haga lo siguiente:

$ apt-get source packagename

Esto descargará tres archivos: un .orig.tar.gz, un .dsc y un .diff.gz. En el caso de paquetes especiales para Debian, el último de estos archivos no es descargado y el primero
generalmente no tendrá el "orig" en el nombre.

El archivo .dsc es utilizado por dbpkg-source para descomprimir el paquete en el directorio packagename-version. Con cada paquete descargado existe un directorio debian/
que contiene los archivos necesarios para crear un paquete .deb.

Para automáticamente compilar el paquete cuando está siendo descargado, sólo agrega -b a la línea de comando así.

$ apt-get -b source packagename

Si decide no crear el archivo .deb mientras descarga el paquete, puede crearlo después ejecutando:

$ dpkg-buildpackage -rfakeroot -uc -b

en el directorio que se ha creado después de descargar el paquete. Para instalar el paquete que ha sido creado por los comandos anteriores, hay que usar el sistema de
administración de paquetes directamente como aquí:

     # dpkg -i archivo.deb

Hay una diferencia entre el apt-get source y las otras opciones. La opción source puede ser utilizada por usuarios normales, sin necesitar de poderes especiales de root. Los archivos son descargados a un directorio desde el cual el comando apt-get source package es ejecutado.

###############
##### deb #####
###############

-Extensión de archivo: .deb
-Tipo de formato: Sistema de gestión de paquetes

.deb es la extensión del formato de paquetes de software de la distribución de Linux, Debian GNU/Linux y derivadas (e.j.Ubuntu), y
el nombre más usado para dichos paquetes. Como Debian, su nombre proviene de Deborah Murdock, ex-esposa del fundador de la distribución Ian Murdock.

El programa predeterminado para manejar estos paquetes es dpkg, generalmente usando apt/aptitude aunque también hay interfaces gráficas como Synaptic
PackageKit, Gdebi o en Ubuntu Software Center (este último solo para Ubuntu), desde la versión 3.0. Es posible convertir un paquete deb a otros
formatos de paquete (como RPM), y viceversa, usando la aplicación alien.

--- Estructura interna ---

Los paquetes deb son archivos ar estándar de Unix que incluyen dos archivos tar en formato gzip, bzip2 o lzma: uno de los cuales alberga
la información de control y el otro los datos.

Estos paquetes contienen tres archivos:
-debian-binary - número de versión del formato deb. Este es "2.0" para las versiones actuales de Debian.
-control.tar.gz - toda la meta-información del paquete.
-data.tar, data.tar.gz, data.tar.bz2 o data.tar.lzma: - los archivos a instalar.

##########################################
##### Trabajando con paquetes Debian #####
##########################################

Gonz-*alo help - ***Pendiente***
./configure

dpkg-source

dpkg-source -x evince_3.14.1-2+deb8u1.dsc

cd evince-3.14.1/

dpkg-buildpackage -rfakeroot

########################
##### Dependencias #####
########################

Una dependencia es un paquete accesorio requerido por un paquete instalador para hacer funcionar correctamente un programa después de instalarlo.
Generalmente son bibliotecas de código o programas accesorios. Un programa puede tener múltiples dependencias, las cuales no siempre vienen instaladas
en la distribución Linux elegida por diversas razones, por no ser necesarias, por aumentar demasiado el tamaño del archivo ISO, etc. Algunas distros, por ser una
distribuciones minimalistas, de tamaño ligero, encaminan con frecuencia al usuario  tener que buscar dependencias de programas que no se suelen ofrecer en los
repositorios o en los foros, por eso el administrador de paquetes incluye una herramienta para detectar y descargar las dependencias junto con el programa principal.
Aunque es posible ofrecer un solo paquete que incluya el programa principal más las dependencias, muchos compiladores y desarrolladores optan por ofrecer esos
componentes por separado para facilitar la descarga a través de conexiones lentas, o para darle al usuario la opción de instalar sólo los componentes que sabe
que están ausentes en su sistema. Por eso, siempre es recomendable investigar cuáles son las dependencias del programa que se desea instalar, así como verificar
que se tiene suficiente espacio para la instalación. No todas las dependencias son absolutamente necesarias, algunas sólo dan soporte adicional para ciertas
funciones o efectos visuales que extienden las características del programa en sí mismo.

########################
##### Metapaquetes #####
########################

Un metapaquete es un como un paquete que enlaza varios paquetes, es decir, es un paquete que contiene referencias a
varios paquetes pero no realiza ninguna funcionalidad.

Los metapaquetes sirven para poder instalar fácilmente varios paquetes con una sola orden. Estos paquetes guardan entre
sí una cierta coherencia.

El funcionamiento de un metapaquete es el siguiente:

Imaginemos que tenemos el metapaquete A, que contiene a B, C , D y E. Cuando instalamos el metapaquete A, lo que en realidad estamos instalando
son los paquetes B, C, D y E.

--- Estructura de un metapaquete ---

Tal como los paquetes comunes, los metapaquetes deben ser generados a partir de un código fuente basado en las políticas de Debian.

metapaquete
    |-- AUTHORS                (opcional)
    |-- COPYING                (opcional)
    |-- debian
    |    |-- changelog
    |    |-- compat
    |    |-- control
    |    |-- copyright
    |    |-- postinst
    |    |-- postrm
    |    |-- preinst
    |    |-- prerm
    |    |-- rules
    |    `-- source
    |        `-- format
    |-- LICENSE                (opcional)
    |-- Makefile               (opcional)
    |-- README                 (opcional)
    |-- THANKS                 (opcional)
    `-- TODO                   (opcional)

La carpeta debian contiene los siguientes archivos:

-changelog: Lista cronológica de versiones del metapaquete, que además contiene una descripción significativa de los cambios hechos en cada una de ellas.
-compat: versión de debhelper utilizada.
-control: El archivo más importante en un metapaquete. Especifica las dependencias, el nombre del paquete, el responsable (mantenedor),
descripción, entre otros campos.
-copyright: Declaración de derechos de autor (si los hubiere) y licencia de distribución del paquete.
-postinst, postrm, preinst, prerm: Los scripts del mantenedor permiten configurar o modificar partes del sistema en diferentes momentos de la instalación del paquete.
-rules: El archivo rules especifica las reglas para el empaquetado de la aplicación.
-source/format: Especifica el formato del código fuente, el más recomendado es 3.0 (quilt).

Los siguientes son archivos opcionales que pueden o no ser incluidos a gusto del desarrollador. Normalmente se incluyen, pero en el caso de los
metapaquetes no hay código que compilar, ni copiar dentro del paquete (que es para lo que sirve el Makefile), ni tampoco hay
código que documentar o describir.

-AUTHORS: Contiene el o los autores del código fuente.
-COPYING: Declaración de derechos de autor (si los hubiere) y licencia de distribución del código fuente.
-LICENSE: Una copia exacta de la licencia con que se distribuye el código fuente.
-Makefile: Son el conjunto de instrucciones necesarias para que el código fuente se organice, (compile si es necesario) e instale en
el sistema. También contiene instrucciones para limpiar y desinstalar.
-README: Descripción detallada del software. Se responden preguntas como: ¿Para que sirve? ¿Cómo se instala? ¿Cómo se desinstala? ¿Donde consigo ayuda?
-THANKS: Agradecimientos a las personas que contribuyeron contigo.
-TODO: Cosas que quisieras hacer en el futuro con tu software.

#########################################################
##### Quemar o grabar una imagen iso en un pendrive #####
#########################################################

# dd if=[imagen] of=[dispositivo]

En donde imagen es la ruta completa a la imagen ISO que deseas grabar y dispositivo la ruta completa hacia el pendrive, no la ruta con el nombre del pendrive, por ejemplo:

dd if=/home/user/Descargas/debian-testing-i386-businesscard.iso of=/dev/media/sdb

-----

$ export GIT_SSL_NO_VERIFY=True // Si un repostirotio git remoto no cuenta con el certificado
digital del servidor a veces se debe saltar chequeo de la firma para bajar las fuentes con este comando
