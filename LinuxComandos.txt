##### Guía de comandos en GNU - Linux by dM #####

#############################################################################################
##### Probados en: Debian GNU/Linux 7 (wheezy) y algunos en Debian GNU/Linux 8 (Jessie) #####
#############################################################################################

Crtl + h // Mostrar archivos ocultos de un directorio, en el entorno grafico

$ cat /etc/issue.net  //Para saber la versión de SO que tenemos.

$ cat /etc/issue  //Para saber la versión de SO que tenemos.

!! // Repetir el ultimo comando ejecutado en consola

~ // Para sacarlo usar AvPag en la consola

comando && comando && comando... // Ejecucion multiple de comandos

Ctrl + u // Cortar el contenido de la linea de comandos desde la posicion del cursor hasta el principio

Ctrl + k // Cortar el contenido de la linea de comandos desde la posicion del cursor hasta el final

Ctrl + t // Intercambiar de posicion las letras que estan a cada lado del cursor

Ctrl + l // Limpiar el shell

$ clear // Limpiar el shell

Alt + d // Borrar palabra

$ lsb_release -a //También tenemos un comando que nos va a dar muchos más detalles 

$ uname // Muestra información del sistema

$ uname -a // Version de Kernel

$ uname -mrs // Saber mi version de Kernel especifica, recomendada

$ cat /etc/*-release // Ver info del sistema (Probado en Debian GNU/Linux 7 wheezy)

$ echo "Texto al final del archivo" >> archivo.txt // Escribir una cadena de texto al final de un fichero.

$ sed -i '1i xxxxx' archivo.txt // Insertar una cadena de texto "xxxxx" al principio de un fichero.

$ sed -i '$a xxx' archivo.txt // Insertar una cadena al final del fichero, funciona como el método echo.

$ ifconfig // Siendo root, permite desplegar numerosos parámetros de las interfaces de red residentes  en el núcleo,
como la dirección ip (dinámica o estática), o la máscara de red entre otros.

$ ip addr// Para ver el estatus de las conexiones de red, este comando le mostrará su dirección IP, el tipo de conexión que está utilizando, etc.

$ apt-get moo // Huevo de pascua, muestra una vaca.

--- ip publica ---

Una forma de averigar esa IP pública es haciendo uso del comando curl. Si no tenéis instalado el paquete habrá que instalarlo,

$ sudo apt-get install curl

$ curl ifconfig.me // Nos mostrará nuestra ip pública.

$ nmap -sT -O localhost // Ver que puertos estan escuchando 

$ user@debian:/media$ umount nombre_device // Desmontar un dispositivo, pendrive, disco externo etc.

$ who // Muestra usuarios conectados a nuestra máquina, tambien usado para ver las conexiones entrantes de un servidor

Ejemplo:
user tty7         2015-07-28 08:47 (:0)
user pts/0        2015-07-30 14:03 (:0.0)
user pts/1        2015-07-30 17:03 (:0.0)
user pts/2        2015-07-31 14:15 (:0.0)
user pts/3        2015-07-31 12:37 (:0.0)

//En este caso son los usuarios conectados a mi máquina, eso quiere decir que tengo shells
abiertos, por lo tanto todos son representados como usuarios, entre los diversos parametros
se puede apreciar la fecha y la hora en que se abrio el shell, en un servidor seria
el momento en que se conecto el usuario

$ whoami // Muestra que usuario soy, nombre de usuario

$ who am i // Nos dira cual usuario somos, si navegamos por los shells abiertos y ejecutamos el comando nos dira cual usuario es

$ who -u //Ver usuarios conectados

// Ejemplo:

user tty7         2015-07-28 08:47  antig       4257 (:0)
user pts/0        2015-07-30 14:03 03:22        8351 (:0.0)
user pts/1        2015-07-30 17:03 03:19        8351 (:0.0)
user pts/2        2015-07-31 14:15 00:08        8351 (:0.0)
user pts/3        2015-07-31 12:37 02:53        8351 (:192.168.0.240)

//Aqui observamos que hay una conexion externa a traves de ssh a nuestro servidor proveniente de la maquina
(192.168.0.240) demarcada por el id process 8351 la cual podemos cancelar con $ kill -9 8351, pero no refusar esa conexion, el usuario seguirá conectado por ssh.

$ pkill -9 -t pts/3 // Acabar con una conexión externa, se envió la señal -9 que indica matar (KILL) el proceso, la opción -t indica que se basará
en un atributo de nombre de terminal y se indica después el nombre de la terminal en si pts/3. Este es el comando que sí funciona para 
refusar o eliminar conexiones externas o eliminar 

$ last // listar los ultimos usuarios conectados

$ clear // Limpia la pantalla

$ date // Muestra la fecha

# date --set 1998-11-02 // Asignar la fecha manualmente

# date --set 21:08:00 // Asignar la hora manualmente

$ man nombre_comando  // Muestra el manual de una comando donde como: ls, grep, aptitude etc...

// Dentro de los manuales podemos presionar "h" para ver las opciones tenemos del manual, ejemplo "/delete"
para hacer una busqueda de la cadena "delete" dentro del manual.

$ whatis nombre_programa // Si no desea ver la página de manual completa sino sólo una descripción corta para confirmar que es lo que está buscando, ingrese whatis programa.

Ejemplo:
$ whatis scp
scp (1)     - copia segura (programa de copia de ficheros remotos)

$ cal // Muestra un calendario

$ pwd // Muestra la ruta en la que te encuentras

$ ls // Muestra lo que hay en la carpeta en la que te encuentras

$ ls -l // Muestra los archivos, fecha, permisos, etc

$ ls -lh // Muestra los archivos, fecha, permisos, y el peso pero en kb,mg o gb según sea el caso.

$ ls -la // Muestra los archivos, los ocultos tambien, fecha, permisos, etc

$ ls -1 // Muestra los archivos en forma de lista

$ ls *.xxx // Listar todos los ficheros de un directorio que tengan las extension .xxx, donde xxx puede ser: txt, html, php, css, etc.
ejemplo: ls *.txt

$ ls -R // Listar los directorios y subdirectorios asi como ficehros de un directorio.

$ du // Para ver la lista de carpetas y sub carpetas, los directorios que existen 
dentro de donde se encuentre situado

$ cd // Cambiar de directorio, nos lleva al home del usuario.

$ cd 'nombre carpeta' // Acceder a un directorio que tiene espacios en el nombre.

-- Si una carpeta se llama (a b c d e), para aceder a ella usamos:

$ cd a\ b\ c\ d\ e/ // Al final siempre lleva el / normal, los otros usan el invertido.

$ cd .. // retroceder un directorio

$ cd ../../ // Retroceder dos directorios (../) representa un directorio

$ mkdir nombre_carpeta // Crear carpeta

$ mkdir -p carpeta1/carpeta2 // Crear una carpeta con otra carpeta dentro, encadenar la creación.

&& // El operador '&&' sirver para continuar con la ejecucion de comadnos en el shell, ejemplo:

$ mkdir carpetaFFF && cd carpetaFFF // Creamos una carpetaFFF y luego entramos en la carpeta creada
,&& nos permite poner varias instrucciones en una sola linea del shell, otro ejemplo:

$ mkdir carpetaZZZ && cd carpetaZZZ && touch archivo.txt // Creamos una carpeta, entramos en ella y creamos un archivo
en ese directorio en una sola instruccion.

$ touch Nombre_Fichero // Crear fichero

$ nano nombre_fichero // Modificar un fichero con el editor nano.

$ man nano // Leer el manual del editor de textos nano, muy útil, práctico y fácil de usar

$ cat nombre_fichero.xxx // Mostrar contenido de un fichero, concatenate files and print on the standard output.

$ cat -b nombre_fichero.xxx // Mostrar contenido de un fichero y numerar las líneas.

$ less nombre_fichero.xxx // Mostrar el contenido de un archivo, lector de ficheros, mayor movilidad que cat, con / permite buscar dentro
del fichero, como vim, q para salir.

$ tail nombre_fichero.xxx // El comando tail sirve para mostrar en pantalla las últimas líneas de un archivo.

$ tail -n X nombre_fichero.xxx // -n donde X es el número de lineas que queremos ver del fichero.

$ tail -c X nombre_fichero.xxx // -n donde X es el número caracteres desde el final, que queremos ver del fichero.

$ tail fichero_1.xxx fichero_2.xxx // Se pueden especificar 1 o más ficheros a la vez, los mostrara en el orden declarado.

$ stat nombre_fichero // Muestra el estado e información de un fichero

$ stat nombre_carpeta // Muestra información de un directorio

Ctrl + D // En el shell, cerrar sesion, salir del root, de maquinas virtuales o de sesiones de usuarios iniciadas

Ctrl + flecha derecha o izquierda // Moverse en el prompt palabra a palabra, no letra por letra.

Ctrl + w // Borrar la palabra que esta antes del cursor en el shell

$ top  // Listar los procesos de ejecución del sistema (y más cosas) en tiempo real, es una de las herramientas más importantes para un administrador.

// Cada proceso tiene un identificador (PID) proccess ID, entonces podemos matar ese proceso con:

$ kill -9 xxxx // Matar un proceso donde xxxx es el identificador del proceso.

$ ps // Muestra los procesos actuales del sistema y acepta varios parametros como:

$ ps -e // Visualiza información sobre "todos" los procesos del sistema.

$ ps -ef // Visualiza información sobre "todos" los procesos del sistema con mas detalles, así pues se puede detener un proceso con kill -9 PID_number.

ps -ef | grep evince // Filtrar la búsqueda, en este caso, buscando el proceso que alberga el visor pdf evince.

ps -ef | grep ssh // Filtrar la búsqueda para ver las conexiones ssh activas, nuevamente se aclara que podemos matar esos procesos
con kill-9 xxx pasandole el PID process.

$ ps -l // Muestra algunos detalles de los procesos del sistema

$ ps l //  Muestra mas detalles de los procesos del sistema.

$ poweroff // Apagar la maquina, se debe ser root para ejecutarlo.

$ reboot // Reiniciar la maquina.

$ file xxx // donde xxx es el nombre de un fichero, nos dira el tipo de fichero que es.
    Ejemplo: file index.html
    index.html: HTML document, UTF-8 Unicode text

$ file * // Nos dira el tipo de archivo de todos los ficheros del directorio

$ diff /home/user/file.html /home/user/file2.html // Permite hacer una comparacion de dos archivos para apreciar sus diferencias
se debe especificar la ruta de ambos archivos y separarlos con un espacio, si estan en el mismo directorio no hace
falta especificar las rutas completas.

$ df // Muestra el espacio disponible del disco y demas dispositivos asi como el espacio usado

$ df -h // Muestra el espacio disponible del disco y demas dispositivos asi como el espacio usado, pero en mg o gb según sea el caso.

# fdisk -l // Ver informacion de los discos duros, particiones y dispositivos montados en el sistema.

$ lsusb // Este comando muestra todos los puertos USB y los detalles acerca de los dispositivos conectados a ellos.

$ lspci // Lista todos los componentes tipo pci (Peripheral Component Interconnec) como las tarjetas de red, de sonido o de televisión.

$ free // Muestra el estado de la memoria RAM, total, usado, disponible, cached, buffers 

$ vmstat // Muestra el estado de la memoria virtual

$ pstree // Muestra los procesos del sistema en forma de arbol

$ gnome-screenshot // Captura de pantalla del escritorio

$ pdfimages fichero.pdf nombre_imagene // Extrae las imagenes de un .pdf

$ du // Muestra una lista de los directorios y el espacio que ocupan en el disco

$ du * // Muestra todos directorios y ficheros y el espacio que ocupan en el disco

$ ping xxx // Donde xxx es el nombre de un host al cual enviaremos paquetes y comprobaremos si hay una conexion con ese host, util para saber si estamos conectados a internet por ejemplo:
    ping http://www.google.com.ve // Si hay conexion a internet enviara paquetes que seran recibidos, de lo contrario dara un error.

$ glxgears // Siendo root, Ver si hay aceleracion grafica en la maquina, muestra unos engranajes de colores rodando, si es así, está correcta la instalacion del video.

$ xrandr // Detectar las resoluciones de pantalla disponibles del sistema así como los hz correspondientes, la que
tenga (*) es la que está siendo usada.

$ adduser nombre_de_usuario // Como root, Agregar un usuario nuevo al sistema, una nueva sesion, nos pedira agregar el 
nombre de usuario y asignarle contraseña, la clave de root es la misma para todas las sesiones.

$ su nombre_de_usuario // Conectarse como otro usuario creado

$ userdel -r nombre_usuario // Como root, eliminar el usuario creado

$ deluser --remove-home nombre_usuario // Otra forma de eliminar un usuario creado

$ rename 's/\.txt/\.xls/' *.txt  //Cambiar extension a todos los ficheros de un directorio
//En el ejemplo vamos a sustituir los .txt por .xls y le decimos que se lo haga a todos los .txt

$ ldd /xxx/python2.7 // Ver las dependencias de una librería o ejecutable, en este caso del ejecutable de python.

$ ldd /bin/bash

################
##### Less #####
################

// less es un visualizador de archivos de texto que funciona en intérpretes de comando.
// A diferencia de otros programas similares (como more), less permite una completa navegación
// por el contenido del archivo, utilizando un mínino de recursos del sistema.

***** Comandos basicos *****

man less // Manual de less

AvPag // Avanzar una página

RePag // Retroceder una página

space // Tecla espacio para avanzar, como page up

:q // Salir

:h // Ayuda

:/palabra // (/) Buscamos una palabra dentro del documento
// (n) para ir a la siguiente coincidencia.
// (N) para ir a la coincidencia anterior

:G // Ir al final del texto

:g // Ir al inicio del texto

:v //Invocar un editor de texto para el documento, por lo general usa vi pero puede usar nano automaticamente

########################################################
##### Comandos para copiar, mover, eliminar, otros #####
########################################################

cp // Copiar un fichero o carpeta

cp -r // Copiar un fichero o carpeta

cp Nombre_de_archivo.txt /Carpeta/destino/a/copiar // Copiar un fichero en un directorio
se debe estar situado en la carpeta del archivo a copiar

cp Nombre_carpeta -r /Carpeta/destino/a/copiar // Copiar un directorio en otro, 
se debe estar situado en la carpeta de la carpeta a copiar

cp -r /home/usuario/carpeta1/ /home/usuario/carpeta2/ //Se pueden copiar archivos o carpetas especificando las
rutas completas, en este caso la primera ruta es el directorio o archivo a copiar y la segunda es la ruta donde
se va a pegar lo copiado, ambas rutas separadas por un espacio en blanco.

cp -r carpeta/ carpeta2/ // Ambas carpetas estan en el mismo directorio donde estamos situados, por lo tanto
no hay que especificar las rutas completas de las carpetas involucradas

cp nombre_fichero.xxx nombre_fichero2.xxx // Hacer una copia de un fichero y cambiarle el nombre.

cp -r carpeta1 carpeta2 // Hacer una copia de un directorio y cambiarle el nombre.

mv // Mover un fichero o carpeta y/o cambiar su nombre

mv /home/carpeta/archivo1.txt /home/carpeta2/ // Mover una carpeta o archivo especificando el directorio
de salida y el de llegada, si estan en el mismo directorio no hace falta poner las rutas completas.

mv archivo1.txt archivo2.txt // Renombrar un archivo o carpeta 

rmdir // Borrar una carpeta

rm nombre_fichero // Borrar un fichero

rm fichero1 fichero2 fichero3 // Borrar varios ficheros

rm -r /directorio // Para borrar una carpeta, se le da la ruta del directorio a borrar

rm * // Borrar todos el contenido de una carpeta, se debe estar dentro del directorio

rm -r * // Borrar todo el contenido de una carpeta, incluyendo las carpetas de ese directorio
se debe estar dentro del directorio

sudo rm -rf /xxx/xxxx // rm: Comando "remove", eliminar. -rf: r de "recursivo" donde se borra todo y f de "force";
nunca solicita confirmación. /xxx/xxx indica la ruta de los ficehros o carpetas a borrar.

sudo -i // Pedir contraseña root, algunas versiones basadas en Debian

su // Pedir contraseña del root

root@debian:/home/user# Ctrl + d //Para salir del root, tambien exit, funciona en algunas consolas como python, ruby, entre otras.

Ctrl + r // En la consola, para hacer una busqueda de comandos usados baasndose en la palabra que se introduzca

Shift + Page up <--> Page down // Moverse a traves de los logs de la consola, simula el scroll up/down del mouse

####################################
##### Editor de texto VI o VIM #####
####################################

// Es un editor de texto poderoso, muy usado en la comunidad de desarrolladores de Software Libre para escribir scripts, modificar ficheros
de texto en el shell, programar etc. No posee botones y todas sus funcionalidades se usan a traves de comandos.
Por lo general viene preinstalado en la mayoria de distribuciones, si no es así solo basta con un:

# apt-get install vim // con apt-get

# aptitude install vim // con aptitude

----------------

--- Modos de uso ---

// Al entrar a VIM para editar un fichero por primera vez, estamos en modo de comandos, quiere decir que no podemos editar el texto
sino que solo podremos usar comandos.

vim // Abrir vim, un fichero en blanco sin nombre ni contenido

i // Tecleamos i para entrar en modo de edicion, podemos insertar texto

escape // Pulsamos la tecla escape para salir del modo edicion o de cualquier otro modo, y volvemos al modo comandos.

:q // En modo comandos escribimos :q para salir del editor sin guardar

:q! // Salir del editor sin guardar ni pedir confirmacion

:w nombre_fichero.xxx //Guardamos un fichero nuevo, le asignamos el nombre y la extension si es necesario.

vim nombre_archivo.xxx // Nos aparecerá una ventana en negro, donde nos aparecerá el contenido del fichero o en negro si está vacío
// En la parte inferior, nos aparecerán los mensajes o comandos que escribamos para manejar el editor, así como la línea en la que estamos, porcentaje del fichero, etc.

:w // Guardar un documento

:wq! // Guardar y salir, esta accion aplica a un fichero ya creado, que estemos editando.

:f // Para saber el nombre y extensión del fichero abierto.

u // Deshacer el ultimo cambio

Ctrl + R // Rehacer el ultimo cambio

yy // Copiar la linea

dd // Eliminar una linea, en tal caso la corta y esta lista para pegarse

p // Pegar una linea cortada

guu // Convertir la linea actual en minusculas

gUU // Convertir la linea actual en mayusculas

g // Ir al principio del archivo

G // Ir al final del documento

w // navegar palabra por palabra en el fichero

:/palabra // Para hacer una busqueda de una palabra dentro del archivo
n // Para ir a la siguiente coincidencia.
N // Para ir a la coincidencia anterior

:set nu // Enumerar las líneas del fichéro.

Si queremos que se enumeren siempre las lineas editamos el fichero:

# vim /etc/vim/vimrc

y quitámos las comillas (") a la línea que tiene a set number y guardamos.

:123 // Ir a la linea (x) donde 123 es el número de linea a la cual queremos ir.

:syntax on // Sirve para dar color al codigo que estemos editando, VIM reconoce la sintaxis de muchos lenguajes y
la resalta en colores como muchos otros editores graficos como gedit, sublime, ninja, komodo, Geany.

En /etc/vim en el fichero vimrc descomentamos la linea 
"syntax on // Quitamos las (") para que quede activado directamente la coloracion de codigos

##############################################
########## Cambiar el pass del root ##########
##############################################

$ su: ****** // Acceder como root
# passwd // Nos pedira que introduzcamos la nueva contraseña y la confirmacion para cambiar la clave de root

root@debian:/home/user# passwd
Introduzca la nueva contraseña de UNIX: ****** 
Vuelva a escribir la nueva contraseña de UNIX: ***** 
passwd: contraseña actualizada correctamente
root@debian:/home/user#

#########################################################
########## Instalacion de programas y paquetes ##########
#########################################################

$ man aptitude // Ver el manual de aptitude.

$ man apt-get

# apt-get install Nombre_Paquete // Instalar paquetes

# aptitude install Nombre_Paquete // Instalar paquetes, otra forma

# apt-get build-dep Nombre_Paquete // Intentará satisfacer las dependencias de compilación de un paquete fuente, el comando build-dep
busca en los repositorios locales en el sistema e instala las dependencias de construcción para el paquete. Si el paquete no existe en
el repositorio local se devolverá un código de error.

$ aptitude install -s Nombre_Paquete // Hace una simulacion de la instalacion, podemos ver que procesos haría la instalación

$ apt-get install -s Nombre_Paquete // Simulacion de instalacion con  apt-get install

$ apt-get source Nombre_paquete // Descargar las fuentes del paquete, para compilar e instalar. 

$ sudo aptitude search Nombre_Paquete // Realizar una busqueda en los repositorios del paquete que se quiere encontrar

$ aptitude show Nombre_Paguete // Para ver la informacion del paquete, version, estado, tamaño, conflictos, dependencias, etc.

$ apt-cache show nombre_paquete // Ver informacion del paquete, version, dependencias, descripcion, tamaño, entre otros.

$ apt-cache search nombre_paquete // Buscar un paquete en los repositorios.

$ aptitude versions nombre_paquete // Muestra las versiones de los paquetes listados en la línea de órdenes.

# aptitude remove Nombre_paquete // Elimina o Desinstala el paquete.

# aptitude purge Nombre_Paquete // Elimina el paquete y sus archivos de configuracion.

$ aptitude download nombre_paquete // Descarga el fichero .deb del paquete dado al directorio actual.

$ apt-get download nombre_paquete // Descarga el fichero .deb del paquete dado al directorio actual.

# aptitude reinstall nombre_paquete // Reinstalar un paquete

$ aptitude update // Actualizar la lista de paquetes disponibles.

$ dpkg -l | grep nombre_paquete // Saber si un paquete está instalado y su version.

##### Comparación de las ordenes en apt-get y aptitude #####

### Acción ###
Instalar cualquiercosa
Buscar cualquiercosa
Eliminar cualquiercosa
Lista recursiva de dependencias de cualquiercosa
Mostrar el estado de cualquiercosa
apt-cache policy cualquiercosa
Descargar código fuente de cualquiercosa y crear un paquete .deb

### apt-get ###
apt-get install cualquiercosa
apt-cache search cualquiercosa
apt-get remove cualquiercosa
apt-cache rdepends cualquiercosa
apt-get source --compile cualquiercosa

### aptitude ###
aptitude install cualquiercosa
aptitude search cualquiercosa
aptitude remove cualquiercosa
aptitude search ~Dcualquiercosa
aptitude versions cualquiercosa
?

####################################################
##### Saber la version instalada de un paquete #####
####################################################

xxx --version // Saber la version de algun paquete que tengamos instalado.

Ejemplo:
    bash --version
    gcc --version
    python --version
    ruby --version

#####################################################
########## Comprimir/Descomprimir archivos ##########
#####################################################

paquete.tar y paquete.tar.gz  // tar se refiere a un formato de archivos ampliamente usado en
entornos UNIX identificados por el sufijo de archivo .tar.. Además hace referencia al programa
para la manipulación de archivos que es estándar en estos entornos, pero no incluye la
compresión de los mismos.

tar -cvf paquete.tar directorio // Comprimir un directorio, le damos los parametros de compresion, asi como el nombre del paquete
y el directorio que vamos a comprimir.

-c : indica a tar que cree un archivo
-x : extraer un archivo
-t : listar los contenidos de un archivo
-v : indica a tar que muestre lo que va empaquetando.
-f : indica a tar que el siguiente argumento es el nombre del fichero.tar
-z : comprimir a la vez que se empaqueta

tar -cvf paquete.tar archivo.txt // Creara un paquete con el nombre que le dimos y contiene el archivo.txt 

tar -xvf paquete.tar // Descomprimir un paquete

Descomprimir paquetes.tar.bz2
tar -xjvf example.tar.bz2

Ficheros: .tar.gz:
Comprimir: $ tar -czvf paquete.tar.gz nombre_directorio
Comprimir: $ tar -czvf paquete.tar.gz nombre_fichero.xxx
Descomprimir: $ tar -xzvf paquete.tar.gz

Ficheros: .gz:
Comprimir: $ gzip -9 index.php
Descomprimir: $ gzip -d index.php.gz

Descomprimir ficheros: .tar.xz
$ tar Jxvf fichero.tar.xz

-------------

Cuando nos iniciamos en Linux y buscamos un programa lo normal es que encontremos un .deb o .rpm y en muchos casos nos encontramos programas con
la extensión .tar.gz y .tar.bz2, estos archivos están comprimidos y por lo general contienen aparte del programa unas instrucciones para instalarlo.

La instalación para estos dos tipos de paquetes es exactamente igual, primero entramos a la carpeta donde tengamos el archivo.

$ cd directorio

$ tar -zxvf nombredelarchivo.tar.gz

$ tar -jxvf nombredelarchivo.tar.bz2

-Configuramos, con esta accion se configurara el paquete
para la posterior compilacion, si hacen falta paquetes "dependencias" para la compilacion
por lo general mostrara que paquetes faltan y fallará la configuracion.

$ ./configure

-Hacemos make (compilamos)

$ make

-Ahora make install

$ make install

################################
##### Descomprimir con RAR #####
################################

// Necesitamos instalar unrar

$ aptitude search unrar

Si no lo encuentra debemos bajar el source de http://www.unrarlib.org/
Nos bajara unrarsrc-3.7.8.tar.gz // Descomprimimos, nos dejara la carpeta (unrar)
luego: 
$ cd unrar
$ make -f makefile.unix
$ install -v -m755 unrar /usr/bin // Como root

// Ya deberíamos poder descomprimir .rar

Uso: unrar [OPTION...] ARCHIVE [FILE...] [DESTINATION]
-x, --extract              Extract files from archive (default)
-t, --list                 List files in archive
-f, --force                Overwrite files when extracting
    --extract-newer        Only extract newer files from the archive
    --extract-no-paths     Don't create directories while extracting
-p, --password             Decrypt archive using a password
-?, --help                 Give this help list
    --usage                Give a short usage message
-V, --version              Print program version

ejemplo:
$ unrar x archivo.rar // Para descomprimir un fichero .rar
$ unrar x archivo.rar /home/user/carpeta // Para descomprimir un fichero .rar dando la ruta

###########################################
##### Comprimir/ Descomprimir con ZIP #####
###########################################

$ sudo aptitude install zip // Instalar el paquete de zip

$ zip archivo.zip nombre_fichero.xxx

$ unzip archivo.zip // Descomprimir el fichero

$ zip -r carpeta.zip nombre_carpeta // Comprimir directorios y su contenido

#####################################
########## Instalar APACHE ##########
#####################################

$ sudo apt-get install apache2 // Instalar servidor apache, 127.0.0.1 o LocalHost es para iniciarlo

/var/www/ o /var/www/html // Es la carpeta de donde podemos guardar nuestros proyectos, ficheros etc 
puesto que es la carpeta por defecto de Apache para ese fin, varia según la version de Apache, probablemente
sea la segunda opción.

$ chmod -R 777 /var/www/html // Cambiar los permisos de /var/www puesto que solo tiene permisos root, 
-R para que los permisos se hagan de forma recursiva, esto se hace porque al pegar ficheros
o carpetas estas no tiene los permisos de lectura/escritura necesarios.

sudo aptitude search php // Realizar una búsqueda en los repositorios del paquete que se quiere encontrar

http://192.xxx.xx.xxx/ //La direccion ip sirve para acceder al directorio del servidor

127.0.0.1:80 // Apache cuando está en ejecucion siempre está escuchando por el puerto 80
por lo que si visitamos 127.0.0.1:80 accederemos al servicio

Sus archivos e configuracion están en etc/apache2

$ sudo service apache2 restart // Restart apache para guardar los cambios

###############################################
########## Instalar y configurar PHP ##########
###############################################

apt-get install php5 php5-mysql php5-gd libapache2-mod-php5

// Una vez que se hayan descargado e instalado los paquetes de PHP, solo tienes que reiniciar el 
servidor Apache para que el servicio esté disponible. Para hacerlo solo tienes que teclear los siguientes comandos:

/etc/init.d/apache2 restart

// Para probar que tu servicio esta trabajando puedes crear un pequeño archivo y verlo en tu navegador.
// Para hacer esto puedes teclear los siguientes comandos:

nano /var/www/testphp.php

// agrega las lineas siguientes

<?php
// Muestra toda la información, por defecto INFO_ALL
phpinfo();
?>

Para ver este archivo abre tu navegador web y teclea la IP de tu servidor seguido del archivo que acabas de crear, por ejemplo:

http://127.0.0.1/testphp.php //Si aparece la pagina azul pastel de PHP se instalo correctamente

######################################################
########## Instalar y configurar phpMyAdmin ##########
######################################################

aptitude install phpmyadmin // Instalar

http://localhost/phpmyadmin // Acceder al servicio

***After the installation has completed, add phpmyadmin to the apache configuration.**

# sudo nano /etc/apache2/apache2.conf //Agregar en este archivo la configuracion de abajo

***Add the phpmyadmin config to the file.

Include /etc/phpmyadmin/apache.conf //Esta linea se agrega al final de la configuracion del apache para que reconozca el phpMyAdmin

/etc/init.d/xxx restart // xxx mysql, apache etc... restart


###########################################
########## Instalar MySQL server ##########
###########################################

apt-get install mysql-server

root@debian:/home/user# aptitude search mysql | grep mysql

# mysql -p //acceder al mysql

#############################################################################
##### Comandos para buscar ficheros, directorios, paquetes, historiales #####
#############################################################################

$ history // Mostrar el historial de los comandos de la consola

$ fc -l // Mostrar los ultimos comandos usados por el usuario

$ history | grep xxx // Busqueda especifica de una comando usado, ejemplo: aptitude, alias, grep etc.

.bash_history // En los archivos ocultos del home, en este fichero se almacena el historial de los comandos usados

$ grep --color=always -n "mysql" /var/www/prueba/2/datos.php // --color para colorear la palabra a buscar, 
-n para listar la la linea del caracter buscado y al final ra ruta del archivo a buscar

$ grep cadena_texto ./* -rIn //Busca la cadena de manera recursiva en la carpeta en que se encuentre situado

$ grep --color=always -n "cadena_texto" ./* -Ir //Busca la cadena de manera recursiva en la carpeta en que se encuentre situado

$ grep --color -n "cadena_texto" -Ir // No hace falta poner =always

$ egrep -r "Saludo" . //Otra forma de busqueda.

| grep xxx // filtra la busqueda con el parametro que le demos ejemplo:

$ aptitude search python | grep 2.7 // Busca las versiones de python que coincidan con el patron 2.7

$ ps -e | grep ruby // Busca en los procesos del sistema las coincidencias con ruby

$ whereis python // Para saber donde esta instalado un programa, saber el directorio
$ whereis firefox
$ whereis apache2

$ find // Listar todos los archivos contenidos en el directorio actual y en los sub directorios, si estamos en /home/user nos listara todo, dependiendo de donde este pues listara el contenido.

$ find -name name_dir // Buscar un directorio specifico en el sistema.

su:
find / -type f -name NombreArchivo.html // Para mostrar el directorio del archivo que se 
//quiera buscar, se debe saber el nombre del archivo

file:///home/user/nombre_fichero.xxx // Abrir un fichero del directorio desde el navegador.

$ locate nombre_del_archivo // Hacer una busqueda de un archivo en los directorios, se puede especificar un nombre con su extensión
//o solo especificar una palabra, la busqueda se hara en todos los archivos que contengan la palabra o nombre de archivo escrita.

$ locate "*.jpg" // Buscar todos los ficheros con la extension especificada

$ sudo locate -c hola // Muestra cuantos archivos contienen la palabra "hola" en el nombre.

$ sudo locate -i hola // Busca todos los archivos que contienen la palabra "hola" en el nombre tanto en mayúsculas como en minúsculas.

$ sudo locate nombre_archivo > /home/usuario/lista.txt // Para guardar el resultado de la búsqueda en un archivo de texto.

$ sudo find / -name nombre_carpeta // (/) es para hacer la busqueda desde ahi en adelante, puede ser (/home/user)

$ find /carpeta // Lista los archivos que componen el directorio introducido

$ type nombre_comando // Busca la ruta donde se encuentra el comando, ejemplo: aptitude, python, etc.

$ which nombre_programa // Buscar la ruta de un programa

$ sudo find / -name "*nombre_fichero*" // Buscar en todo el sistema los ficheros cuyo nombre contengan la expresion escrita.

$ sudo find / -name "*.xxx*" // Buscar en todo el sistema los ficheros cuyo nombre contengan la expresion escrita, en este caso,
una extensión de fichero, donde / puede ser /home/user etc y .xxx la extension: .jpg, .png, .txt, .py, etc.

$ sudo find /home/user ! -name "*xxx*" // Busca todos los archivos que NO contienen la palabra "xxx" en el nombre, se especifíca el directorio en el cual buscar.

$ sudo find /home/user -iname "*xxx*" // Busca todos los archivos que contienen la palabra "xxx" en el nombre tanto en mayúsculas como en minúsculas.

$ sudo find /home/user/ -iname "*xxx*" > /home/user/lista.txt // Si el resultado de la búsqueda anterior te ha proporcionado una gran cantidad de información, resulta
más cómodo almacenar el resultado de la búsqueda en un fichero de texto para revisarlo posteriormente.

# sudo find / -type f -name /home/user/fichero.c>>/home/user/x.txt // Crear un fichero (x.txt) que guardará la salida de la consola, en este caso
es una búsqueda, buscamos el fichero.c en el directorio user y guardaremos la salida del shell en el fichero x.txt que se creará.

########################################
##### wget para descargar ficheros #####
########################################

$ wget www.ejemplo_web.com // Descargar toda una página completa, wget no está limitado a solo descargas de archivos. Sitios completos pueden descargarse también.

$ wget -p www.ejemplo_web.com  // Lo mismo que lo anterior pero con esta opción -p descarga además todos los elementos extras necesarios de la página
como hojas de estilos, imágenes en línea, etc.

$ wget -c ftp://sunsite.doc.ic.ac.uk/ls-lR.Z // -c ó --continue, reanudar una descarga de wget si se detuvo por caída de red, cancelación de proceso, etc. Se lanza el comando de nuevo con el enlace para reanudar.

$ wget http://ejemplo.com/programa.tar.gz  ftp://otrositio.com/descargas/video.mpg // Indicar más de una descarga a la vez, incluso con distintos protocolos o extensiones

$ wget http://ejemplo.com/*.pdf // Descargar varios archivos, con extensión similar.

$ wget -i archivos.txt // Descargar varios archivos a traves de una lista.

Creamos una lista en archivos.txt que serán descargados:
http://ejemplo.com/programa.tar.gz
http://ejemplo.com/rpm/paquete.rpm
ftp://otrositio.com/descargas/distro.iso

$ wget -t 50 http://ejemplo.com/pelicula.mpg // Por defecto, wget realiza 20 intentos de establecer la conexión e iniciar la descarga, en sitios muy
saturados es posible que ni con 20 intentos se logré, con la opción -t (tries) aumenta a más intentos.

$ wget -r www.ejemplo.com // Con la opción -r se descarga recursivamente hasta 5 niveles del sitio.

$ wget --convert-links -r http://www.sitio.com/

ó

$ wget -k -r http://www.sitio.com/ // Por defecto, los enlaces dentro del sitio apuntan a la dirección del dominio completo. Si deseas descargar el sitio
recursivamente y después estudiarlo fuera de línea (off line) usa la opción convert-links que los convertirá en enlaces locales, apuntando a las páginas
dentro del sitio descargado.

$ wget --mirror http://ejemplo_web.com/    

ó

$ wget -m http://ejemplo_web.com/ // De este modo obtienes una copia (un espejo) completa del sitio.

$ wget -r -l7 www.ejemplo.com // -l7 (nivel de profundidad) de descargara, es decir descargará en esa profundidad de subdirectorios. De forma predeterminada wget emplea 5.

#################
##### jigdo #####
#################

Jigsaw Download, o abreviadamente jigdo , se propone como la forma principal de distribuir imágenes de CD de Debian en el futuro. Actualmente, el sistema funciona, pero no es aún muy cómodo de usar porque la aplicación gestora de descargas no está terminada.

Página del paquete -> https://www.debian.org/CD/jigdo-cd/

# aptitude install jigdo-file

Aquí, por ejemplo, podemos buscar los .jigdo --> http://cdimage.debian.org/debian-cd/8.5.0/amd64/ en jigdo-dvd/

$ jigdo-lite http://cdimage.debian.org/debian-cd/8.5.0/amd64/jigdo-dvd/debian-8.5.0-amd64-DVD-1.jigdo

#########################################
########## Terminal Terminator ##########
#########################################

//Gran herramienta para los desarrolladores, permite abrir multiples terminales
y poder ordenarlos, muy personalizable, entre muchas otras cosas. **RECOMENDADO**

Paquete: terminator / multiple GNOME terminals in one window

aptitude install terminator // Para instalarlo
apt-get install terminator

Dentro de Terminator:
Ctrl + Shift + o // Abrir un terminal horizontal y paralelo
Ctrl + Shift + e // Abrir un terminal vertical y paralelo
Alt + flechas // Moverse por los terminales
Ctrl + Shift + w // Cerrar un terminal
Ctrl + Shift + x // Maximizar un terminal, igual para salir
Ctrl + Shift + z // Maximizar un terminal(aumentado), igual para salir
Ctrl + Shift + flechas // Cambiar el tamaño a voluntad de un terminal
Ctrl + (+) // Aumentar tamaño de fuente, el (+) del Qwerty
Ctrl + (-) // Minimizar tamaño de fuente, el (-) del Qwerty 
Ctrl + d // Si no hay sesion de usuario abierta, como root y otros cerrará la pestaña o ventana.

-----------------

################################################
########## Ambiente virtual en Python ##########
################################################

// Cuando se desarrollando software con Python, quizas se presente el problema de tener utilizar diferentes versiones de una mismo paquete en
diferentes proyectos, ya sea el mismo Python o diferentes versiones de un Framework como Django por ejemplo, el problema a solucionar radica
en como poder instalar las dos o mas versiones de la misma librería con el fin de poder desarrollar varios proyectos de forma simultánea.

La solución consiste en crear virtualenvs o entornos virtuales. Un entorno virtual de Python es un espacio completamente independiente
de otros entornos virtuales y de los paquetes instalados globalmente en el sistema. Esto significa que es posible instalar la versión
2.7 de Python en un entorno virtual y la versión 3.0 en otro diferente o de forma global sin problema alguno.

El porder tener diferentes entornos donde podemos instalar diferentes versiones de paquetes nos da la oportunidad de hacer un desarrollo simultaneo
así como poder hacer pruebas si afectar a los paquetes del sistema global.

--- Instalación: ---

Para crear un ambiente virtual instale las herramientas python-setuptools, python-dev, python-virtualenv, virtualenvwrapper

# aptitude install python-setuptools python-dev

# aptitude install python-virtualenv virtualenvwrapper

$ mkvirtualenv nombre_ambiente_virtual //  Con un usuario (diferente a root) cree un ambiente virtual para su proyecto.

$ workon nombre_ambiente_virtual // Para acceder al nombre del ambiente virtual creado

ejemplo: 
user@debian:/home$ workon proyecto // Accedemos al entorno virtual creado
(proyecto)user@debian:/home$ // Ya estamos en el entorno virtual creado, denotado por el nombre del entorno al inicio del prompt

$ deactivate nombre_ambiente_virtual // Para salir del entorno virtaul, o simplemente deactivate

$ lsvirtualenv // Para listar los entornos virtuales creados o disponibles.

$ rmvirtualenv nombre_virtualenv // Remover o borrar un entorno virtual.

// Los entornos virtuales se crean en el directorio /home/user/.virtualenvs

##### Usando virtualenv #####

Installation: 

# aptitude install python-virtualenv

-Crear un virtualenv:

$ virtualenv mi_env

-Activar el virtualenv:

$ source mi_env/bin/activate

-Instalar un paquete (p.ej. Django) en el virtualenv:

(mi_env)$ pip install django

-Trabajar en el proyecto.

-Salir del virtualenv:

(mi_env)$ deactivate

--- Using Python 3 in virtualenv ---

$ virtualenv -p python3 my_env

########################
##### Paquetes pip #####
########################

// Para desarrollar software con rapidez y calidad, es imprescindible utilizar paquetes externos que ayuden
con parte de la funcionalidad que se desea implementar. En el ambiente Python esto no es la excepción.

// Para solventar ésta necesidad, la comunidad Python ha puesto convenientemente a disposición de los desarrolladores
un repositorio de paquetes de fácil acceso llamado PyPi. Solo es necesario ejecutar un comando en la terminal
para poder instalar el paquete Python que necesitemos. Incluso es posible instalar paquetes que no se encuentren
en el mencionado repositorio.

// Para descargar paquetes del repositorio PyPi se pueden utilizar varias herramientas, pero en este caso se
va a usar pip. Es necesario instalar esta herramienta en el sistema en caso de no estar disponible, antes
de poder instalar un paquete Python.

// El comando pip equivale al apt-get de Debian pero para paquetes Python.

$ aptitude install python-pip python-dev python-setuptools python3-pip // Instalamos pip y otros necesarios, com python3 para pip, necesario en algunos proyectos.

// Una vez instalado ya podremos instalar paquetes de Python a traves de pip ejemplo:

$ pip install django // Nos instalara la ultima version de Django disponible en los paquetes pi

$ pip install django==1.7 // Instalar una versión específica de algun paquete.

// Tambien es posible crear ficheros que contengan rutinas para automatizar la instalacion
de varios paquetes ejemplo:

Creamos un requirements.txt y dentro escribimos como ejemplo:
django==1.5.12
pillow==2.4.0
Geraldo==0.4.17

// Luego podemos ejecutar un pip install sobre el fichero e instalará lo que contenga:

pip install -r requirements.txt

// Dentro de los .virtualenvs, dentro de nuestro entorno virtual en
lib/python2.7/site-packages podemos ver que se instalaron los paquetes de requirements.txt
de no ser así hay que revisar el fichero o el nombre de los paquetes a instalar, etc.

$ pip search nombre_paquete // Buscar un paquete.

$ pip uninstall package // Desinstalar un paquete.

#############################################
########## Conexion remota con ssh ##########
#############################################

# aptitude install ssh

--> configurarlo

# aptitude install openssh-server

SSH (Secure SHell) es el nombre de un protocolo y del programa que lo implementa, y sirve para acceder
a máquinas remotas a través de una red. Permite manejar por completo la computadora mediante un intérprete
de comandos, y también puede redirigir el tráfico de X para poder ejecutar programas gráficos si tenemos ejecutando un Servidor X (en sistemas Unix y Windows).

Además de la conexión a otros dispositivos, SSH nos permite copiar datos de forma segura
(tanto archivos sueltos como simular sesiones FTP cifradas), gestionar claves RSA para no escribir
claves al conectar a los dispositivos y pasar los datos de cualquier otra aplicación por un canal seguro tunelizado mediante SSH.

$ ssh Nombre_usuario@IP_servidor o nombre_servidor

ssh user@192.168.0.240 // Asi se accede a un ordenador o servidor remoto, debemos poner el usuario que debe estar creado asi como la ip
del server, nos pedira la clave de session, una vez adentro tenemos acceso a los archivos y podemos pedir el root para tener acceso total.
ssh es muy usado por administradores de redes y de sistemas para acceder a las maquinas y los servidores y hacer cambios asi 
como monitorear los procesos que esten ejecutando, especialmente en maquinas virtuales si varios proyectos corren en un mismo servidor.

Conectado al servidor, podemos enviar mensajes o abrir programas remotamente, ejemplo:

echo "mensaje" > /dev/pts/2 // Enviar mensaje a traves del shell a otro usuario, en el servidor o local, debe haber un shell abierto que sea receptor
Se puede hacer localmente para probar, con (who) veremos la identificacion de cada shell, si estamos conectados remotamente, comprobaremos si hay shells
abiertos en el local y el servidor, se identifican con los pts/0, pts/1, etc, y sabremos por la ip si son shells locales o del server  el mensaje sale en
el shell escogido.

$ export DISPLAY=:0.0 // Creamos la ventana virtual donde se abrira la aplicacion que ejecutemos, luego
$totem o $nautilus // Deberia abrir el programa en el servidor, ya esportada la ventana podemos:

DISPLAY=:0.0 totem // Abrir el reproductor totem en el servidor

DISPLAY=:0.0 nautilus // Abrir el explorador de archivos en el servidor

--- COPIAR ARCHIVOS DE LOCAL A SERVIDOR ---
Si queremos subir el archivo archivo.txt de nuestro ordenador a la carpeta /home/usuario del servidor, hacemos lo siguiente:

$ scp archivo.txt usuario@dominio.com:/home/usuario // Se especifica el archivo a copiar, luego el servidor y luego el directorio 
en el servidor donde copiaremos el archivo.

--- COPIAR ARCHIVOS DE SERVIDOR A LOCAL ---
Si queremos copiar el fichero archivo.txt del servidor a nuestro ordenador en la carpeta Documentos, hacemos lo siguiente:

$ scp usuario@dominio.com:/home/usuario/archivo.txt /home/usuario/Documentos // Especificamos el servidor, luego la ruta y el archivo a copiar y luego el directorio local donde sera copiado el archivo.

--- COPIAR ARCHIVOS DE SERVIDOR A SERVIDOR ---

$ scp usuario1@dominio1.com:/home/usuario1/archivo.txt usuario2@dominio2.com:/home/usuario2/

--- COPIAR UN DIRECTORIO COMPLETO DE LOCAL A SERVIDOR ---
Para copiar un directorio completo de mi ordenador al servidor, por ejemplo /home/mario/carpeta a /home/usuario, añadimos un -r en el comando:

$ scp -r /home/mario/carpeta usuario@dominio.com:/home/usuario

$ scp -r /home/mario/carpeta usuario@dominio.com: // Con los dos puntos al final se copiara automáticamente en el home del usuario.

--- COPIAR UN DIRECTORIO COMPLETO DE SERVIDOR A LOCAL ---
Para copiar un directorio completo del servidor al local, por ejemplo /home/usuario/carpeta a /home/user/docs, añadimos un -r en el comando:

$ scp -r usuario@dominio.com:/home/usuario/carpeta /home/user/docs

####################################################################
##### Conexion por nautilus explorador de archivos/directorios #####
####################################################################

Usando el navegador de archivos de Debian, Ubuntu, etc, podemos acceder a ordenador remoto "servidor" para ver graficamente 
los directorios, es decir, desde nuestro navegador de archivos, navegaremos en los directorios del servidor, para acceder vamos a:

$ nautilus

Archivo > Conectar con el servidor // Nos saldrá una ventana para llenar con:

Servidor: 192.168.12.400 // Aqui va la ip del servidor
Puerto: 22 // El puerto que tiene habilitado el ssh_config
Tipo: SSH
Carpeta: /home // Carpeta que abrira al entrar en conexion
Nombre de usuario: // Nombre de usuario, de sesion de ese servidor
Contraseña: // Contraseña de la sesion de usuario del servidor

Si todo esta bien deberia entrar a explorar los directorios del servidor.

###########################################
##### X11 forwarding a través de ssh  #####
###########################################

X11, como supongo la mayoría de Uds. sabrá, es el servidor gráfico que usan casi todas las distribuciones Linux. Este servidor permite, entre otras cosas,
forwarding a través de SSH. Esto significa que es posible ejecutar apliaciones gráficas de una máquina remota exportando el display a nuestro escritorio.
Es decir, la aplicación se ejecuta en el servidor remoto, pero la interfaz gráfica la visualizamos en nuestro escritorio local.

Ejemplo:
1- En el servidor, editar el archivo /etc/ssh/ssh_config y modificar la opción X11Forwarding o ForwardX11 para que quede así:

X11Forwarding yes

ó

ForwardX11 yes

Luego de este cambio, posiblemente sea necesario reiniciar el demonio ssh. La forma de hacer esto varía de acuerdo a cada distribución Linux.
Lo más sencillo es reiniciar la máquina.

2- En el escritorio local, loguearse al servidor a través de ssh utilizando el parámetro -X:

$ ssh -X user@hostname

Donde user es el nombre de usuario utilizado para loguearse en el servidor y hostname es el ip o el alias del servidor.

3- Para ejecutar una aplicación, simplemente hay que hacerlo desde el terminal. Por ejemplo:

$ firefox

$ nautilus

$ evince

Cuando ejecutamos una aplicación gráficamente la consola se bloqueara con el proceso en ejecución, por lo que podemos usar &
para que se ejecute el proceso, construya el entorno grafico del programa y luego dezplace el proceso para poder seguir usando la
consola, ejemplo:

$ firefox

ó

$ firefox & nautilus &

##### El error ssh remote host identification has changed #####

Cuando el sistema base guarda una llave de acceso a un host, pero el host cambió, entonces la llave no funciona y arroja el típico erro:

@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@    WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED!     @
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
IT IS POSSIBLE THAT SOMEONE IS DOING SOMETHING NASTY!
Someone could be eavesdropping on you right now (man-in-the-middle attack)!
It is also possible that a host key has just been changed.
The fingerprint for the ECDSA key sent by the remote host is
...
...
...

Entonces borramos ese host roto, llave perdida, etc.

$ ssh-keygen -R <host>

Ejemplo:

$ ssh-keygen -R 192.168.3.10

#############################################
##### Programación shell-script (bash) ######
#############################################

--- ¿Qué es un "Script"? ---

Es un archivo que contiene código escrito en determinado lenguaje de programación que el sistema usa para determinada tarea.
No es necesario que tenga una entrada externa ni interfaz gráfica, pero sí que provoque una salida de datos procesados
(por más de que el usuario no los vea).

El lenguaje usado por Bash está definido por su propio intérprete y combina la sintaxis de otros Shells, como el Korn Shell (ksh) o el C Shell (csh).
Muchos de los comandos que usualmente se usan en la consola también pueden usarse en los scripts, salvo aquellos que pertenecen estrictamente a una
distribución en particular.

--- Estructura de un Script ---

Para empezar debemos contar con un editor de texto, los archivos que guardamos con extensión .sh podrán ser ejecutados (o interpretados) por la consola
siempre y cuando la primera línea sea la siguiente:

#!/bin/bash

Esto le dice al sistema que deberá usar la consola para ejecutar el archivo. Además, el carácter # permite escribir comentarios.

echo // muestra un mensaje en pantalla, en este caso el típico "Hola Mundo". Si lo guardamos y ejecutamos con la consola veremos el resultado.

Bash (y otros shells) permiten programar scripts
--Bash (Bourne again shell) es un programa informático cuya función consiste en interpretar órdenes.
Está basado en la shell de Unix.

Script o programa shell: Fichero de texto conteniendo comandos externos e internos
que se ejecutan línea por línea, el programa puede contener, además de comandos
variables, constructores lógicos (if...then, AND, OR, etc.) y lazos (while, for, etc.)
funciones comentarios

--- Ejecución de un script ---

Los scripts deben empezar por el simbolo #! seguido del programa a usar para interpretar el script:

#!/bin/bash // Script de bash
#!/bin/sh // Script de shell
#!/usr/bin/perl // Script de perl

----------------------------

#Ejemplo de programa en bash para imprimir valores de variables
#!/bin/bash
VAL=10
VAL2=20
echo $VAL
echo $VAL2

----------------------------

Guardamos el script, ejemplo: prueba.sh, no es necesario ponerle
la extensión ya que la cabecera del script especifíca que programa
lo interpretará

Ejecución:

sh prueba.sh // Ejecutar un programa con bash.

bash prueba.sh // Ejecutar un programa con bash.

./script.sh // Otra manera de ejecutar el script.

sh prueba // Ejecutar un programa con bash, script guardado sin extension.

------------------------

#Ejemplo de programa en bash para ejecutar aplicaciones instaladas en el SO.
#!/bin/bash
#val=10
val='##### Abriendo Meld #####'
echo $val
/usr/bin/meld

------------------------

#Ejemplo de programa en bash que crea un fichero en el directorio en que se ejecuta.
#!/bin/bash
touch FFF.txt

------------------------

# Ejemplo de programa en bash que crea un fichero en un directorio específico.
#!/bin/bash
touch /home/aosorio/FFF.txt

------------------------

#Crear una carpeta, entrar en la carpeta y crear un fichero dentro.
#!/bin/bash
mkdir proyecto &&
cd proyecto &&
touch FFF.txt

------------------------

#Comprimir un directorio con un script de bash.
#!/bin/bash
DIRS="proyecto"
tar -cvf backup.tar $DIRS

------------------------

#A Simple Bash Example
#!/bin/bash  
echo "This is a shell script"  
ls -lah
echo "I am done running ls"  
SOMEVAR='text stuff'
echo "$SOMEVAR"

------------------------

#Usando una funcion, y viendo el funcionamiento de variables locales y globales.
#!/bin/bash
HOLA=Hola_global
function hola {
    local HOLA=Mundo_local
    echo $HOLA
}
echo $HOLA
hola
echo $HOLA

-----------------------

#Abrir un fichero específico con el editor gedit
#!/bin/bash
gedit /home/user/try.txt

-----------------------

#Llamado de una Funcion
#!/bin/bash
a='Estaba la pájara pinta'
function Imprimir {
    local a='sentada en un verde limón.'
    echo $a
}
echo $a
Imprimir
#echo $a

#################
##### RSYNC #####
#################

Es una aplicación que ofrece transmisión eficiente de datos, que opera también con datos comprimidos y cifrados.
Mediante una técnica de delta encoding, permite sincronizar archivos y directorios entre dos máquinas de una red
o entre dos ubicaciones en una misma máquina, minimizando el volumen de datos transferidos.
Muy recomendable para hacer respaldos en discos externos.

aptitude install rsync // Instalarlo desde los repositorios de debian

Parametros: -P para mostrar el progreso de la copia y -r cuando se van a copiar directorios

rsync -P ficehero /directorio/carpeta2 // Para copiar ficheros, archivos, etc. 

rsync -P -r /directorio/carpeta1_origen /directorio/carpeta2_destino // -r para copiar directorios se ponen las dos rutas: origen y destino separados por un espacio
**Ojo con carpeta1, sin el / al final, lo cual significa que se va copiar la carpeta completa con su contenido y no solo su contenido.

##################################
##### Crear alias de comandos #####
##################################

Un alias es una palabra o frase que se asignara para 
remplazar un comando, por lo generalmente se usa para
remplazar comandos muy largos y dificiles de recordar
por lo que es una gran ventaja la creacion de alias.

Un alias Se pueden crear temporalmente, directamente en la consola
y durara hasta que cerremos ese shell, tambien asignar permanentemente
escribiendolo en el archivo .bashrc que esta en el /home 

$ alias nombre_alias='comando'

Ejemplo:
$ alias sa='aptitude search apache | grep rt4' // (sa) ahora es el alias de 
ese comando de busqueda en los repositorios de un paquete especifico.

$ unalias nombre_alias // Para eliminar el alias creado temporalmente

Otros ejemplos:

# some more ls aliases
alias ll='ls -l --color'
alias buscar='grep --color -n -Ir'

// Para que se haga efectivo algun cambio en .bashrc es necesario reiniciar
pero hay otra forma de actualizar el fichero sin reiniciar, entonces:

$ source .bashrc // Bastara para que se apliquen los cambios hechos

// Mensaje de bienvenida al usuario

Pegamos esto al final del .bashrc, reiniciamos el fichero
y ahora cada vez que iniciemos un shell nos saludará.

## Mensaje al iniciar
echo "Hola Usuario"

########################################################
### Saber la direccion ip de una pagina o un sevidor ###
########################################################

user@debian:~$ nslookup google.com // Saber la de google por ejemplo
Non-authoritative answer:
Name:   google.com
Address: 216.58.192.110 // Direccion ip de google

--- Otra forma ---

$ ping google.com // Haciendo ping al una pagina 
PING google.com (216.58.192.110) 56(84) bytes of data.
64 bytes from mia07s35-in-f14.1e100.net (216.58.192.110): icmp_req=1 ttl=49 time=69.6 ms // Ip de google
64 bytes from mia07s35-in-f14.1e100.net (216.58.192.110): icmp_req=2 ttl=49 time=70.4 ms

--- google.com ping statistics ---
3 packets transmitted, 2 received, 33% packet loss, time 2001ms
rtt min/avg/max/mdev = 69.645665/70.00475/470.48645/0.010 ms

########################################
##### Compilar e instalar paquetes #####
########################################

$ aptitude search build-essential // Este paquete es esencial para crear y manejar paquetes debian,
por consiguiente para la creación, compilacion e instalación de programas en debian, ubuntu etc.
Tambien se instala cuando se va a desarrollar con c y c++ puesto que la instalacion incluye
los compiladores y las librerias necesarias para comenzar a trabajar en estos lenguajes.

Descargámos el código fuente del programa que queremos compilar e instalar.
Normalmente lo encontraremos en un archivo comprimido, con extensión tar.bz2. 
Así que tendrás que descomprimirlo escribiendo en la consola:

$ tar xvzf paquete.tar.gz (o ver sección de Comprimir/Descomprimir archivos arriba)

//Ahora vamos al directorio donde hemos extraído el contenido del paquete:
$ cd path_del_paquete

// Confguramos el modo de compilación con:
./configure

Luego escribimos:
make

Y finalmente, instalamos con:
make install

// Si no hay errores ya deberíamos poder usar el programa instalado.

#################################
### DIA - Editor de diagramas ###
#################################

Es un editor de diagramas, grafos, gráficas, etc. Ofrece soporte para diagramas de estructuras
estáticas en UML (diagramas de clases), diagramas de  Entidad-Relación, diagramas de redes y mucho más.
Los diagramas se pueden exportar a postscript y a otros formatos.

$ aptitude install dia

################
##### Meld #####
################

Es una herramienta gráfica para hacer archivos diff y fusionarlos.
Permite al usuario ver los cambios entre, y fusionar, dos archivos, dos directorios, o dos archivos con un ancestro común.

$ aptitude install meld

########################################
##### Cambiar permisos de usuarios #####
########################################

Al ver los permisos de los ficehros o directorios nos encontramos con varios parametros:

En la primera columna se pueden ver una serie de letras y guiones (-rwxr-x---)
estas letras nos dicen quien en el sistema, y que clases de permisos tiene el fichero o carpeta.

Estas letras están agrupadas en tres grupos con tres posiciones cada uno
más una primera posición que nos dice de que clase de archivo se trata
(los mas normales (d) directorios, o (-) archivos de datos).

El primer grupo de tres (rwx en nuestro caso) nos dice que clase de permisos tiene el dueño del fichero (u)(user/owner)
El segundo grupo de tres (r-x en nuestro caso) nos dice que clase de permisos tiene el grupo del fichero (g)(group).
Y el último grupo de tres (--- en nuestro caso) nos dice que clase de permisos tienen todos los demás usuarios del sistema sobre este
fichero (o)(others).

r :significa permiso para leer 
w :significa permiso para escribir  
x :significa permiso para ejecutar

u :permisos para el usuario/dueño del fichero/directorio
g :permisos de grupos
o :permisos de los demás usuarios

Los permisos se pueden especificar de diferentes maneras, una serie de ejemplos, es lo mejor para comprenderlo:

chmod ugo+rwx (da permisos rwx a todos, user,group,others)
chmod ugo-x test (quita permiso x (ejecucion) a todos, user,group,others) 
chmod o-rwx test (quita permisos rwx a others) 
chmod u=rwx,g=rx (da permisos rwx a user, rx a group y ninguno a others)

chmod -R u=rwx,g=rx,o=rx /dir/dir2/dir3 // Ejemplo de como otorgar permisos a un directorio específico, estos serían los permisos
predeterminados o por defecto de un directorio.

##### chmod en octal ######

Representación octal de chmod

Lectura tiene el valor de 4
Escritura tiene el valor de 2
Ejecución tiene el valor de 1

Entonces:

rwx |  7  | Lectura, escritura y ejecución
rw- |  6  | Lectura, escritura
r-x |  5  | Lectura y ejecución
r-- |  4  | Lectura
-wx |  3  | Escritura y ejecución
-w- |  2  | Escritura
--x |  1  | Ejecución
--- |  0  | Sin permisos

Por lo tanto:

chmod u=rwx,g=rwx,o=rx  | chmod 775 |
chmod u=rwx,g=rx,o=     | chmod 760 |
chmod u=rw,g=r,o=r      | chmod 644 |
chmod u=rw,g=r,o=       | chmod 640 |
chmod u=rw,go=          | chmod 600 |
chmod u=rwx,go=         | chmod 700 |

################################################
##### CCLive - Descargar videos de youtube #####
################################################

CCLive es una aplicación que nos permite descargar un vídeo que esté en YouTube
hacia nuestro ordenador mediante un simple comando. Por defecto guarda los vídeos en webm.

$ aptitude show cclive //Para ver si lo tenemos en los repos, y ver la descripción, si es así.

$ aptitude install cclive // Instalación, como root.

ó

$ sudo apt-get install cclive // Instalación, como root.

$ cclive https://www.youtube.com/watch?v=yWVrvce5R9 // Descargar un video pasando la url de youtube.

$ cclive URL1 URL2 URL3 URL4 // Soporta varias URLs a la vez, para bajar mas de 1 video.

$ cclive < urls.txt // Descargar un vídeo detrás de otro, desde un archivo de texto plano con todas las URLs (en líneas diferentes).

$ man cclive // Manual del paquete.

$ cclive -F https://www.youtube.com/watch?v=Lfj667lLLnE // Comprobar los formatos disponibles antes de descargar el video.
// Se podrá ver un listado de formatos disponibles separados por "|"

$ cclive -f fmt22_720p https://www.youtube.com/watch?v=LtzFg4JiL5E // Se elige el formato y se pasa en el comando, luego comenzará la descarga.

$ cclive -f best http://www.youtube.com/xxxxxx // Download the best available format of the media.

#################################################################################
##### Cifrado de ficheros gpg, cifrado simétrico, asimétrico, firma digital #####
#################################################################################

$ aptitude search gnupg // Revisar si está instalado gnupg

##### ¿Qué es GnuPG? (GNU Privacy Guard) #####

Es un derivado libre de PGP y su utilidad es la de cifrar y firmar digitalmente, siendo además
multiplataforma (podéis descargarlo desde la página oficial) aunque viene incorporado en algunos
sistemas Linux, como en Ubuntu o Debian.

GnuPG es una herramienta de GNU para la comunicación y el almacenamiento de datos de manera segura. Se puede utilizar para
cifrar datos y para crear firmas digitales. Incluye capacidad avanzada de gestión de claves y cumple con el estándar de
Internet OpenPGP propuesto tal como se describe en el RFC 4880. 

##### Anillo de claves #####

GPG tiene un repositorio de claves (anillo de claves) donde guarda todas las que tenemos almacenadas en nuestro sistema,
ya sean privadas o públicas (como comenté, con la clave pública cifraremos un mensaje que solo podrá descifrar el
que posee la clave privada).

Más adelante cuando veamos un anillo de claves debemos de recordar que pub hace referencia a la clave pública y sub hace referencia
a la privada (y que tenemos que tener a buen recaudo).

##### Servidores de claves #####

Para que nos cifren un mensaje tenemos que compartir la clave pública de nuestro par de claves para cifrar, y como es un poco
engorroso difundir una clave a muchas personas existen los servidores de claves PGP (compatibles con GPG), donde subiré una
clave pública para el que quiera probar los ejemplos. Unos ejemplos de servidores son estos: pgp.rediris.es (español, aunque falla algunas veces)
o pgp.mit.edu (americano, del MIT y a mi no me ha dado problemas).

##### El cifrado simétrico y asimétrico #####

-En el cifrado simétrico, ciframos el archivo con una clave X
Para descifrarlo y obtener el archivo original, utilizamos la misma clave X.

-El cifrado asimétrico es más complicado. Aquí no tenemos una sola clave común. En su lugar
cada persona tiene dos claves, una pública y una privada. Para enviarle un archivo a un amigo
lo cifras con su clave pública. De esta forma, sólo lo puede descifrar él con su clave privada.
Es más seguro que el cifrado simétrico, ya que la clave de descifrado (la privada) nunca se
comparte, siempre la tiene el receptor.

Ejemplo: Sabiendo lo anterior, si queremos que tres compañeros de trabajo nos manden un archivo
cifrado debemos de mandarle nuestra clave pública (que está vinculada a la privada) y nos
podrán mandar de forma confidencial ese archivo que solo nosotros podremos
descifrar con la clave privada.

##### Cifrado simétrico #####

El cifrado simétrico es el tipo de cifrado más sencillo que hay, es más rápido de procesar y por desgracia
menos seguro que el cifrado asimétrico.

Crear un fichero cualquiera de ejemplo

$ touch prueba.txt

Dentro del fichero copiaremos algún texto de prueba para comprobar luego con el descifrado.

Luego en el shell escribimos el comando gpg con el parámetro -c para cifrar y -d para descifrar.

##### Parámetros básicos de gpg #####

-c // Encrypt with a symmetric cipher using a passphrase. The default symmetric cipher used is CAST5,

-d // Decrypt the file given on the command line

$ gpg -c prueba.txt // El comando gpg -c nombre_fichero nos aparecerá un cuadro que nos pide la contraseña
luego una confirmacion de la misma, luego  generará un archivo .gpg

Para descifrarlo usamos el comando gpg -d notas.txt.gpg introduciendo la contraseña correcta para poder decifrarlo.

$ gpg -d prueba.txt.gpg // Descifrar el fichero, nos permitira mirar el contenido.

$ man gpg // Ver el Manual de gpg

##### Cifrado asimétrico #####

*** Generar las claves ***

Para poder cifrar asimétricamente primero tenemos que crear la pareja de claves
(pública y privada) con el comando gpg --gen-key

$ gpg --gen-key
gpg (GnuPG) 1.4.12; Copyright (C) 2012 Free Software Foundation, Inc.
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.

Por favor seleccione tipo de clave deseado:
   (1) RSA and RSA (default)
   (2) DSA and Elgamal
   (3) DSA (sólo firmar)
   (4) RSA (sólo firmar)
Su elección:

// GPG nos permite elegir el tipo de clave que queremos usar, hay opciones que solo permiten firmar
y otras que permiten firmar y cifrar, en este caso usaremos DSA y Elgamal.

las claves DSA pueden tener entre 1024 y 3072 bits de longitud.
¿De qué tamaño quiere la clave? (2048)

Nos pedirá el tamaño de la clave que puede variar entre 1024 bits y 3072, esto es de libre elección,
tomarémos el que propone por defecto (2048).

Nos pide la fecha en la que expirará la clave, la información del emisor de la clave
(nombre, mail y algunos datos extra que queramos dar) y por último nos pedirá la
contraseña que salvaguarda la clave privada.

Tras generar las claves podemos verlas con el comando gpg -k que nos muestra nuestro
anillo de claves, lo importante de este paso es que veremos la identificación de cada una
que es necesaria para poderlas exportar y enviar.

$ gpg -k // Visualizar anillo de claves

/home/user/.gnupg/pubring.gpg
--------------------------------

pub   1559C/88651986 2017-01-01
uid                  username_lastname (Enunciado de la clave) <username@email.com>
sub   2048g/55GD33FG 2017-01-01

##### Exportar y enviar la clave pública #####

El objetivo de esta pareja de claves es que cualquiera nos pueda mandar un archivo cifrado
que solo veremos nosotros y esto se hace difundiendo la clave pública que acabamos de crear
(la pública, nunca la privada), para exportarla en un archivo usaremos el comando:

$ gpg -output [archivo destino] --export [ID de a clave pública] (la clave pública generada antes tiene la ID 88651986).

$ gpg --output ClavePublica_username.gpg --export 88651986

$ ls
ClavePublica_username.gpg // Fichero generado que contiene la clave pública

Este archivo ahora se puede difundir por el medio que queramos.

##### Subir una clave pública a un servidor de claves #####

Los servidores de claves suelen ser de acceso público (al no haber mucho problema por difundir una clave pública) y en este caso
subiremos una clave a los servidores del MIT (pgp.mit.edu) usando el comando:

$ gpg --send-keys --keyserver [Dirección del servidor] [ID de la clave pública] (al igual que antes la ID es 88651986).

$ gpg --send-keys --keyserver pgp.mit.edu 88651986

Entramos a --> https://pgp.mit.edu/ y buscamos nuestra clave pública por El Nombre y Apellido que añadimos cuando la estuvimos creando.

##### Importar la clave desde el archivo o servidor de claves #####

Para poder usar la clave pública para cifrar o comprobar la identidad del remitente tenemos que importar previamente la clave, desde un archivo
debemos de usar el comando gpg --import [Archivo de la clave pública]

$ gpg --import CPub.gpg 

Al tener la clave ya en mi anillo de claves me contesta que no hay cambios.

Para realizar la importación desde el servidor tenemos que usar el comando

$ gpg --keyserver [Dirección del servidor] --recv-keys [ID de la clave]

$ gpg --keyserver pgp.mit.edu --recv-keys 5616846865

##### Borrar una clave de mi anillo de claves #####

$ gpg --delete-keys id_key // Pasamos el id de la clave que queremos borrar.

##### Cifrar un fichero #####

$ vim x.txt // Creamos el fichero, lo llenamos con algo de texto para la prueba, lo guardamos.

gpg --encrypt --recipient [ID de la clave] [Archivo] // Cifrar con una clave pública.

gpg --encrypt --recipient 88651986 x.txt // Ciframos el fichero con la clave publica creada para la prueba.

Nos creará un fichero: x.txt.gpg // Fichero cifrado con la clave pública

##### Descifrar un archivo con la clave privada #####

$ gpg -d [Archivo] e introduciendo la contraseña que creamos para salvaguardar la clave privada.

$ gpg -d x.txt.gpg

Nos mostrará

Necesita una frase contraseña para desbloquear la clave secreta
del usuario: "Name_user Last_name (comment) <mail@mail.xxx>"
clave RSA de 2048 bits, ID 88651986, creada el 201x-xx-xx(ID de clave primaria 5F829889)

Introduzca frase contraseña:

---

La contraseña es la clave privada, la cual solo tendremos nosotros y nunca compartiremos, pues es la que nos permite descifrar los ficheros
que fueron cifrados con nuestra clave publica.

##### Firmar archivos #####

Una de las medidas de seguridad básicas al pasar un mensaje o fichero es asegurarnos que el emisor es quien dice ser, para asegurarnos de esto
digitalmente existe la firma digital, podemos cifrar y a su vez firmar ficheros, que es lo que haremos con el comando:

$ gpg -u [ID de la clave] --output [Archivo resultante] --sign [Archivo para firmar]

...e introduciendo la contraseña de la clave privada.

$ gpg -u 88651986 --output x_firmado.txt.gpg --sign x.txt

...

Necesita una frase contraseña para desbloquear la clave secreta
del usuario: "xxx xxx (xx) <mail@mail.xxx>"
clave RSA de 2048 bits, ID 88651986, creada el 201x-xx-xx

Introduzca frase contraseña: 

...

nos generará el fichero:

x_firmado.txt.gpg

##### Verificar y descifrar un archivo firmado #####

Cualquiera con la clave pública asociada a la que ha firmado el documento puede leerlo, de la misma forma que desciframos un archivo
(gpg -d [Archivo]) o verificándolo únicamente con el comando gpg --verify [Archivo].

$ gpg --verify x_firmado.txt.gpg 

muestra...

gpg: Firmado el xxx xx xx 201x xx:xx:xx VET usando clave RSA ID 88651986
gpg: Firma correcta de "User_name Last_name (comment) <user@mail.xxx>"

##### Exportar la clave privada #####

Si queremos verificar o firmar desde otro equipo con nuestra clave privada tenemos que tener nuestra clave privada
en ese equipo, para eso es necesario copiar el directorio .gnupg que está en el /home/user de la máquina en la cual
creamos la clave privada a la nueva máquina.

#####################################
##### Configurar sudo en Debian #####
#####################################

En Debian no viene instalado y configurado por defecto.

$ aptitude install sudo

Una vez con el sudo instalado deberemos agregar nuestro usuario en la sección "User privilege specification"
en el archivo /etc/sudoers, de tal forma que la sección quede así:

User privilege specification
root ALL=(ALL) ALL
tu_usuario ALL=(ALL) ALL

Una vez configurado esto, ya podremos ejecutar acciones de administrador desde una terminal común, anteponiendo el sudo a la acción a realizar.

###################################################################
##### Lista de fuentes de los paquetes de debian sources.list #####
###################################################################

----- Apt -----

Apt (Advanced Package Tool) es un set de herramientas del núcleo de Debian. Apt hace posible:
instalar, eliminar, mantener sus aplicaciones al día y mucho más... 

Apt, que basicamente resuelve problemas de dependencias y busca los paquetes solicitados, trabaja con dpkg, otra herramienta
que maneja la instalación y eliminación de paquetes (aplicaciones). Apt es muy poderoso, y se usa frecuentemente desde la línea
de comandos o consola/terminal. Sin embargo, hay muchas herramientas GUI/Gráficas para ayudarle a usar Apt sin tener
que tocar la línea de comando.

Al presente, aptitude es la herramienta recomendada para interactuar con la suite APT. Las herramientas APT deben ser usadas
especificamente para manejar acciones que no puedan ser manejadas por aptitude, o dónde se necesite mayor control de las dependencias. 

/etc/apt/sources.list // APT utiliza un archivo que enlista las "fuentes" en donde se encuentran los paquetes. Este archivo es: /etc/apt/sources.list

El contenido de este archivo, normalmente sigue este formato:
    deb http://host/debian distribución sección1 sección2 sección3
    deb-src http://host/debian distribución sección1 sección2 sección3

Los renglones arriba mencionados son ficticios y no deberán ser usados. La primera palabra en cada línea, deb o deb-src, indican
el tipo del archivo: ya sea que contenga paquetes binarios (deb), esto es, los paquetes pre-compilados que normalmente se usan
o los paquetes fuente (deb-src), que son los códigos originales, más el archivo de control de Debian (.dsc) y el diff.gz que
contienen los cambios necesarios para "debianizar" el programa.

Generalmente se encuentra lo siguiente por defecto en el archivo sources.list:

     # See sources.list(5) for more information, especialy
     # Remember that you can only use http, ftp or file URIs
     # CDROMs are managed through the apt-cdrom tool.
     deb http://http.us.debian.org/debian stable main contrib non-free
     deb http://non-us.debian.org/debian-non-US stable/non-US main contrib non-free
     deb http://security.debian.org stable/updates main contrib non-free
     
     # Uncomment if you want the apt-get source function to work
     #deb-src http://http.us.debian.org/debian stable main contrib non-free
     #deb-src http://non-us.debian.org/debian-non-US stable/non-US main contrib non-free

Éstas son las líneas necesarias para una instalación básica de Debian. La primer línea deb apunta al archivo en el servidor oficial
la segunda línea apunta hacia el archivo del servidor non-US y la tercera línea apunta hacia el archivo del servidor de
actualizaciones de seguridad.

Las dos últimas líneas están deshabilitadas (con un "#" al inicio), así que apt-get las ignora. Éstas son las líneas de deb-src
esto es, apuntan hacia los paquetes fuente de Debian. Si frecuentemente descarga paquetes fuente para probar o recompilar
habilítelas (borrando el "#" al inicio de la línea).

El archivo /etc/apt/sources.list puede contener varios tipos de líneas. APT sabe como interpretar líneas del tipo http,
ftp, file (archivos locales, p.e., un directorio que contiene un CD-ROM) y ssh, según mis conocimientos.

No olvide ejecutar el comando apt-get update después de modificar el archivo /etc/apt/sources.list. Debe hacer
esto para permitir a APT obtener la lista de paquetes de las fuentes que especificó.

#########################################################
##### Quemar o grabar una imagen iso en un pendrive #####
#########################################################

# dd if=[imagen] of=[dispositivo]

En donde imagen es la ruta completa a la imagen ISO que deseas grabar y dispositivo la ruta completa hacia el pendrive, no la ruta con el nombre del pendrive, por ejemplo:

dd if=/home/user/Descargas/debian-testing-i386-businesscard.iso of=/dev/media/sdb

-----

$ export GIT_SSL_NO_VERIFY=True // Si un repostirotio git remoto no cuenta con el certificado
digital del servidor a veces se debe saltar chequeo de la firma para bajar las fuentes con este comando.

###########################################
##### Formatear pendrives desde linux #####
###########################################

# aptitude install dosfstools

Luego de instalar el paquede, montamos el pendrive, solo esta montado si aparece el nombre de la unidad en /media, luego escribimos:

$ df -h

Visualizamos la ruta de nuestro usb, ejemplo /dev/sdc1 que es el puerto donde está montado, luego desmontamos el pendrive.

$ umount /media/nombre_usb

Luego, estando desmontado la unidad usb, pero conectado al puerto

# mkfs.vfat -F 32 -n Nombre_usb /dev/sdc1

Esperamos y listo. Con la opción -F 32 le decimos que será formateada como Fat32, y con la opción -n le ponemos una etiqueta o nombre al dispositivo y
al final ponemos la ruta hasta nuestro dispositivo, la que vimos con df -h

#########################
##### sqlitebrowser #####
#########################

Herramienta de alta calidad visual para crear, diseñar y editar archivos de bases de datos compatibles con SQLite.
Es para usuarios y desarrolladores que desean crear bases de datos, buscar y editar datos.
Utiliza una interfaz de tipo hoja de cálculo familiar y no necesita aprender comandos SQL complicados.

# aptitude install sqlitebrowser

#################################################
##### Enlaces físicos y simbólicos en Linux #####
#################################################

##### Enlaces físicos #####

Un enlace físico no es más que una etiqueta o un nuevo nombre asociado a un archivo. Es una forma de identificar el mismo
contenido con diferentes nombres. Éste enlace no es una copia separada del archivo anterior sino un nombre diferente
para exactamente el mismo contenido.

$ ln archivo.txt nuevo_nombre.txt // Para crear un enlace físico en Linux del archivo archivo.txt a nuevo_nombre.txt

El enlace aparecerá como otro archivo más en el directorio y apuntará al mismo contenido de archivo.txt.
Cualquier cambio que se haga se reflejará de la misma manera tanto para archivo.txt como para nuevo_nombre.txt.

Un enlace se puede borrar usando el comando rm de la misma manera en que se borra un archivo, sin embargo el contenido del
iniodo no se eliminará mientras haya un enlace físico que le haga referencia. Esto puede tener varias ventajas, pero también
puede complicar la tarea de seguimiento de los archivos.

Un enlace físico tampoco puede usarse para hacer referencia a directorios o a archivos en otros equipos.

##### Enlaces simbólicos #####

Un enlace simbólico también puede definirse como una etiqueta o un nuevo nombre asociado a un archivo pero a diferencia de los enlaces físicos
el enlace simbólico no contiene los datos del archivo, simplemente apunta al registro del sistema de archivos donde se encuentran los datos.
Tiene mucha similitud a un acceso directo en guindows o un alias en OS X.

$ ln -s archivo.txt nuevo_nombre.txt // Para crear un enlace simbólico del archivo archivo.txt a nuevo_nombre.txt.

Éste enlace también aparecerá como otro archivo más en el directorio y apuntará al mismo contenido de archivo.txt, reflejando todos los cambios
que se hagan tanto para archivo.txt como para nuevo_nombre.txt.

Sobre un enlace simbólico también se pueden usar todos los comandos básicos de archivos (rm, mv, cp, etc). sin embargo cuando el archivo original
es borrado o movido a una ubicación diferente el enlace dejará de funcionar y se dice que el enlace está roto.

Un enlace simbólico permite enlazar directorios y, usando NFS, también permite enlazar archivos fuera del equipo.

########################
##### jaula chroot #####
########################

Con los programas chroot y debootstrap, es posible configurar un sistema Debian aislado en el cual poder entrar
y hacer pruebas, sin temor alguno a destruir su sistema principal.

Definimos un directorio en la raíz del sistema donde se ejecutará el sistema enjaulado, en este ejemplo lo mostrare para
debían Wheezy pero siguiendo la misma secuencia y sustituyendo adecuadamente se puede instalar cualquier versión de debían.

$ sudo mkdir /home/user/jaulas/wheezy

Instalamos la aplicación necesaria para ejecutar la jaula:

$ sudo apt-get install debootstrap

Creamos la jaula 

$ sudo debootstrap wheezy /home/user/jaulas/wheezy http://ftp.us.debian.org/debian/

o usamos un repo local o mas cercano para que las descarga de los ficheros sea mas rápida

$ sudo debootstrap wheezy /home/user/jaulas/wheezy http://debian.cenditel/debian/

Cuando termine, dependiendo de la velocidad de descarga, habrá creado todo el sistema básico para correr
debían wheezy en el directorio definido.

Antes de ejecutar la jaula se deben montar algunos directorios:

$ sudo mount -o bind /proc /home/user/jaulas/wheezy/proc 

Si senecesita conexión a periféricos como un módem usb o una impresora estos se guardan en el directorio /dev/
por ende tambien se debe montar.

$ sudo mount -o bind /dev/ /home/user/jaulas/wheezy/dev/ 

$ sudo mount -o bind /dev/pts/ /home/user/jaulas/wheezy/dev/pts/

$ sudo mount -o bind /sys/ /home/user/jaulas/wheezy/sys/ 

Para accecer a la jaula o ejecutarla debes ser usuario root o usar sudo

$ sudo chroot /home/user/jaulas/wheezy

o creamos un script para montar los directorios, creamos el script: montar.sh

---

#!/bin/bash
mount -o bind /proc /home/user/jaulas/wheezy/proc
mount -o bind /dev/ /home/user/jaulas/wheezy/dev/
mount -o bind /dev/pts/ /home/user/jaulas/wheezy/dev/pts/
mount -o bind /sys/ /home/user/jaulas/wheezy/sys/

---

y lo ejecutamos con:

# ./montar.sh

Para desmontar por alguna razón (borrar la jaula por ejemplo), creamos un desmontar.sh:

---

#!/bin/bash
umount /home/user/jaulas/wheezy/proc
umount /home/user/jaulas/wheezy/dev/
umount /home/user/jaulas/wheezy/dev/pts/
umount /home/user/jaulas/wheezy/sys/

---

# ./desmontar

A partir de este momento ya tienes el sistema listo y puedes hacer cualquier tipo de prueba sin que corra riesgo
tu sistema base para salir de la jaula y continuar con tu sistema solo debes ejecutar:

# exit

##### Nota #####
Este sistema solo puede ejecutar aplicaciones en el terminal si se requiere interfaz gráfica se debe utilizar una
aplicación como Xnest que su utilización te detallo a continuación:

$ sudo apt-get xnest

Ejecución:

En terminal 1 ejecutas 

$ Xnest -ac -geometry 800x600 :1 

en un segundo terminal inicias la jaula 

# sudo chroot /jaulas/wheezy 

y dentro de la jaula ejecutas 

# export DISPLAY=localhost:1 

En este momento toda aplicación que ejecutes en dicha jaula que posea interfaz gráfica se mostrara en la pantalla
mostrada por Xnest adicionalmente cabe destacar que puedes colocar cualquier geometria de ventana al ejecutar xnest 

- Cada ves que reinicies la pc debes volver a montar los directorios /proc, /dev/pts y /dev, esto lo puedes automatizar
agregando las siguientes siguientes lineas en el archivo /etc/fstab o corriendo un script con esas sentencias.

/proc		 /home/user/jaulas/wheezy/proc/	         auto	 bind 0	      0 
/dev		 /home/user/jaulas/wheezy/dev/pts/	 auto	 bind 0	      0 
/dev/pts	 /home/user/jaulas/wheezy/dev/pts/	 auto	 bind 0	      0
/sys             /home/aosorio/jaulas/wheezy/sys/        auto    bind 0       0

Descargamos los paquetes locales y locales-all y ejecutamos:

$ dpkg-reconfigure locales 

Escogemos las configuraciones regionales que desea generar:

es_VE.UTF-8 UTF-8

Configuración regional predeterminada para el entorno del sistema:
es_VE.UTF-8

Listo, jaula de wheezy lista!

##### Remover un entorno chroot #####

Desmontar los directorios montados y borrar el directorio de que alverga la jaulea (wheezzy)

################################
##### source.list example  #####
################################

**The format is
deb <respository server/mirror> <repository name> <sub branches of the repo>

-----

# Debian GNU/Linux 8 (Jessie) Estable

# Repositorio Oficial
deb http://http.us.debian.org/debian/ jessie main contrib non-free
deb-src http://http.us.debian.org/debian/ jessie main contrib non-free
deb http://httpredir.debian.org/debian/ jessie main
deb-src http://httpredir.debian.org/debian/ jessie main

# jessie-updates, previously known as 'volatile'
deb http://httpredir.debian.org/debian/ jessie-updates main
deb-src http://httpredir.debian.org/debian/ jessie-updates main

# Repositorio de Seguridad
deb http://security.debian.org/ jessie/updates main contrib non-free
deb-src http://security.debian.org/ jessie/updates main contrib non-free
deb http://security.debian.org/ jessie/updates main
deb-src http://security.debian.org/ jessie/updates main

#----------------------------------

#Debian GNU/Linux Testing & Unstable

# Testing repository - main, contrib and non-free branches
#deb http://http.us.debian.org/debian testing main non-free contrib
#deb-src http://http.us.debian.org/debian testing main non-free contrib

# Testing security updates repository
#deb http://security.debian.org/ testing/updates main contrib non-free
#deb-src http://security.debian.org/ testing/updates main contrib non-free

# Unstable repo main, contrib and non-free branches, no security updates here
#deb http://http.us.debian.org/debian unstable main non-free contrib
#deb-src http://http.us.debian.org/debian unstable main non-free contrib

#----------------------------------

#Debian GNU/Linux 7 (Wheezy) Estable

#Repositorio Oficial
deb http://ftp.us.debian.org/debian/ wheezy main contrib
deb-src http://ftp.us.debian.org/debian/ wheezy main contrib

#Actualizaciones de Seguridad
deb http://security.debian.org/ wheezy/updates main contrib
deb-src http://security.debian.org/ wheezy/updates main contrib

#Actualizaciones de Wheezy
deb http://ftp.debian.org/debian wheezy-updates main contrib non-free
deb-src http://ftp.debian.org/debian wheezy-updates main contrib non-free

#Backports
deb http://ftp.debian.org/debian/ wheezy-backports main

#----------------------------------

#Debian GNU/Linux 7 (Wheezy) Estable - CENDITEL

deb http://debian.cenditel/debian/ wheezy main
deb-src http://debian.cenditel/debian/ wheezy main

deb http://security.debian.org/ wheezy/updates main
deb-src http://security.debian.org/ wheezy/updates main

# wheezy-updates, previously known as 'volatile'
deb http://debian.cenditel/debian/ wheezy-updates main
deb-src http://debian.cenditel/debian/ wheezy-updates main

#----------------------------------

# Debian GNU/Linux 8 (Jessie) Estable - CENDITEL

deb http://debian.cenditel/debian/ jessie main
deb-src http://debian.cenditel/debian/ jessie main

# jessie-updates, previously known as 'volatile'
deb http://debian.cenditel/debian/ jessie-updates main
deb-src http://debian.cenditel/debian/ jessie-updates main

#deb http://tibisay.cenditel.gob.ve/repositorio jessie main

#----------------------------------

# Debian GNU/Linux 9 (Stretch) - CENDITEL

deb http://debian.cenditel/debian stretch main
deb-src http://debian.cenditel/debian stretch main

deb http://debian.cenditel/debian stretch-updates main
deb-src http://debian.cenditel/debian stretch-updates main

deb http://debian.cenditel/debian-security stretch/updates main
deb-src http://debian.cenditel/debian-security stretch/updates main

########################################################
##### Recommended installation packages for Debian #####
########################################################

Actualizar el source.list 

# apt-get update

Si da problemas con el fichero dir/dir/lock por ejemplo, lo borramos

# rm -f dir/dir/lock

No se pudo bloquear /var/lib/dpkg/lock - open (11: Recurso no disponible temporalmente)

Solución...

$ sudo fuser -vki  /var/lib/dpkg/lock

luego seguimos con...

##### Programas para el Sistema #####
terminator (Configurar, luego)
vim (Configurarlo)

.bashrc (Configurarlo, alias, etc...)
    alias ll='ls -l --color'
    alias buscar='grep --color -n -Ir'

sudo (Configurar y Probar)
aptitude (Probar)
ssh (Configurar y Probar)
git (Configurarlo, Probarlo)
vlc player

apache (Probar)
postgresql (Probar)
Virtual Box (Opcional)
Paquete para dar formatos a unidades usb
rsync
meld
audacity
tree // Muestra un árbol de directorios con sangría, en color.

#####  Para compilacion y construcción de paquetes #####
build-essential
gcc
dpkg-dev
fakeroot
cmake
devscripts
autoconf
automake
dh-make
debhelper
autotools-dev
gnupg
lintian
quilt

##### Desarrollo #####
curl
Sublime (Instalar el .deb de la página o buscar en los repos, > a v2.)
python (Probarlo)
python-pip
virtualenv
virtualenvwrapper
python-requests
django (Opcional)
ruby (Probarlo)
ruby on rails (Opcional)
Qt-Creator (Opcional)

##### Navegador Web #####
Firefox
Adblock --> https://addons.mozilla.org/es/firefox/addon/adblock-plus/
Private Tab --> https://addons.mozilla.org/es/firefox/addon/private-tab/
Firebug --> https://addons.mozilla.org/es/firefox/addon/firebug/
Youtube Video Downloader --> https://addons.mozilla.org/es/firefox/search/?q=youtube&appver=&platform=
Save as PDF --> https://addons.mozilla.org/es/firefox/addon/save-as-pdf/
Google Translator for Firefox --> http://translatorforfirefox.blogspot.com/
