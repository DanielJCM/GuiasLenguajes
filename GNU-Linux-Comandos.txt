##### Guía de comandos en GNU/Linux Debian by dM #####

Probados en: Debian GNU/Linux 7 (wheezy) y algunos en Debian GNU/Linux 8 (Jessie)

#########################################################
##### Comandos para mostrar información del sistema #####
#########################################################

Crtl + h // Mostrar archivos ocultos de un directorio, esto se hace desde el explorador de archivos nautilus de Gnome

$ cat /etc/issue.net  // Para saber la versión de SO que tenemos.

$ cat /etc/issue  // Para saber la versión de SO que tenemos.

$ cat /proc/cpuinfo // Para ver la información del cpu o procesador

$ lscpu // Para ver la información del cpu o procesador pero menor a la anterior

$ lsb_release -a // Comando que nos va a dar detalles de SO

$ uname // Muestra información del sistema

$ uname -a // Version de Kernel.

$ uname -a // Version de Kernel, mas corta.

$ uname -mrs // Saber mi version de Kernel especifica, recomendada

$ cat /etc/*-release // Ver info del sistema (Probado en Debian GNU/Linux 7 wheezy)

$ uptime // Indica cuánto tiempo ha estado funcionando el sistema, muestra:

15:11:08 up 1 day,  5:07,  9 users,  load average: 0,65, 0,83, 0,88

Los parámetros que muestra son:
-El tiempo actual que el sistema ha estado ejecutando
-El tiempo que lleva el sistema corriendo
-Los usuarios que están actualmente registrados
-Tiempo de carga del sistema durante los últimos 1, 5 y 15 minutos.

$ ls -l /etc/init.d/ // Saber cuantos demonios(daemons) del sistema están en ejecución. En esta ruta se encuentran algunos de los scripts que se ejecutan con el arrenque del SO.

$ date // Muestra la fecha

# date --set 1998-11-02 // Asignar la fecha manualmente

# date --set 21:08:00 // Asignar la hora manualmente

$ cal // Muestra un calendario

# fdisk -l // Ver informacion de los discos duros, particiones y dispositivos montados en el sistema.

$ lsusb // Este comando muestra todos los puertos USB y los detalles acerca de los dispositivos conectados a ellos.

$ lspci // Lista todos los componentes tipo pci (Peripheral Component Interconnec) como las tarjetas de red, de sonido o de televisión.

$ free // Muestra el estado de la memoria RAM, total, usado, disponible, cached, buffers.

$ free -m // Mostrar los datos en mb sin más.

$ free -h // Para ver los resultados en mb o gb con letra al final.

$ cat /proc/meminfo // Leer el fichero meminfo que contiene datos dinámicos de la memoria, similar a free.

$ vmstat // Muestra el estado de la memoria virtual

$ df // Muestra el espacio disponible del disco y demas dispositivos asi como el espacio usado

$ df -h // Muestra el espacio disponible del disco y demas dispositivos asi como el espacio usado, pero en mg o gb según sea el caso.

$ df -m // Muestra el espacio disponible del disco y demas dispositivos asi como el espacio usado, pero en mg.

$ pstree // Muestra los procesos del sistema en forma de arbol

############################################
##### Tips para la consola de comandos #####
############################################

!! // Repetir el ultimo comando ejecutado en consola

~ // Para sacarlo usar AvPag en la consola

comando && comando && comando... // Ejecucion multiple de comandos

Ctrl + u // Cortar el contenido de la linea de comandos desde la posicion del cursor hasta el principio

Ctrl + k // Cortar el contenido de la linea de comandos desde la posicion del cursor hasta el final

Ctrl + t // Intercambiar de posicion las letras que estan a cada lado del cursor

Ctrl + l // Limpiar el shell

Ctrl + d // En el shell, cerrar sesion, salir del root, de maquinas virtuales o de sesiones de usuarios iniciadas

Ctrl + flecha derecha o izquierda // Moverse en el prompt palabra a palabra, no letra por letra.

Ctrl + w // Borrar la palabra que esta antes del cursor en el shell

Control + s : Parar la salida por pantalla. Si por ejemplo ejecutamos un comando que
tiene una salida inmensa, podemos hacer que trabaje en silencio.

Control + q: Permitir la salida por pantalla, inverso al comando anterior.

Alt + d // Borrar palabra

###########################
##### Comandos varios #####
###########################

$ man nombre_comando // Muestra el manual de una comando donde como: ls, grep, aptitude etc...

Dentro de los manuales podemos presionar "h" para ver las opciones tenemos del manual, ejemplo "/delete"
para hacer una busqueda de la cadena "delete" dentro del manual.

$ clear // Limpiar la consola.

$ whatis nombre_programa // Si no desea ver la página de manual completa sino sólo una descripción corta para confirmar que es lo que está buscando, ingrese whatis programa.

Ejemplo:
$ whatis scp
scp (1)     - copia segura (programa de copia de ficheros remotos)

$ poweroff // Apagar la maquina, se debe ser root para ejecutarlo.

$ reboot // Reiniciar la maquina.

$ xrandr // Detectar las resoluciones de pantalla disponibles del sistema así como los hz correspondientes, la que
tenga (*) es la que está siendo usada.

$ ldd /xxx/python2.7 // Ver las dependencias de una librería o ejecutable, en este caso del ejecutable de python.

$ ldd /bin/bash

##############################################
##### Comandos para gestionar directorios ####
##############################################

$ pwd // (print work directory) Muestra la ruta en la que te encuentras.

$ mkdir nombre_carpeta // Crear una carpeta

$ mkdir -p carpeta1/carpeta2 // Crear una carpeta con otra carpeta dentro, encadenar la creación.

&& // El operador '&&' sirver para continuar con la ejecucion de comadnos en el shell, ejemplo:

$ mkdir carpetaFFF && cd carpetaFFF // Creamos una carpetaFFF y luego entramos en la carpeta creada
,&& nos permite poner varias instrucciones en una sola linea del shell, otro ejemplo:

$ mkdir carpetaZZZ && cd carpetaZZZ && touch archivo.txt // Creamos una carpeta, entramos en ella y creamos un archivo
en ese directorio en una sola instruccion.

$ touch Nombre_Fichero // Crear fichero

$ mkdir /tmp/`date +\%Y\%m\%d` // Crear una carpeta que lleve por nombre la fecha, ejemplo: 20170807

###############################################
##### Comandos para listar los directorios ####
###############################################

$ ls // Muestra lo que hay en la carpeta en la que te encuentras

$ ls -l // Muestra los archivos, fecha, permisos, etc

$ ls -lh // Muestra los archivos, fecha, permisos, y el peso pero en kb,mg o gb según sea el caso.

$ ls -la // Muestra los archivos, los ocultos tambien, fecha, permisos, etc

$ ls -1 // Muestra los archivos en forma de lista

$ ls | more // Lista el contenido de un directorio en orden alfabético, usa space para paginar si la lista es grande.

$ ls *.xxx // Listar todos los ficheros de un directorio que tengan las extension .xxx, donde xxx puede ser: txt, html, php, css, etc.
ejemplo: ls *.txt

$ ls -R // Listar los directorios y subdirectorios asi como ficehros de un directorio.

$ ls | cat -n // Muestra el contenido del directorio en una lista numerada.

$ du // ver la lista de carpetas y sub carpetas, los directorios que existen, lo primero que muestra es el tamaño.

$ du -h // Los mismo que arriba pero se ven los tamaños en kg, mg, etc

$ du -sh // Ver el tamaño total de los directorios.

$ du * // Muestra todos directorios y ficheros y el espacio que ocupan en el disco

$ file * // Nos dira el tipo de archivo de todos los ficheros del directorio

##################################################
##### Comandos para moverse entre directorios ####
##################################################

$ cd // Cambiar de directorio, nos lleva al home del usuario.

$ cd 'nombre carpeta' // Acceder a un directorio que tiene espacios en el nombre.

-- Si una carpeta se llama (a b c d e), para aceder a ella usamos:

$ cd a\ b\ c\ d\ e/ // Al final siempre lleva el / normal, los otros usan el invertido.

$ cd .. // retroceder un directorio

$ cd ../../ // Retroceder dos directorios (../) representa un directorio

#######################################################
##### Lectores/Editores de texto desde la consola #####
#######################################################

$ nano nombre_fichero // Modificar un fichero con el editor nano.

$ man nano // Leer el manual del editor de textos nano, muy útil, práctico y fácil de usar

$ cat nombre_fichero.xxx // Mostrar contenido de un fichero, concatenate files and print on the standard output.

$ cat -b nombre_fichero.xxx // Mostrar contenido de un fichero y numerar las líneas.

$ less nombre_fichero.xxx // Mostrar el contenido de un archivo, lector de ficheros, mayor movilidad que cat, con / permite buscar dentro
del fichero, como vim, q para salir.

$ tail nombre_fichero.xxx // El comando tail sirve para mostrar en pantalla las últimas líneas de un archivo.

$ tail -n X nombre_fichero.xxx // -n donde X es el número de lineas que queremos ver del fichero.

$ tail -c X nombre_fichero.xxx // -n donde X es el número caracteres desde el final, que queremos ver del fichero.

$ tail fichero_1.xxx fichero_2.xxx // Se pueden especificar 1 o más ficheros a la vez, los mostrara en el orden declarado.

$ stat nombre_fichero // Muestra el estado e información de un fichero

$ stat nombre_carpeta // Muestra información de un directorio

$ file xxx // donde xxx es el nombre de un fichero, nos dira el tipo de fichero que es.
Ejemplo: file index.html
index.html: HTML document, UTF-8 Unicode text

$ diff /home/user/file.html /home/user/file2.html // Permite hacer una comparacion de dos archivos para apreciar sus diferencias
se debe especificar la ruta de ambos archivos y separarlos con un espacio, si estan en el mismo directorio no hace
falta especificar las rutas completas.

$ rename 's/\.txt/\.xls/' *.txt  //Cambiar extension a todos los ficheros de un directorio
//En el ejemplo vamos a sustituir los .txt por .xls y le decimos que se lo haga a todos los .txt

###############################################
##### Comandos para monitorear el sistema #####
###############################################

$ top  // Listar los procesos de ejecución del sistema (y más cosas) en tiempo real, es una de las herramientas más importantes para un administrador.
-Si presionamos "z" nos mostrara la salida con 2 colores, para distingir mejor la información.
-"q" o "Ctrl+c" para salirse del monitor top.

# sysctl -w vm.drop_caches=3 // Liberar memoria RAM

$ fg %1 // Si un programa es pausado con Ctrol + z, con este comando lo reanudamos.

$ htop // Es otro monitor del sistema, parecido a top pero con un poco mas de herramientas, para instalarlo # apt-get install htop

$ nmon // Es otro monitor de sistema, para instalarlo # apt-get install nmon
Si quieren ver la información relacionada con el CPU presionan la tecla "c", con la memoria "m", del kernel "k" y discos "d".
Segun vayamos usando las letras nos va mostrando lo que escogimos, muy útil y bonito.

$ ping xxx // Donde xxx es el nombre de un host al cual enviaremos paquetes y comprobaremos si hay una conexion con ese host, util para saber si estamos conectados a internet por ejemplo:
ping http://www.google.com.ve // Si hay conexion a internet enviara paquetes que seran recibidos, de lo contrario dara un error.

$ ping -w n ip_num // Tiempo en segundos que se va a hacer ping donde n es un entero

// Siendo root, Ver si hay aceleracion grafica en la maquina, muestra unos engranajes
// de colores rodando, si es así, está correcta la instalacion del video.
# glxgears

##########################################
##### Gestionar procesos del sistema #####
##########################################

Cada proceso tiene un identificador (PID) proccess ID, entonces podemos matar ese proceso con:

$ kill xxxx // Matar un proceso donde xxxx es el identificador del proceso.

$ kill -9 xxxx // Matar un proceso donde xxxx es el identificador del proceso.

$ ps // Muestra los procesos actuales del sistema y acepta varios parametros como:

$ ps -e // Visualiza información sobre "todos" los procesos del sistema.

$ ps -ef // Visualiza información sobre "todos" los procesos del sistema con mas detalles, así pues se puede detener un proceso con kill -9 PID_number.

$ ps -ef | grep evince // Filtrar la búsqueda, en este caso, buscando el proceso que alberga el visor pdf evince.

$ ps -ef | grep ssh // Filtrar la búsqueda para ver las conexiones ssh activas, nuevamente se aclara que podemos matar esos procesos
con kill -9 xxx pasandole el PID process.

$ ps -p xxxx -o etime // Saber el tiempo que lleva ejecutandose un proceso.

$ ps aux // Muestra los procesos del sistema de sistema, similar a ps -ef.

$ ps aux | grep firefox // Mostrar información de proceso/s específico/s.

$ ps -l // Muestra algunos detalles de los procesos del sistema.

$ ps l //  Muestra mas detalles de los procesos del sistema.

#########################################
##### Usando los programas de gnome #####
#########################################

$ gnome-screenshot // Captura de pantalla del escritorio

$ gnome-shell --replace & disown // Recargar el entorno gráfico, evitando el reinicio del pc.

$ pdfimages fichero.pdf nombre_imagene // Extrae las imagenes de un .pdf

##########################################
##### Gestionar usuarios del sistema #####
##########################################

$ su nombre_de_usuario // Conectarse como otro usuario creado

$ adduser nombre_de_usuario // Como root, Agregar un usuario nuevo al sistema, una nueva sesion, nos pedira agregar el 
nombre de usuario y asignarle contraseña, la clave de root es la misma para todas las sesiones.

$ userdel -r nombre_usuario // Como root, eliminar el usuario creado

$ deluser --remove-home nombre_usuario // Otra forma de eliminar un usuario creado

#################################################
###### Comandos para escribir en un fichero #####
#################################################

$ echo "Texto al final del archivo" >> archivo.txt // Escribir una cadena de texto al final de un fichero.

$ sed -i '1i xxxxx' archivo.txt // Insertar una cadena de texto "xxxxx" al principio de un fichero.

$ sed -i '$a xxx' archivo.txt // Insertar una cadena al final del fichero, funciona como el método echo.

$ apt-get moo // Huevo de pascua, muestra una vaca.

########################################################
##### Comandos para copiar, mover, eliminar, otros #####
########################################################

$ cp // Copiar un fichero o carpeta

$ cp -r // Copiar un fichero o carpeta

$ cp Nombre_de_archivo.txt /Carpeta/destino/a/copiar // Copiar un fichero en un directorio
se debe estar situado en la carpeta del archivo a copiar

$ cp Nombre_carpeta -r /Carpeta/destino/a/copiar // Copiar un directorio en otro, 
se debe estar situado en la carpeta de la carpeta a copiar.

- Saber la ruta de un directorio //  Desde el explorador de archivar (nautilus) desde cualquier directorio
sin importar el nivel donde estemos, tecleamos Ctrl + l esto nos dirá la ruta completa hasta el directorio.

$ cp -r /home/usuario/carpeta1/ /home/usuario/carpeta2/ //Se pueden copiar archivos o carpetas especificando las
rutas completas, en este caso la primera ruta es el directorio o archivo a copiar y la segunda es la ruta donde
se va a pegar lo copiado, ambas rutas separadas por un espacio en blanco.

$ cp -r carpeta/ carpeta2/ // Ambas carpetas estan en el mismo directorio donde estamos situados, por lo tanto
no hay que especificar las rutas completas de las carpetas involucradas

$ cp nombre_fichero.xxx nombre_fichero2.xxx // Hacer una copia de un fichero y cambiarle el nombre.

$ cp -r carpeta1 carpeta2 // Hacer una copia de un directorio y cambiarle el nombre.

$ mv // Mover un fichero o carpeta y/o cambiar su nombre

$ mv /home/carpeta/archivo1.txt /home/carpeta2/ // Mover una carpeta o archivo especificando el directorio
de salida y el de llegada, si estan en el mismo directorio no hace falta poner las rutas completas.

$ mv archivo1.txt archivo2.txt // Renombrar un archivo o carpeta 

$ rmdir // Borrar una carpeta

$ rm nombre_fichero // Borrar un fichero

$ rm fichero1 fichero2 fichero3 // Borrar varios ficheros

$ rm -r /directorio // Para borrar una carpeta, se le da la ruta del directorio a borrar

$ rm * // Borrar todos el contenido de una carpeta, se debe estar dentro del directorio

rm -r * // Borrar todo el contenido de una carpeta, incluyendo las carpetas de ese directorio
se debe estar dentro del directorio

$ sudo rm -rf /xxx/xxxx // rm: Comando "remove", eliminar. -rf: r de "recursivo" donde se borra todo y f de "force";
nunca solicita confirmación. /xxx/xxx indica la ruta de los ficehros o carpetas a borrar.

$ rm -r !("try") // Borrar todos los elementos de un directorio exeptuando lo que está entre "", donde try es un directorio pero
también puede ser un fichero, "x.txt" por ejemplo.

$ sudo -i // Pedir contraseña root, algunas versiones basadas en Debian

$ su // Pedir contraseña del root

root@debian:/home/user# Ctrl + d //Para salir del root, tambien exit, funciona en algunas consolas como python, ruby, entre otras.

Ctrl + r // En la consola, para hacer una busqueda de comandos usados baasndose en la palabra que se introduzca

Shift + Page up <--> Page down // Moverse a traves de los logs de la consola, simula el scroll up/down del mouse

###################################
##### Ip pública e Ip privada #####
###################################

##### Ip Pública #####

Es la que tiene asignada cualquier equipo o dispositivo conectado de forma directa a Internet.

Algunos ejemplos son: los servidores que alojan sitios web como Google, los router o modems que dan a acceso a Internet, otros
elementos de hardware que forman parte de su infraestructura, etc.

Las Ip públicas son siempre únicas. No se pueden repetir. Dos equipos con IP de ese tipo pueden conectarse directamente entre sí.
Por ejemplo, tu router con un servidor web. O dos servidores web entre sí.

##### Ip Privada #####

Se utiliza para identificar equipos o dispositivos dentro de una red doméstica o privada.
En general, en redes que no sean la propia Internet y utilicen su mismo protocolo (el mismo "idioma" de comunicación).

Las Ip privadas están en cierto modo aisladas de las públicas. Se reservan para ellas determinados rangos de direcciones. Son estos:

Estas Ip deben ser únicas dentro de una misma red. Cada equipo o dispositivo ha de tener la suya, distinta de la de los demás.
De lo contrario habría problemas. Sería como si dos vecinos tuvieran el mismo nombre y la misma dirección física.
El cartero nunca sabría a quién corresponde la carta que les envíen.

Las Ip privadas sí pueden repetirse en redes distintas (como en la tuya y la de una empresa).
Los equipos o dispositivos con esas IP pueden conectarse entre sí SÓLO dentro de la red a que pertenecen.
No hay conflictos porque las redes están separadas. Igual que no los hay entre dos direcciones físicas iguales de ciudades distintas.

#### Saber la ip pública #####

Una forma de averigar esa ip pública es haciendo uso del comando curl. Si no tenéis instalado el paquete habrá que instalarlo,

$ sudo apt-get install curl

$ curl ifconfig.me // Nos mostrará nuestra ip pública.

$ user@debian:/media$ umount nombre_device // Desmontar un dispositivo, pendrive, disco externo etc.

$ who // Muestra usuarios conectados a nuestra máquina, tambien usado para ver las conexiones entrantes de un servidor

Ejemplo:
user tty7         2015-07-28 08:47 (:0)
user pts/0        2015-07-30 14:03 (:0.0)
user pts/1        2015-07-30 17:03 (:0.0)
user pts/2        2015-07-31 14:15 (:0.0)
user pts/3        2015-07-31 12:37 (:0.0)

// En este caso son los usuarios conectados a mi máquina, eso quiere decir que tengo shells
abiertos, por lo tanto todos son representados como usuarios, entre los diversos parametros
se puede apreciar la fecha y la hora en que se abrio el shell, en un servidor seria
el momento en que se conecto el usuario

$ whoami // Muestra que usuario soy, nombre de usuario

$ who am i // Nos dira cual usuario somos, si navegamos por los shells abiertos y ejecutamos el comando nos dira cual usuario es

$ who -u // Ver usuarios conectados

// Ejemplo:

user tty7         2015-07-28 08:47  antig       4257 (:0)
user pts/0        2015-07-30 14:03 03:22        8351 (:0.0)
user pts/1        2015-07-30 17:03 03:19        8351 (:0.0)
user pts/2        2015-07-31 14:15 00:08        8351 (:0.0)
user pts/3        2015-07-31 12:37 02:53        8351 (:192.168.0.240)

// Aqui observamos que hay una conexion externa a traves de ssh a nuestro servidor proveniente de la maquina
(192.168.0.240) demarcada por el id process 8351 la cual podemos cancelar con $ kill -9 8351, pero no refusar esa conexion, el usuario seguirá conectado por ssh.

$ pkill -9 -t pts/3 // Acabar con una conexión externa, se envió la señal -9 que indica matar (KILL) el proceso, la opción -t indica que se basará
en un atributo de nombre de terminal y se indica después el nombre de la terminal en si pts/3. Este es el comando que sí funciona para 
refusar o eliminar conexiones externas. A veces pide su.

$ last // listar los ultimos usuarios conectados

################
##### Less #####
################

// less es un visualizador de archivos de texto que funciona en intérpretes de comando.
// A diferencia de otros programas similares (como more), less permite una completa navegación
// por el contenido del archivo, utilizando un mínino de recursos del sistema.

***** Comandos basicos *****

man less // Manual de less

AvPag // Avanzar una página

RePag // Retroceder una página

space // Tecla espacio para avanzar, como page up

:q // Salir

:h // Ayuda

:/palabra // (/) Buscamos una palabra dentro del documento
// (n) para ir a la siguiente coincidencia.
// (N) para ir a la coincidencia anterior

:G // Ir al final del texto

:g // Ir al inicio del texto

:v //Invocar un editor de texto para el documento, por lo general usa vi pero puede usar nano automaticamente

$ less +123 filename // Para ir a una línea específica de un fichero.

########################################################
########## Cambiar el pass del usuario y root ##########
########################################################

##### Usuario normal #####

$ passwd

// Nos mostrara lo siguiente:

Cambiando la contraseña de user.
(actual) contraseña de UNIX:******
Introduzca la nueva contraseña de UNIX:*****
Vuelva a escribir la nueva contraseña de UNIX:*****

##### Usuario root #####

Primero nos logeamos como root:

$ su

Luego lo mismo de arriba:

# passwd

// Nos pedira que introduzcamos la nueva contraseña y la confirmacion para cambiar la clave de root

Introduzca la nueva contraseña de UNIX:****** 
Vuelva a escribir la nueva contraseña de UNIX:***** 
passwd: contraseña actualizada correctamente

#########################################################
########## Instalacion de programas y paquetes ##########
#########################################################

$ man aptitude // Ver el manual de aptitude.

$ man apt-get

# apt-get install Nombre_Paquete // Instalar paquetes

# apt-get install -t jessie-backports Nombre_Paquete // Instalar paquetes disponibles desde otro repositorio, en este caso, los de jessie-backports.

# aptitude install Nombre_Paquete // Instalar paquetes, otra forma

# apt-get build-dep Nombre_Paquete // Intentará satisfacer las dependencias de compilación de un paquete fuente, el comando build-dep
busca en los repositorios locales en el sistema e instala las dependencias de construcción para el paquete. Si el paquete no existe en
el repositorio local se devolverá un código de error.

$ aptitude install -s Nombre_Paquete // Hace una simulacion de la instalacion, podemos ver que procesos haría la instalación

# apt-get install -y package // El -y Supone una respuesta afirmativa a todas las preguntas, de esta forma apt-get se ejecuta sin necesidad de intervención posterior para tomar decisiones, usar con cuidado.

# apt-get install -s Nombre_Paquete // Simulacion de instalacion con  apt-get install

$ apt-get source Nombre_paquete // Descargar las fuentes del paquete, para compilar e instalar. 

$ sudo aptitude search Nombre_Paquete // Realizar una busqueda en los repositorios del paquete que se quiere encontrar

$ aptitude show Nombre_Paguete // Para ver la informacion del paquete, version, estado, tamaño, conflictos, dependencias, etc.

$ apt-cache show nombre_paquete // Ver informacion del paquete, version, dependencias, descripcion, tamaño, entre otros.

$ apt-cache search nombre_paquete // Buscar un paquete en los repositorios.

$ aptitude versions nombre_paquete // Muestra las versiones de los paquetes listados en la línea de órdenes.

# aptitude remove Nombre_paquete // Elimina o Desinstala el paquete.

# aptitude purge Nombre_Paquete // Elimina el paquete y sus archivos de configuracion.

$ aptitude download nombre_paquete // Descarga el fichero .deb del paquete dado al directorio actual.

$ apt-get download nombre_paquete // Descarga el fichero .deb del paquete dado al directorio actual.

# aptitude reinstall nombre_paquete // Reinstalar un paquete

$ aptitude update // Actualizar la lista de paquetes disponibles.

$ dpkg -l | grep nombre_paquete // Saber si un paquete está instalado y su version.

# apt-get autoremove // Borra los paquetes huérfanos, o las dependencias que quedan instaladas después de haber instalado una aplicación y luego eliminarla, por lo que ya no son necesarias.

##### Comparación de las ordenes en apt-get y aptitude #####

### Acción ###
Instalar cualquiercosa
Buscar cualquiercosa
Eliminar cualquiercosa
Lista recursiva de dependencias de cualquiercosa
Mostrar el estado de cualquiercosa
apt-cache policy cualquiercosa
Descargar código fuente de cualquiercosa y crear un paquete .deb

### apt-get ###
apt-get install cualquiercosa
apt-cache search cualquiercosa
apt-get remove cualquiercosa
apt-cache rdepends cualquiercosa
apt-get source --compile cualquiercosa

### aptitude ###
aptitude install cualquiercosa
aptitude search cualquiercosa
aptitude remove cualquiercosa
aptitude search ~Dcualquiercosa
aptitude versions cualquiercosa

####################################################
##### Saber la version instalada de un paquete #####
####################################################

xxx --version // Saber la version de algun paquete que tengamos instalado.

Ejemplo:
bash --version
gcc --version
python --version
ruby --version

#####################################
##### Liberando espacio con apt #####
#####################################

APT (Advanced Packaging Tool) Herramienta Avanzada de Empaquetado es un sistema gestor de paquetes creado por el proyecto Debian.
Esta herramienta se encarga de facilitarle al usuario las tareas de instalación y eliminación de programas en los
sistemas GNU/Linux (distribuciones derivadas de Debian).

Esta herramienta se compone de dos programas principalmente: apt-get y apt-cache, para estos programas podemos encontrar programas
frontend, me refiero a programas con una interfaz gráfica que facilita el uso de apt como es Aptitude, Synaptic, Adept, Ubuntu Software Center, etc.

Apt instala paquetes .deb para los sistemas debian y distribuciones derivadas, instalar un programa con esta herramienta es tan sencillo como escribir:

$ apt-get install <nombre_del_programa>

Donde <nombre_del_programa> lo sustituimos por el nombre del programa que deseamos instalar.

Si queremos por ejemplo instalar GIMP, un programa para la manipulación de imágenes, se haría de la siguiente manera:

$ apt-get install gimp

##### Comprobando el espacio utilizado #####

Los archivos .deb que apt-get descarga de los repositorios, son almacenados en nuestra máquina antes de comenzar el proceso
de instalación, y a veces hace falta hacer limpieza de estos archivos (ojo, al realizar los siguientes 3 pasos para liberar
espacio, liberaremos espacio sin desinstalar programas, solo borraremos los instaladores, caché de .deb almacenados localmente);
Los archivos son almacenados en la siguiente ruta cuando van a ser instalados /var/cache/apt/archives podemos ver cuánto espacio
están utilizando estos archivos en nuestro disco con:

$ du -hs /var/cache/apt/archives

du es un comando que nos permite ver el Disk Usage (espacio utilizado en disco).
3 Pasos para liberar espacio

$ sudo apt-get autoclean
$ sudo apt-get clean
$ sudo apt-get autoremove

##### Explicación de los 3 comandos anteriores #####

1- Para liberar el espacio primero haremos un autoclean, esta opción borra todo el caché de los paquetes .deb de paquetes de versiones anteriores y de los programas que ya han sido instalados en nuestro sistema:

$ sudo apt-get autoclean

2- El siguiente comando con la opción clean borra todos los paquetes .deb, si queremos instalar de nuevo un programa el archivo .deb necesitará ser descargado nuevamente de los repos:

$ sudo apt-get clean

3- Por último el siguiente comando con la opción autoremove borra todos los paquetes dependencias de otros programas:

$ sudo apt-get autoremove

Comprobando el espacio libre nuevamente

Ahora que hemos liberado el espacio, podemos comprobar nuevamente el tamaño de la carpeta que apt usa para almacenar todos los archivos como caché:

$ du -hs /var/cache/apt/archives

#####################################################
########## Comprimir/Descomprimir archivos ##########
#####################################################

tar se refiere a un formato de archivos ampliamente usado en
entornos UNIX identificados por el sufijo de archivo .tar.. Además hace referencia al programa
para la manipulación de archivos que es estándar en estos entornos, pero no incluye la
compresión de los mismos.

// Comprimir un directorio, le damos los parametros de compresion, así como el nombre del paquete
y el directorio que vamos a comprimir.

$ tar -cvf paquete.tar nombre_directorio 

-c : indica a tar que cree un archivo
-x : extraer un archivo
-t : listar los contenidos de un archivo
-v : indica a tar que muestre lo que va empaquetando.
-f : indica a tar que el siguiente argumento es el nombre del fichero.tar
-z : comprimir a la vez que se empaqueta

// Crear un paquete con el nombre que le dimos y contiene el archivo.txt 

$ tar -cvf paquete.tar archivo.txt

// Descomprimir un paquete

$ tar -xvf paquete.tar

##### Descomprimir paquetes.tar.bz2 #####

$ tar -xjvf example.tar.bz2

##### Ficheros: .tar.gz #####

// Comprimir un directorio

$ tar -czvf paquete.tar.gz nombre_directorio

// Comprimir un fichero

$ tar -czvf paquete.tar.gz nombre_fichero.xxx

// Descomprimir

$ tar -xzvf paquete.tar.gz

##### Ficheros: .gz: #####

// Comprimir

$ gzip -9 ficehro.txt

// Descomprimir

$ gzip -d fichero.gz

##### Descomprimir .tar.xz #####

$ tar Jxvf fichero.tar.xz

-------------

Cuando nos iniciamos en Linux y buscamos un programa lo normal es que encontremos un .deb o .rpm y en muchos casos nos encontramos programas con
la extensión .tar.gz y .tar.bz2, estos archivos están comprimidos y por lo general contienen aparte del programa unas instrucciones para instalarlo.

La instalación para estos dos tipos de paquetes es exactamente igual, primero entramos a la carpeta donde tengamos el archivo.

$ cd directorio

$ tar -zxvf nombredelarchivo.tar.gz

$ tar -jxvf nombredelarchivo.tar.bz2

-Configuramos, con esta accion se configurara el paquete
para la posterior compilacion, si hacen falta paquetes "dependencias" para la compilacion
por lo general mostrara que paquetes faltan y fallará la configuracion.

$ ./configure

-Hacemos make (compilamos)

$ make

-Ahora make install

$ make install

################################
##### Descomprimir con RAR #####
################################

// Necesitamos instalar unrar

$ aptitude search unrar

Si no lo encuentra debemos bajar el source de http://www.unrarlib.org/
Nos bajara unrarsrc-3.7.8.tar.gz // Descomprimimos, nos dejara la carpeta (unrar)
luego: 
$ cd unrar
$ make -f makefile.unix
$ install -v -m755 unrar /usr/bin // Como root

// Ya deberíamos poder descomprimir .rar

Uso: unrar [OPTION...] ARCHIVE [FILE...] [DESTINATION]
-x, --extract              Extract files from archive (default)
-t, --list                 List files in archive
-f, --force                Overwrite files when extracting
--extract-newer        Only extract newer files from the archive
--extract-no-paths     Don't create directories while extracting
-p, --password             Decrypt archive using a password
-?, --help                 Give this help list
--usage                Give a short usage message
-V, --version              Print program version

ejemplo:
$ unrar x archivo.rar // Para descomprimir un fichero .rar
$ unrar x archivo.rar /home/user/carpeta // Para descomprimir un fichero .rar dando la ruta

###########################################
##### Comprimir/ Descomprimir con ZIP #####
###########################################

$ sudo aptitude install zip // Instalar el paquete de zip

$ zip archivo.zip nombre_fichero.xxx

$ unzip archivo.zip // Descomprimir el fichero

$ zip -r carpeta.zip nombre_carpeta // Comprimir directorios y su contenido

#####################
##### Programas #####
#####################

#########################################
########## Terminal Terminator ##########
#########################################

//Gran herramienta para los desarrolladores, permite abrir multiples terminales
y poder ordenarlos, muy personalizable, entre muchas otras cosas. **RECOMENDADO**

Paquete: terminator / multiple GNOME terminals in one window

aptitude install terminator // Para instalarlo
apt-get install terminator

Dentro de Terminator:
Ctrl + Shift + o // Abrir un terminal horizontal y paralelo
Ctrl + Shift + e // Abrir un terminal vertical y paralelo
Ctrl + Shift + t // Abrir una nueva pestaña en el terminal
Alt + flechas // Moverse por los terminales
Ctrl + Shift + w // Cerrar un terminal
Ctrl + Shift + x // Maximizar un terminal, igual para salir
Ctrl + Shift + z // Maximizar un terminal(aumentado), igual para salir
Ctrl + Shift + flechas // Cambiar el tamaño a voluntad de un terminal
Ctrl + (+) // Aumentar tamaño de fuente, el (+) del Qwerty
Ctrl + (-) // Minimizar tamaño de fuente, el (-) del Qwerty 
Ctrl + d // Si no hay sesion de usuario abierta, como root y otros cerrará la pestaña o ventana.
f11 // Pantalla completa.

#################################
### DIA - Editor de diagramas ###
#################################

Es un editor de diagramas, grafos, gráficas, etc. Ofrece soporte para diagramas de estructuras
estáticas en UML (diagramas de clases), diagramas de  Entidad-Relación, diagramas de redes y mucho más.
Los diagramas se pueden exportar a postscript y a otros formatos.

$ aptitude install dia

################
##### Meld #####
################

Es una herramienta gráfica para hacer archivos diff y fusionarlos.
Permite al usuario ver los cambios entre, y fusionar, dos archivos, dos directorios, o dos archivos con un ancestro común.

$ aptitude install meld

####################################
##### Editor de texto VI o VIM #####
####################################

// Es un editor de texto poderoso, muy usado en la comunidad de desarrolladores de Software Libre para escribir scripts, modificar ficheros
de texto en el shell, programar etc. No posee botones y todas sus funcionalidades se usan a traves de comandos.
Por lo general viene preinstalado en la mayoria de distribuciones, si no es así solo basta con un:

# apt-get install vim // con apt-get

# aptitude install vim // con aptitude

----------------

--- Modos de uso ---

// Al entrar a VIM para editar un fichero por primera vez, estamos en modo de comandos, quiere decir que no podemos editar el texto
sino que solo podremos usar comandos.

vim // Abrir vim, un fichero en blanco sin nombre ni contenido

i // Tecleamos i para entrar en modo de edicion, podemos insertar texto

escape // Pulsamos la tecla escape para salir del modo edicion o de cualquier otro modo, y volvemos al modo comandos.

:q // En modo comandos escribimos :q para salir del editor sin guardar

:q! // Salir del editor sin guardar ni pedir confirmacion

:w nombre_fichero.xxx //Guardamos un fichero nuevo, le asignamos el nombre y la extension si es necesario.

vim nombre_archivo.xxx // Nos aparecerá una ventana en negro, donde nos aparecerá el contenido del fichero o en negro si está vacío
// En la parte inferior, nos aparecerán los mensajes o comandos que escribamos para manejar el editor, así como la línea en la que estamos, porcentaje del fichero, etc.

:w // Guardar un documento

:wq! // Guardar y salir, esta accion aplica a un fichero ya creado, que estemos editando.

:f // Para saber el nombre y extensión del fichero abierto.

u // Deshacer el ultimo cambio

Ctrl + R // Rehacer el ultimo cambio

yy // Copiar la linea

dd // Eliminar una linea, en tal caso la corta y esta lista para pegarse

p // Pegar una linea cortada

guu // Convertir la linea actual en minusculas

gUU // Convertir la linea actual en mayusculas

g // Ir al principio del archivo

G // Ir al final del documento

w // navegar palabra por palabra en el fichero

v // Entra en modo Visual. En este modo seleccionaremos un texto con los cursores, y
después podremos cortar, copiar y pegar con los comandos:  
Copiar: y
Copiar el texto seleccionado en modo visual (de "yank".)
Cortar: c
Cortar el texto seleccionado en modo visual 
Pegar: p
Pegar el texto copiado o cortar en modo visual con anterioridad. 

:/palabra // Para hacer una busqueda de una palabra dentro del archivo
n // Para ir a la siguiente coincidencia.
N // Para ir a la coincidencia anterior

:set nu // Enumerar las líneas del fichéro.

Si queremos que se enumeren siempre las lineas editamos el fichero:

# vim /etc/vim/vimrc

y quitámos las comillas (") a la línea que tiene a set number y guardamos.

:123 // Ir a la linea (x) donde 123 es el número de linea a la cual queremos ir.

:syntax on // Sirve para dar color al codigo que estemos editando, VIM reconoce la sintaxis de muchos lenguajes y
la resalta en colores como muchos otros editores graficos como gedit, sublime, ninja, komodo, Geany.

En /etc/vim en el fichero vimrc descomentamos la linea 
"syntax on // Quitamos las (") para que quede activado directamente la coloracion de codigos

########################################
########## Apache HTTP Server ##########
########################################

Servidor HTTP Apache es un servidor web HTTP de código abierto, para plataformas
Unix (BSD, GNU/Linux, etc.), Microsoft Guindows, Macintosh y otras, que implementa
el protocolo HTTP/1.1

##### Instalación #####

# apt-get install apache2

Para comprobar la correcta instalación de apache abriremos el navegador web de la máquina
y escribiremos localhost, 127.0.0.1 o la IP de la máquina si está conectado a una red local.
Cualquiera de las tres opciones nos sirve, y tecleamos enter, si está bien instalado nos
aparecerá una página que indica que apache está funcionando, a su vez, esa instalación creara
la siguiente ruta en la máquina:

/var/www/

ó

/var/www/html

Dependiendo de la versión de Apache que se haya instalado será uno u otro.

En este directorio es donde podemos guardar nuestros proyectos, ficheros, etc.
Que queremos que sean servidos por Apache en la web.

http://192.xxx.xx.xxx/ // La direccion ip sirve para acceder al directorio del servidor

127.0.0.1:80 // Apache cuando está en ejecucion siempre está escuchando por el puerto 80
por lo que si visitamos 127.0.0.1:80 accederemos al servicio

Sus archivos e configuracion están en etc/apache2

Estructura del directorio /etc/apache2:

├── apache2.conf
├── conf-available
│   ├── charset.conf
│   ├── localized-error-pages.conf
│   ├── other-vhosts-access-log.conf
│   ├── security.conf
│   └── serve-cgi-bin.conf
├── conf-enabled
│   ├── charset.conf -> ../conf-available/charset.conf
│   ├── localized-error-pages.conf -> ../conf-available/localized-error-pages.conf
│   ├── other-vhosts-access-log.conf -> ../conf-available/other-vhosts-access-log.conf
│   ├── security.conf -> ../conf-available/security.conf
│   └── serve-cgi-bin.conf -> ../conf-available/serve-cgi-bin.conf
├── envvars
├── magic
├── mods-available
├── mods-enabled
├── ports.conf
├── sites-available
│   ├── 000-default.conf
│   └── default-ssl.conf
└── sites-enabled
    └── 000-default.conf -> ../sites-available/000-default.conf

Breve repaso por algunos de sus ficheros:

apache2.conf

Este es el archivo de configuración principal del servidor. Desde aquí se pueden configurar
la mayoría de las opciones con las que cuenta apache para el servicio. Lee y ordena el resto
de los archivos de configuración cuando arranca el servidor. El propio archivo "apache2.conf"
contiene instrucciones y explicación de cada archivo y directorio del servidor.

ports.conf

Este archivo especifica los puertos de escucha de los hosts virtuales. Se agrega al archivo de
configuración "apache2.conf". Se agregan tantos "Listen numpuerto" como puertos queramos que
escuche nuestro servidor.

mods-enabled

Contiene configuraciones de módulos opcionales del servidor (seguridad, speedy, ssl, multiproceso)
y los módulos en sí mismos.

conf-enabled

Fragmentos de configuración global. Almacena archivos ".conf" que contienen parte de la configuración
de apache. Contiene enlaces simbólicos a los ficheros de conf-available.

sites-availables

Es donde definiremos los host virtuales del servidor Apache, es donde configuramos
los accesos, puertos, y otras cosas relativas nuestros proyectos, que queremos que sean servidos
en la web por apache.

sites-enabled

En el hay enlaces simbólicos a los ficheros de configuracion que están en sites-availables.

##### Comandos para gestionar apache #####

$ chmod -R 777 /var/www/html // Cambiar los permisos de /var/www puesto que solo tiene permisos root, 
-R para que los permisos se hagan de forma recursiva, esto se hace porque al pegar ficheros
o carpetas estas no tiene los permisos de lectura/escritura necesarios.

$ sudo service apache2 restart // Restart apache para guardar los cambios.

$ sudo service apache2 stop // Detener el servicio de apache.

$ sudo service apache2 status // Ver el estado del servicio

$ sudo service apache2 reload // Para recargar la configuración del servicio de Apache.

$ sudo service apache2 force-reload // Forzar la recargar de configuración del servicio.

##### log de accesos ######

$ sudo tail -f /var/log/apache2/access.log // Para ver el log de acceso via Web al servidor Web Apache.

Ejemplo de una petición, vista en el log:

ip visitante || fecha y hora || Método de acceso || url visitada || codigo http || codigo de estado || ip + url visitada || navegador usando, SO usado, arquitectura usada en la petición

192.168.200.201 - - [31/Aug/2017:14:59:44 -0400] "GET /files/2017/ HTTP/1.1" 200 1287 "http://192.168.200.201/files/" "Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:55.0) Gecko/20100101 Firefox/55.0"

##### log de errores #####

$ sudo tail -f /var/log/apache2/error.log // Para depurar posibles errores del servidor.

##### Borrar apache #####

# apt-get --purge remove apache2*

# rm -fr /etc/apache2

##### Ejemplo de configuración para un sitio de pruebas #####

Creamos un fichero prueba.conf en /etc/apache2/sites/availables con el siguiente contenido:

# touch prueba.conf

<VirtualHost *:80>
  ServerAdmin admin@mail.com
  ServerName myserver.com
  DocumentRoot /var/www/html/prueba/
  DirectoryIndex index.html
</VirtualHost>

---

ServerAdmin // Es una opción obligatoria e indica una dirección de correo electrónico
del responsable del sitio.

ServerName // Aquí anotamos el FQDN vinculado al sitio, es decir, el nombre de dominio que luego configuraremos en el servidor BIND9

DocumentRoot // Apunta al directorio donde tenemos nuestro proyecto.

DirectoryIndex // Indica el archivo de inicio definido por defecto.

Ahora crearemos un enlace simbólico de esta configuración a sites-enabled

# ln -s /etc/apache2/sites-available/prueba.conf /etc/apache2/sites-enabled/

Reiniciamos apache:

service apache2 reload

Una vez echo esto deberíamos poder visualizar nuestro proyecto en:

127.0.0.1/prueba

#################
##### Nginx #####
#################

Nginx (pronunciado en inglés "engine X") es un servidor web/proxy inverso ligero de alto rendimiento y un proxy
para protocolos de correo electrónico (IMAP/POP3).

##### Ventajas de usar Nginx #####

Se trata de un software multiplataforma, por lo tanto podremos instalarlo en la mayoría de nuestros servidores.

Consume menos recursos que la mayoría de servicios que hacen su misma función.

Nos proporciona un alto rendimiento soportando mayor carga y respondiendo mejor que sus competidores.

Puede ser usado como proxy inverso cacheando el contenido de nuestros sitios web.

Podemos integrarlo junto con Apache, de forma que Nginx procese contenido estático y Apache contenido dinámico.

Puede usarse como balanceador de carga entre varios servidores, permitiéndonos así una mayor facilidad a la hora de escalar nuestros servidores.

Es compatible con una gran variedad de CMS y aplicaciones actuales como pueden ser: Wordpress, Drupal, Prestashop, y muchas más.

El proyecto Nginx tiene detrás a la empresa Nginx Inc. y también cuenta con el apoyo de una gran comunidad contribuyendo a mejorar y resolver dudas. También podemos recurrir a soporte profesional.

##### Inconvenientes de usar Nginx #####

No se integra con PHP de forma nativa. Es necesario usar FastCGI para poder integrarlo.

##### Instalación #####

No debe estar instalado Apache porque puede dar problemas, como por ejemplo
que ambos servidores usan algunos puertos por defecto, lo que conlleva a colisiones.

# apt-get install nginx

Si visitamos 127.0.0.1 ó la ip de la máquina asignada por red veremos
la plantilla por defecto de Nginx, que significa que está corriendo
el servicio. Esta plantilla esta en /var/www/index.html

$ sudo systemctl stop nginx // To stop your web server

$ sudo systemctl start nginx // To start the web server when it is stopped, type.
# service nginx start // En versiones anteriores de nginx.

$ sudo systemctl restart nginx // To stop and then start the service again
# service nginx reload // En versiones anteriores de nginx.

$ sudo systemctl reload nginx // If you are simply making configuration changes, Nginx can often reload without dropping connections.

##### Archivos de configuración de Nginx #####

Los archivos de configuración de Nginx se encuentran en /etc/nginx/
.
├── conf.d
├── fastcgi.conf
├── fastcgi_params
├── koi-utf
├── koi-win
├── mime.types
├── naxsi_core.rules
├── naxsi.rules
├── naxsi-ui.conf.1.4.1
├── nginx.conf
├── proxy_params
├── scgi_params
├── sites-available
│   ├── default
├── sites-enabled
│   ├── default -> ../sites-available/default
├── uwsgi_params
└── win-utf

Donde el archivo de configuración principal es nginx.conf y los directorios principales de configuración son sites-available y sites-enabled.

El archivo de configuración principal es donde configuraríamos las opciones del servidor web Nginx que afectan a todos los hosts
virtuales que tengamos configurados (todas las página web alojadas).

En el directorio sites-available crearíamos los archivos de configuración específicos de cada host virtual.

En el directorio sites-enabled crearíamos enlaces simbólicos a los archivos de configuración que hayamos creado
en sites-available, para que Nginx tenga en cuenta esa configuración (activarla).

Se puede observar que por defecto tenemos creado el archivo de configuración "default" que está habilitado y por eso tiene un enlace
simbólico en "sites-enabled".

Para ver la configuración de nginx del sitio disponible:
--> /etc/nginx/sites-enabled/nombre_del_sitio

Si se quiere comprobar la sintaxis de los archivos de configuración luego de realizar algun cambio,
o si es la primera vez que se configura, usaremos el siguiente comando:

$ nginx -t

Si todo está bien, la salida sería algo como esto:

nginx: the configuration file /etc/nginx/nginx.conf syntax is ok
nginx: configuration file /etc/nginx/nginx.conf test is successful

Si hay algun error, en este ejemplo, unas "sssssss" al principio del fichero, entonces el error sería:

nginx: [emerg] unknown directive "ssssssssssssss" in /etc/nginx/sites-enabled/www.name-site.com:3
nginx: configuration file /etc/nginx/nginx.conf test failed

##### Ver los logs #####

Para ver los logs del sitio disponible:
--> /var/log/nginx/nombre_del_sitio.xxx.log

Para ver en tiempo real el log de accesos del server del sitio:
/var/log/nginx# tailf nombre_del_sitio.ve.access.log

Para ver en tiempo real el log de errores del server del sitio:
/var/log/nginx# tailf nombre_del_sitio.ve.error.log

##### A debugging log #####

To enable a debugging log, nginx needs to be configured to support debugging during the build:

./configure --with-debug .../tailf


Then the debug level should be set with the error_log directive:

#error_log /path/to/log error; // Normal error log.
error_log /path/to/log debug;

$ sudo systemctl restart nginx // Reiniciamos para que se aplique el cambio.

Ahora si vemos el error log con $ tailf nombre_del_sitio.ve.error.log
veremos una especie de monitor que nos mostrará otra o mas información
que el error.log normal.

##### Borrar nginx #####

# apt-get purge nginx nginx-common

# apt-get autoremove

-----

Ejemplo de configuración del fichero /etc/nginx/sites-available/default para servir proyectos de php:

server {
  listen   80;
  #root /usr/share/nginx/html;
  ### Aqui va la ruta donde tenemos el directorio del proyecto
  root /var/www/html;
  ## Orden de prioridad de los archivos index
  index index.php index.html index.htm;
  server_name example.com;
  location / {
    try_files $uri $uri/ /index.html;
  }
  error_page 404 /404.html;
  error_page 500 502 503 504 /50x.html;
  location = /50x.html {
    root /usr/share/nginx/www;
  }
  # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000
  location ~ \.php$ {
    try_files $uri =404;
    fastcgi_pass unix:/var/run/php5-fpm.sock;
    fastcgi_index index.php;
    fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;
    include fastcgi_params;
  }
}

#################
##### uwsgi #####
#################

UWSGI es una implementación de WSGI capaz de servir aplicaciones Python, pero que además apunta a proveer la pila de
software completa para implementar servicios de hosting.

Suele trabajar conjuntamente con un servidor web como Nginx.

##### Instalación #####

# apt-get install uwsgi uwsgi-core

# pip install uwsgi // Para entornos virtuales, se recomienda instalar globalmente

# apt-get install uwsgi-plugin-python // WSGI plugin for uWSGI (Python 2)          

# apt-get install uwsgi-plugin-python3 // WSGI plugin for uWSGI (Python 3)

##### Directorios #####

Luego de la instalación se crearon los siguientes directorios:

/usr/bin/uwsgi
/usr/lib/uwsgi
/etc/uwsgi
/usr/share/uwsgi
/usr/share/man/man1/uwsgi.1.gz

##### Configuración #####

Al igual que con nginx, es común que con uwsgi se crean archivos de configuración
específicos por si hay pruebas o si se va a servir mas de un sitio, ademas
de trabajar con enlaces simbólicosa esas configuraciones, entonces en /etc/uwsgi/
se pueden tener dos directorios:

/etc/uwsgi/apps-available // Directorio la las configuraciones de los sitios disponibles.

/etc/uwsgi/apps-enabled // Directorio de los sitios habilitados, con enlaces simbólicos a las configuraciones
en /etc/uwsgi/apps-available.

En este ejemplo, el archivo de configuración es un .xml en las aplicaciones disponibles, con un enlace
simbólico en las aplicaciones habilitadas.

apps-available
    README
    www-prueba.com.xml
apps-enabled
    README
    www-prueba.com.xml -> ../apps-available/www-prueba.com.xml

##### Ejemplo de archivo de configuración .xml #####

<uwsgi>
    <threads>10</threads>
    <workers>1</workers>
    <master/>
    <uid>name_project</uid>
    <gid>nogroup</gid>
    <log-x-forwarded-for/>
    <post-buffering>4096</post-buffering>
    <max-requests>1000</max-requests>
    <chmod-socket>666</chmod-socket>        
    <chdir>/var/www/path_project/</chdir>
    <module>wsgi</module>
    <plugins>python27</plugins>
</uwsgi>

##### Ver logs #####

$ tailf /var/log/uwsgi/app/name_site_com.log

#############################################################
##### Levantar un proyecto de Django, con uwsgi y nginx #####
#############################################################

En este ejemplo trabajaremos con un entorno virtual de python, y nuestro proyecto de Django se llama "prueba".

El fichero wsgi.py que está junto al settings.py lo moveremos a la raíz del proyecto, esto para que uwsgi
lo consiga con la configuración que haremos luego.

Instalamos nginx.

# apt-get install nginx

Instalamos uwsgi globalmente y el plugin de uwsgi de python.

# apt-get install uwsgi uwsgi-core

# apt-get install uwsgi-plugin-python // Para python 2.7

El crear y mover ficheros o directorios lo harémos siempre como root.
Ahora vamos a configurar nginx y a mover la aplicación "prueba" al directorio de trabajo /srv

En /etc/nginx/sites-available vamos a crear un fichero de configuración para nuestra aplicación "prueba"

/etc/nginx/sites-available# touch prueba

Ahora vamos a empezar a crear la configuración del sitio

/etc/nginx/sites-available# vim prueba

Nuestro fichero debería quedar mas o menos así:

server {
    #Puerto por el que va a escuchar el servidor
    listen 80;

    #Dirección ip de nuestra máquina
    #Va a ser la url o dirección por donde se va a servir la aplicación
    server_name 192.168.12.148;

    #Codificación de caracteres de la configuración
    charset utf-8;

    # Cuerpo máximo del mensaje permitido en una petición
    client_max_body_size 30M;

    client_body_buffer_size 128k;

    #Ruta en que está alojada la aplicación
    #root /srv/prueba;

    # Habilitamos los logs de acceso de nginx
    access_log /var/log/nginx/prueba.access.log;

    # Habilitamos los logs de error de nginx
    error_log /var/log/nginx/prueba.error.log;

    # Le decimos al servidor donde estan los estáticos de la aplicación
    location /static/ {
        root /srv/prueba/;
    }

    # Configuración adicional para trabajar con uwsgi
    # Esto es necesario solo si el sistema va a correr por una ruta
    #location ~ ^/(?<ruta>/.*)?$ {
    #location ~ ^/{
    location / {
        uwsgi_pass unix:/var/run/uwsgi/app/prueba/socket;
        include uwsgi_params;
        uwsgi_param UWSGI_SCHEME $http_x_forwarded_protocol;
        uwsgi_param SCRIPT_NAME /;
        # Esto es necesario solo si el sistema va a correr por una ruta
        #adicional al dominio, ejemplo: domain/ruta_adicional
        #uwsgi_param PATH_INFO $ruta;
        # Tiempo de espera en la conexión de nginx con uwsgi.
        uwsgi_read_timeout 600;
    }
}

Ahora creamos un enlace simbólico de sites-available a sites-enabled

# ln -s /etc/nginx/sites-available/prueba /etc/nginx/sites-enabled/

Al listar los directorios en sites-enabled nos quedará así:

/etc/nginx/sites-enabled# ls -la
total 8
drwxr-xr-x 2 root root 4096 ago 25 08:31 .
drwxr-xr-x 6 root root 4096 ago 25 07:59 ..
lrwxrwxrwx 1 root root   34 ago 25 07:59 default -> /etc/nginx/sites-available/default
lrwxrwxrwx 1 root root   25 ago 25 08:31 prueba -> ../sites-available/prueba

Verificamos que esté bien la configuración del nginx con:

# nginx -t
nginx: the configuration file /etc/nginx/nginx.conf syntax is ok
nginx: configuration file /etc/nginx/nginx.conf test is successful

Ahora harémos las configuraciones de uwsgi en /etc/uwsgi

etc/uwsgi# ls
apps-available	apps-enabled

Al igual que en nginx crearemos un fichero de configuración, pero este va a ser un xml
que se va a guardar en apps-available:

Tenemos que tener mucho cuidado al momento de configurar este fichero, las rutas deben ser
declaradas muy bien, especial énfasis en la ruta del entorno virtual, y el usuario del sistema y grupo
dueño de la aplicación, así como la ruta local o dirección donde está alojada la aplicación.

/etc/uwsgi/apps-available# vim prueba.xml

<uwsgi>
        <threads>100</threads>
        <workers>2</workers>
        <master/>
        <chmod-socket>666</chmod-socket>
        <home>/home/user/Entornos_virtuales/Django_1.8.8</home>
        <socket>/var/run/uwsgi/app/prueba/socket</socket>
        <pidfile>/var/run/uwsgi/app/prueba/pid</pidfile>
        <uid>root</uid>
        <gid>root</gid>
        <log-x-forwarded-for/>
        <post-buffering>4096</post-buffering>
        <max-requests>1000</max-requests>
        <chdir>/srv/prueba</chdir>
        <pythonpath>/srv/prueba/prueba/</pythonpath>
        <module>wsgi</module>
        <plugins>python27</plugins>
</uwsgi>

// Guardamos como prueba prueba.xml y ahora creamos el enlace simbolico en app-enabled

# ln -s /etc/uwsgi/apps-available/prueba.xml /etc/uwsgi/apps-enabled/

// Reiniciar servicio de nginx
# systemctl restart nginx

// Reiniciar el servicio de uwsgi
# systemctl restart uwsgi

Cada vez que se haga un cambio en la configuración de nginx reiniciaremos el servicio, y si el cambio
es de python, es decir en el proyecto de Django entonces reiniciaremos el servicio de uwsgi.

// Para no detener e iniciar los servicios y a su vez tumbar las conexiones usaremos reload en vez de restart:

# systemctl reload nginx

Si todo está bien, podemos visitar la ip local desde el navegador, 192.168.12.148 configurada en
nginx y por la cual va a estar servida la aplicación.

Si la aplicación no se muestra nos ayudaremos con los logs a encontrar el error

Para ver en tiempo real el log de accesos del servidor a nuestra aplicación:

# tailf /var/log/nginx/prueba.access.log

Para ver en tiempo real el log de errores del servidor en nuestra aplicación :

# tailf /var/log/nginx/prueba.error.log

Para ver en tiempo real el log de uwsgi:

# tailf /var/log/uwsgi/app/prueba.log

##############################################################
##### Levantar un proyecto de Django, con uwsgi y Apache #####
##############################################################

Instalamos apache

# apt-get install apache2

Esto nos creará el directorio /var/www/html/

Movemos el proyecto de django a /var/www/html/ y le damos permisos de lectura, escritura y ejecución al proyecto

# chmod -R 777 /var/www/html

Instalamos el modulo uwsgi

# apt-get install libapache2-mod-wsgi

// Reiniciamos el servicio de apache
# service apache2 restart

Una vez apache se halla reiniciado tendremos el modulo instalado y activado en apache.
A este punto solo nos queda configurar el host virtual.

// En base al fichero de configuración por defecto creamos una copia
# cp /etc/apache2/sites-available/000-default.conf /etc/apache2/sites-available/prueba.conf

Editamos prueba.conf

<VirtualHost *:80>
    # Por convención personal uso para los nombres de dominio la siguiente convención
    # lenguaje.nombre_del_proyecto.rama_de_git
    ServerName python.my_project.dev
    ServerAdmin admin@email.com
    # El document root debe hacer referencia a la carpeta donde esta nuestro proyecto
    DocumentRoot /var/www/html/my_project/

    # El WSGIScriptAlias obtiene 2 parámetros el primero hace referencia a la ruta y el segundo al archivo wsgi.py de nuestro proyecto
    WSGIScriptAlias / /var/www/html/my_project/my_project/wsgi.py

    # El WDGIDaemonProcess recibe los siguientes parámetros
    # - ServerName
    # - El ejecutable de Python relacionado al DocumentRoot
    # - La cantidad de procesos, para lo cual es recomendable dejarlo en 2
    # - Los threads, del mismo modo se recomienda dejarlo en 15
    # - Y el nombre a mostrar
    WSGIDaemonProcess python.<reponame>.dev python-path=/var/www/public/<reponame>:/var/www/public/<reponame>/env/lib/python2.7/site-packages processes=2 threads=15 display-name=%{GROUP}
    # El WSGIProcessGroup hace referencia al ServerName
    WSGIProcessGroup python.<reponame>.dev

    <Directory /var/www/public/my_project/ />
        <Files wsgi.py>
            Require all granted
        </Files>
    </Directory>

    Alias /robots.txt /var/www/public/<reponame>/static/robots.txt
    Alias /favicon.ico /var/www/public/<reponame>/static/favicon.ico

    # El directorio "static" será el encargado de servir los archivos css, js, etc...
    Alias /static/ /var/www/html/my_project/static/

    <Directory /var/www/public/<reponame>/static>
        Require all granted
    </Directory>

    # El directorio "media" se encarga en este caso de servir las imágenes, videos y demás
    Alias /media/ /var/www/public/<reponame>/media/

    <Directory /var/www/public/<reponame>/media>
        Require all granted
    </Directory>

    # LogLevel info ssl:warn

    ErrorLog ${APACHE_LOG_DIR}/error.log
    CustomLog ${APACHE_LOG_DIR}/access.log combined

    # Include conf-available/serve-cgi-bin.conf
</VirtualHost>

Falta...

######################################################
########## Instalar y configurar phpMyAdmin ##########
######################################################

aptitude install phpmyadmin // Instalar

http://localhost/phpmyadmin // Acceder al servicio

***After the installation has completed, add phpmyadmin to the apache configuration.**

# sudo nano /etc/apache2/apache2.conf //Agregar en este archivo la configuracion de abajo

***Add the phpmyadmin config to the file.

Include /etc/phpmyadmin/apache.conf //Esta linea se agrega al final de la configuracion del apache para que reconozca el phpMyAdmin

/etc/init.d/xxx restart // xxx mysql, apache etc... restart

###########################################
##### Configurar el localhost / hosts #####
###########################################

En el fichero /etc/hosts está configurado el localhost de la máquina, el contenido
puede ser parecido a:

---

127.0.0.1      localhost
127.0.1.1       debian8.debian8 debian8

---

Esto quiere decir que cuando accedamos desde el navegador a "localhost"
entonces estaremos accediento a 127.0.0.1.

Para hacer una prueba agregaremos y comentaremos una línea al fichero:

---

#127.0.0.1      localhost
127.0.1.1       debian8.debian8 debian8
127.0.0.1        www.x.x

---

Lo que hicimos es cambiar localhost por una url arbitraria, ahora si accedemos a www.x.x accederemos a 127.0.0.1

#######################################################
##### Bloquear acceso localmente a una página web #####
#######################################################

$ ping www.pagina_a_bloquear.com

Eso va a hacer ping o enviar paquetes a esa web y nos mostrara la ip pública
del sitio, es decir un número con este formato: 111.222.333.444

Ahora, con esa ip hacemos lo siguiente:

// Para bloquear el acceso a esa página
# iptables -I INPUT -s 111.222.333.444 -j DROP

// Para habilitar el acceso a esa página
# iptables -I INPUT -s 111.222.333.444 -j ACCEPT

##### Otra forma #####

Para bloquear sitios vamos a modificar el archivo hosts, abrimos un terminal y escribimos la siguiente
linea de comando:

// Como super usuario abrimos el fichero /etc/hosts con el editor gedit, puede ser nano vi, vim, u otro.

# gedit /etc/hosts

Ahora para bloquear en este ejemplo a Instagram, vamos a escribir al principio del archivo:

127.0.0.1 instagram.com
127.0.0.1 www.instagram.com

Guardamos y listo.

##################################################################
##### Bloquear acceso localmente a una página web en Windows #####
##################################################################

Probado en 7

Editamos con el blog de notas el fichero que está en:

C:\Windows\system32\drivers\etc\hosts

Nos encontraremos con algo como esto:

127.0.0.1       localhost
127.0.0.1       localhost
127.0.0.1       localhost

Para bloquear una página, solamente agregamos un par de lineas al final del fichero
Por ejemplo, vamos a bloquear a instagram, entonces quedaría así:

127.0.0.1       localhost
127.0.0.1       www.instagram.com
127.0.0.1       instagram.com

Guardamos y listo, podemos agregar tantas webs como queramos.

###################################
##### Generar certificado ssl #####
###################################

Hay que configurar el sitio a proteger en /etc/hosts

# aptitude install openssl

$ mkdir -p /etc/nginx/ssl_keys/ // Opcional, solo si se trabaja con Nginx web server.

1-) Generar la clave RSA:

$ openssl genrsa -des3 -out x.gob.ve.key 1024

-genrsa: Genera la clave rsa. En criptografía, RSA (Rivest, Shamir y Adleman) es un sistema criptográfico de clave pública

-des3: Triple-DES Cipher. En criptografía el Triple DES se llama al algoritmo que hace triple cifrado del DES. También es conocido
como TDES o 3DES, fue desarrollado por IBM en 1998. Data Encryption Standard (DES) es un algoritmo de cifrado, es decir,
un método para cifrar información. El algoritmo fue controvertido al principio, con algunos elementos de diseño
clasificados, una longitud de clave relativamente corta, Hoy en día, DES se considera inseguro para muchas aplicaciones.
Esto se debe principalmente a que el tamaño de clave de 56 bits es corto; las claves de DES se han roto en menos de 24 horas. 

-out: Archivo de salida

-1024: Podemos especificar el tamaño de la clave ( 1024, 2048)

2-) Generar CSR (Petición de Firma de Certificado

$ openssl req -new -key x.gob.ve.key -out x.gob.ve.csr

-Realiza una petición para la firma con clave privada especificado. Al realizarlo nos pide datos:

Req: Genera Certificate Signing Request (CSR) 
-new: Nuevo CRS
-key: Clave rsa creada anteriormente
Country Name (2 letter code) []:
State or Province Name (full name) []:
Locality Name (eg, city) []:
Organization Name (eg, company) []:
Organizational Unit Name (eg, section) []:
Common Name (eg, your name or your server's hostname) []: 
**El "Common Name" debe corresponder con la URL que queremos Securizar. Si la URL a poner por
SSL es x.gob.ve, este campo debe contener exactamente eso.
Email Address []:
Please enter the following 'extra' attributes
to be sent with your certificate request
A challenge password []:
An optional company name []:

3-) Eliminar Clave Privada DES3

$ cp x.gob.ve.key x.gob.ve.key.gob

$ openssl rsa -in x.gob.ve.key.gob -out x.gob.ve.key

4-) Generar Certificado Autofirmado.

$ openssl x509 -req -days 365 -in x.gob.ve.csr -signkey x.gob.ve.key -out x.gob.ve.crt

Al final nos Deben quedar 4 ficheros: .cert, .crs, .key, .gob
x.gob.ve.crt // Este es el certificado final.
x.gob.ve.csr
x.gob.ve.key
x.gob.ve.key.gob

#################
##### rsync #####
#################

Es una aplicación que ofrece transmisión eficiente de datos, que opera también con datos comprimidos y cifrados.
Mediante una técnica de delta encoding, permite sincronizar archivos y directorios entre dos máquinas de una red
o entre dos ubicaciones en una misma máquina, minimizando el volumen de datos transferidos.
Muy recomendable para hacer respaldos en discos externos.

# apt-get install rsync // Para instalarlo

Parametros: -P para mostrar el progreso de la copia y -r cuando se van a copiar directorios

rsync -P ficehero /directorio/carpeta2 // Para copiar ficheros, archivos, etc. 

rsync -P -r /directorio/carpeta1_origen /directorio/carpeta2_destino // -r para copiar directorios se ponen las dos rutas: origen y destino separados por un espacio
**Ojo con carpeta1, sin el / al final, lo cual significa que se va copiar la carpeta completa con su contenido y no solo su contenido.

##### rsync para copiar ficheros a un servidor a través de ssh #####

-v : Verbose (try -vv for more detailed information)
-e "ssh options" : specify the ssh as remote shell
-a : archive mode
-r : recurse into directories

$ rsync -P -r -v -e ssh name_dir_or_filename user@192.168.1.100:/home/use/dir/

##### Usando rsync desde python para copiar un fichero a un servidor #####

$ python

>>> import os
>>> os.system("rsync -varz /home/user/xxx.txt user@192.168.1.100:")
user@192.168.1.100's password: ******
sending incremental file list
xxx.txt

sent 87 bytes  received 31 bytes  33.71 bytes/sec
total size is 0  speedup is 0.00
0
>>> 

// Fichero copiado al servidor!

################################################
##### CCLive - Descargar videos de youtube #####
################################################

CCLive es una aplicación que nos permite descargar un vídeo que esté en YouTube
hacia nuestro ordenador mediante un simple comando. Por defecto guarda los vídeos en webm.

$ aptitude show cclive //Para ver si lo tenemos en los repos, y ver la descripción, si es así.

$ aptitude install cclive // Instalación, como root.

ó

$ sudo apt-get install cclive // Instalación, como root.

$ cclive https://www.youtube.com/watch?v=yWVrvce5R9 // Descargar un video pasando la url de youtube.

$ cclive URL1 URL2 URL3 URL4 // Soporta varias URLs a la vez, para bajar mas de 1 video.

$ cclive < urls.txt // Descargar un vídeo detrás de otro, desde un archivo de texto plano con todas las URLs (en líneas diferentes).

$ man cclive // Manual del paquete.

$ cclive -F https://www.youtube.com/watch?v=Lfj667lLLnE // Comprobar los formatos disponibles antes de descargar el video.
// Se podrá ver un listado de formatos disponibles separados por "|"

$ cclive -f fmt22_720p https://www.youtube.com/watch?v=LtzFg4JiL5E // Se elige el formato y se pasa en el comando, luego comenzará la descarga.

$ cclive -f best http://www.youtube.com/xxxxxx // Download the best available format of the media.

###########################################
##### Formatear pendrives desde linux #####
###########################################

# aptitude install dosfstools

Luego de instalar el paquede, montamos el pendrive, solo esta montado si aparece el nombre de la unidad en /media, luego escribimos:

$ df -h

Visualizamos la ruta de nuestro usb, ejemplo /dev/sdc1 que es el puerto donde está montado, luego desmontamos el pendrive.

$ umount /media/nombre_usb

Luego, estando desmontado la unidad usb, pero conectado al puerto

# mkfs.vfat -F 32 -n Nombre_usb /dev/sdc1

Esperamos y listo. Con la opción -F 32 le decimos que será formateada como Fat32, y con la opción -n le ponemos una etiqueta o nombre al dispositivo y
al final ponemos la ruta hasta nuestro dispositivo, la que vimos con df -h

#########################
##### sqlitebrowser #####
#########################

Herramienta de alta calidad visual para crear, diseñar y editar archivos de bases de datos compatibles con SQLite.
Es para usuarios y desarrolladores que desean crear bases de datos, buscar y editar datos.
Utiliza una interfaz de tipo hoja de cálculo familiar y no necesita aprender comandos SQL complicados.

# aptitude install sqlitebrowser

$ sqlitebrowser // Para ejecutarlo

#########################################################
##### Quemar o grabar una imagen iso en un pendrive #####
#########################################################

# dd if=[imagen] of=[dispositivo]

En donde imagen es la ruta completa a la imagen ISO que deseas grabar y dispositivo la ruta completa hacia el pendrive, no la ruta con el nombre del pendrive, por ejemplo:

dd if=/home/user/Descargas/debian-testing-i386-businesscard.iso of=/dev/media/sdb

-----

$ export GIT_SSL_NO_VERIFY=True // Si un repostirotio git remoto no cuenta con el certificado
digital del servidor a veces se debe saltar chequeo de la firma para bajar las fuentes con este comando.

################################################
##### Instalación de gnome en sistema base #####
################################################

# apt-get install gnome-shell

# apt-get install gnome-core

# apt-get install gnome

# apt-get install task-gnome-desktop

# apt-get install task-spanish-desktop

#####################################
##### Remover gnome del sistema #####
#####################################

# apt-get autoremove --purge 'gnome*'

# apt-get autoremove 

########################################################
##### Instalación de gnome classic en sistema base #####
########################################################

Probado en Ubuntu 11 y 12 nada más, puede que funcione en anteriores o superiores.

# apt-get install gnome-panel

# apt-get install gnome-session-flashback

Luego de reiniciar, saldrá el gnome-classic en las opciones de escritorio antes de iniciar sesión.

###############################################
##### Instalación de xfce en sistema base #####
###############################################

Xfce es un entorno de escritorio ligero para sistemas tipo UNIX. Su objetivo es ser rápido y usar pocos recursos
del sistema, sin dejar de ser visualmente atractivo y fácil de usar.

# aptitude install xfce4

Luego instalamos utilidades extras, si se quiere, se le conoce como "goodies".

# aptitude install xfce4-goodies

# aptitude install lightdm

Luego de eso, cuando reiniciemos la máquina, podremos elegir acceder con xfce como entorno de escritorio.

#############################################################################
##### Comandos para buscar ficheros, directorios, paquetes, historiales #####
#############################################################################

$ history // Mostrar el historial de los comandos de la consola

$ fc -l // Mostrar los ultimos comandos usados por el usuario

$ history | grep xxx // Busqueda especifica de una comando usado, ejemplo: aptitude, alias, grep etc.

.bash_history // En los archivos ocultos del home, en este fichero se almacena el historial de los comandos usados

$ grep --color=always -n "mysql" /var/www/prueba/2/datos.php // --color para colorear la palabra a buscar, 
-n para listar la la linea del caracter buscado y al final ra ruta del archivo a buscar

$ grep cadena_texto ./* -rIn // Busca la cadena de manera recursiva en la carpeta en que se encuentre situado

$ grep --color=always -n "cadena_texto" ./* -Ir // Busca la cadena de manera recursiva en la carpeta en que se encuentre situado

$ grep --color -n "cadena_texto" -Ir // No hace falta poner =always

$ egrep -r "Saludo" . // Otra forma de busqueda.

| grep xxx // filtra la busqueda con el parametro que le demos ejemplo:

$ aptitude search python | grep 2.7 // Busca las versiones de python que coincidan con el patron 2.7

$ ps -e | grep ruby // Busca en los procesos del sistema las coincidencias con ruby

$ whereis python // Para saber donde esta instalado un programa, saber el directorio
$ whereis firefox
$ whereis apache2

$ find // Listar todos los archivos contenidos en el directorio actual y en los sub directorios, si estamos en /home/user nos listara todo, dependiendo de donde este pues listara el contenido.

$ find -name name_dir // Buscar un directorio especifico en el sistema.

# find / -name name_file_or_package // Buscar un fichero o directorio específico en el sistema.

su:
find / -type f -name NombreArchivo.html // Para mostrar el directorio del archivo que se quiera buscar, se debe saber el nombre del archivo.

file:///home/user/nombre_fichero.xxx // Abrir un fichero del directorio desde el navegador.

$ locate nombre_del_archivo // Hacer una busqueda de un archivo en los directorios, se puede especificar un nombre con su extensión
//o solo especificar una palabra, la busqueda se hara en todos los archivos que contengan la palabra o nombre de archivo escrita.

$ locate .jpg // Buscar en todos los directorios los ficheros con la extension especificada

$ locate "*.jpg" // Buscar en todos los directorios los ficheros con la extension especificada.

$ locate .pdf | grep software // Buscar en todos los .pdf del sistema que contengan la palabra "software" en el nombre. Sí hace distinción entre mayúsculas, minúsculas y acéntos.

$ sudo locate -c hola // Muestra cuantos archivos contienen la palabra "hola" en el nombre.

$ sudo locate -i hola // Busca todos los archivos que contienen la palabra "hola" en el nombre tanto en mayúsculas como en minúsculas.

$ sudo locate nombre_archivo > /home/usuario/lista.txt // Para guardar el resultado de la búsqueda en un archivo de texto.

$ sudo find / -name nombre_carpeta // (/) es para hacer la busqueda desde ahi en adelante, puede ser (/home/user)

$ find /carpeta // Lista los archivos que componen el directorio introducido

$ type nombre_comando // Busca la ruta donde se encuentra el comando, ejemplo: aptitude, python, etc.

$ which nombre_programa // Buscar la ruta de un programa

$ sudo find / -name "*nombre_fichero*" // Buscar en todo el sistema los ficheros cuyo nombre contengan la expresion escrita.

$ sudo find / -name "*.xxx*" // Buscar en todo el sistema los ficheros cuyo nombre contengan la expresion escrita, en este caso,
una extensión de fichero, donde / puede ser /home/user etc y .xxx la extension: .jpg, .png, .txt, .py, etc.

$ sudo find /home/user ! -name "*xxx*" // Busca todos los archivos que NO contienen la palabra "xxx" en el nombre, se especifíca el directorio en el cual buscar.

$ sudo find /home/user -iname "*xxx*" // Busca todos los archivos que contienen la palabra "xxx" en el nombre tanto en mayúsculas como en minúsculas.

$ sudo find /home/user/ -iname "*xxx*" > /home/user/lista.txt // Si el resultado de la búsqueda anterior te ha proporcionado una gran cantidad de información, resulta
más cómodo almacenar el resultado de la búsqueda en un fichero de texto para revisarlo posteriormente.

# sudo find / -type f -name /home/user/fichero.c>>/home/user/x.txt // Crear un fichero (x.txt) que guardará la salida de la consola, en este caso
es una búsqueda, buscamos el fichero.c en el directorio user y guardaremos la salida del shell en el fichero x.txt que se creará.

########################################
##### wget para descargar ficheros #####
########################################

$ wget www.ejemplo_web.com // Descargar toda una página completa, wget no está limitado a solo descargas de archivos. Sitios completos pueden descargarse también.

$ wget -p www.ejemplo_web.com  // Lo mismo que lo anterior pero con esta opción -p descarga además todos los elementos extras necesarios de la página
como hojas de estilos, imágenes en línea, etc.

$ wget -c ftp://sunsite.doc.ic.ac.uk/ls-lR.Z // -c ó --continue, reanudar una descarga de wget si se detuvo por caída de red, cancelación de proceso, etc. Se lanza el comando de nuevo con el enlace para reanudar.

$ wget http://ejemplo.com/programa.tar.gz  ftp://otrositio.com/descargas/video.mpg // Indicar más de una descarga a la vez, incluso con distintos protocolos o extensiones

$ wget http://ejemplo.com/*.pdf // Descargar varios archivos, con extensión similar.

$ wget -i archivos.txt // Descargar varios archivos a traves de una lista.

Creamos una lista en archivos.txt que serán descargados:
http://ejemplo.com/programa.tar.gz
http://ejemplo.com/rpm/paquete.rpm
ftp://otrositio.com/descargas/distro.iso

$ wget -t 50 http://ejemplo.com/pelicula.mpg // Por defecto, wget realiza 20 intentos de establecer la conexión e iniciar la descarga, en sitios muy
saturados es posible que ni con 20 intentos se logré, con la opción -t (tries) aumenta a más intentos.

$ wget -r www.ejemplo.com // Con la opción -r se descarga recursivamente hasta 5 niveles del sitio.

$ wget --convert-links -r http://www.sitio.com/

ó

$ wget -k -r http://www.sitio.com/ // Por defecto, los enlaces dentro del sitio apuntan a la dirección del dominio completo. Si deseas descargar el sitio
recursivamente y después estudiarlo fuera de línea (off line) usa la opción convert-links que los convertirá en enlaces locales, apuntando a las páginas
dentro del sitio descargado.

$ wget --mirror http://ejemplo_web.com/    

ó

$ wget -m http://ejemplo_web.com/ // De este modo obtienes una copia (un espejo) completa del sitio.

$ wget -r -l7 www.ejemplo.com // -l7 (nivel de profundidad) de descargara, es decir descargará en esa profundidad de subdirectorios. De forma predeterminada wget emplea 5.

#################
##### jigdo #####
#################

Jigsaw Download, o abreviadamente jigdo , se propone como la forma principal de distribuir imágenes de CD de Debian en el futuro. Actualmente, el sistema funciona, pero no es aún muy cómodo de usar porque la aplicación gestora de descargas no está terminada.

Página del paquete -> https://www.debian.org/CD/jigdo-cd/

# aptitude install jigdo-file

Aquí, por ejemplo, podemos buscar los .jigdo --> http://cdimage.debian.org/debian-cd/8.5.0/amd64/ en jigdo-dvd/

$ jigdo-lite // Nos pedirá un fichero .jigdo para descargar

ó simplemente le pasamos el fichero en el mismo comando:

$ jigdo-lite http://cdimage.debian.org/debian-cd/8.5.0/amd64/jigdo-dvd/debian-8.5.0-amd64-DVD-1.jigdo // Para descargar

ó

$ jigdo-lite http://cdimage.debian.org/cdimage/archive/7.11.0/amd64/jigdo-cd/debian-7.11.0-amd64-CD-1.jigdo // Para descargar

Luego nos preguntará por ejemplo:

Files to scan: 

Como esta es la primera vez que vamos a descargar el iso, damos Enter y no añado nada en este paso.

Lo otro que va a preguntar es cuál el mirror que quieres usar (se puede usar un mirror local siempre y cuando esté actualizado). por lo tango metemos la dirección en el espacio: http://debian.cen.... y enter

Ejecutará muchos procesos y al final debe mostrar un:

-------------------------------
Finished!
The fact that you got this far is a strong indication that `debian-7.11.0-amd64-CD-1.iso'
was generated correctly. I will perform an additional, final check,
which you can interrupt safely with Ctrl-C if you do not want to wait.

OK: Checksums match, image is good!  

################################################
########## Ambiente virtual en Python ##########
################################################

// Cuando se desarrollando software con Python, quizas se presente el problema de tener utilizar diferentes versiones de una mismo paquete en
diferentes proyectos, ya sea el mismo Python o diferentes versiones de un Framework como Django por ejemplo, el problema a solucionar radica
en como poder instalar las dos o mas versiones de la misma librería con el fin de poder desarrollar varios proyectos de forma simultánea.

La solución consiste en crear virtualenvs o entornos virtuales. Un entorno virtual de Python es un espacio completamente independiente
de otros entornos virtuales y de los paquetes instalados globalmente en el sistema. Esto significa que es posible instalar la versión
2.7 de Python en un entorno virtual y la versión 3.0 en otro diferente o de forma global sin problema alguno.

El porder tener diferentes entornos donde podemos instalar diferentes versiones de paquetes nos da la oportunidad de hacer un desarrollo simultaneo
así como poder hacer pruebas si afectar a los paquetes del sistema global.

--- Instalación: ---

Para crear un ambiente virtual instale las herramientas python-setuptools, python-dev, python-virtualenv, virtualenvwrapper

# aptitude install python-setuptools python-dev

# aptitude install python-virtualenv virtualenvwrapper

$ mkvirtualenv nombre_ambiente_virtual //  Con un usuario (diferente a root) cree un ambiente virtual para su proyecto.

$ workon nombre_ambiente_virtual // Para acceder al nombre del ambiente virtual creado

ejemplo: 
user@debian:/home$ workon proyecto // Accedemos al entorno virtual creado
(proyecto)user@debian:/home$ // Ya estamos en el entorno virtual creado, denotado por el nombre del entorno al inicio del prompt

$ deactivate nombre_ambiente_virtual // Para salir del entorno virtaul, o simplemente deactivate

$ lsvirtualenv // Para listar los entornos virtuales creados o disponibles.

$ rmvirtualenv nombre_virtualenv // Remover o borrar un entorno virtual.

// Los entornos virtuales se crean en el directorio /home/user/.virtualenvs

##### Tips #####

En Debian GNU/Linux 8 (Jessie) a veces el comando mkvirtualenv no funciona por lo que hacemos lo siguiente:

# apt-get install virtualenvwrapper

$ vim .bashrc // Como usuario normal (NO ROOT), hay que agregar las variables con la ruta para virtualenv en el .bashrc, Agregar el siguiente contenido:

# to virtualenvwrapper
export WORKON_HOME=$HOME/django
source /etc/bash_completion.d/virtualenvwrapper

luego:

$ source ~/.bachrc

##### Usando virtualenv #####

Installation: 

# aptitude install python-virtualenv

-Crear un virtualenv:

$ virtualenv mi_env

-Activar el virtualenv:

$ source mi_env/bin/activate

-Instalar un paquete (p.ej. Django) en el virtualenv:

(mi_env)$ pip install django

-Trabajar en el proyecto.

-Salir del virtualenv:

(mi_env)$ deactivate

##### Usando Python 3 en virtualenvwrapper #####

# aptitude install python3.4 python3-pip python3.4-dev python3-setuptools

# aptitude install python3-virtualenv virtualenvwrapper

$ mkvirtualenv --python=/usr/bin/python3 my_env

$ workon my_env

(my_env)$

##### Usando Python 3 en virtualenv #####

$ virtualenv -p python3 my_env

##### Borrar entorno virtual #####

No hay comando para borrar un entorno virtual desde virtualenv, basta con cancelar o detener los procesos (servidores y servicios) usados por
ese entorno y luego borrar el directorio.

$ rm -rf myenv

########################
##### Paquetes pip #####
########################

// Para desarrollar software con rapidez y calidad, es imprescindible utilizar paquetes externos que ayuden
con parte de la funcionalidad que se desea implementar. En el ambiente Python esto no es la excepción.

// Para solventar ésta necesidad, la comunidad Python ha puesto convenientemente a disposición de los desarrolladores
un repositorio de paquetes de fácil acceso llamado PyPi. Solo es necesario ejecutar un comando en la terminal
para poder instalar el paquete Python que necesitemos. Incluso es posible instalar paquetes que no se encuentren
en el mencionado repositorio.

// Para descargar paquetes del repositorio PyPi se pueden utilizar varias herramientas, pero en este caso se
va a usar pip. Es necesario instalar esta herramienta en el sistema en caso de no estar disponible, antes
de poder instalar un paquete Python.

// El comando pip equivale al apt-get de Debian pero para paquetes Python.

# aptitude install python-pip python-dev python-setuptools python3-pip // Instalamos pip y otros necesarios, com python3 para pip, necesario en algunos proyectos.

// Una vez instalado ya podremos instalar paquetes de Python a traves de pip ejemplo:

$ pip install django // Nos instalara la ultima version de Django disponible en los paquetes pi

$ pip install django==1.7 // Instalar una versión específica de algun paquete.

// Tambien es posible crear ficheros que contengan rutinas para automatizar la instalacion
de varios paquetes ejemplo:

Creamos un requirements.txt y dentro escribimos como ejemplo:
django==1.5.12
pillow==2.4.0
Geraldo==0.4.17

// Luego podemos ejecutar un pip install sobre el fichero e instalará lo que contenga:

pip install -r requirements.txt

// Dentro de los .virtualenvs, dentro de nuestro entorno virtual en
lib/python2.7/site-packages podemos ver que se instalaron los paquetes de requirements.txt
de no ser así hay que revisar el fichero o el nombre de los paquetes a instalar, etc.

$ pip search nombre_paquete // Buscar un paquete.

$ pip uninstall package // Desinstalar un paquete.

$ pip show package // Para ver si un paquete está instalado, si es así, mostrará la version, y la ruta donde está instalado.

$ pip install Package --upgrade // Para actualizar un paquete a su última versión.

$ pip install --upgrade Package package==1.x.x // Actualizar un paquete a una versión específica.

 $ pip freeze // Listar los paquetes instalado y sus versiones exactas.

##### Error: ImportError: No module named packaging.version #####

Puede que alguna vez a pip le pique el trasero y no deje realizar acciones
de búsqueda, actualización etc.. entonces moveremos unos ficheros:

$ cd /usr/local/lib/python2.7/dist-packages

$ mv pkg_resources/ pkg_resources_bak/

Funcionó cuando se instalo en el sistema base, si está en un entorno virtual la
ruta será diferente.

###########################################
##### Usando un espejo de pip cercano #####
###########################################

Para usar los repositorios py.pi internos de Cenditel
vamos al directorio /home/usuario/.pip/
y creamos dentro el fichero pip.conf
Agregamos el siguiente contenido al fichero creado y guardamos:

[global]
index-url = http://pypi.cenditel/simple/

Luego actualizamos el pip y listo, si estamos usando un entorno virtual de python
entonces ejecutaremos los comandos dentro del entorno virtual.

$ pip install --upgrade pip
$ pip install package_name --trusted-host pypi.cenditel
$ pip install -r requirements.txt --trusted-host pypi.cenditel // Para instalar recursivamente un fichero de requerimientos.

##### Nota #####

Hay paquetes que requieren permisos de superusuario, entonces al usar sudo, o estar como
superusuarios ya no hará efecto el pip.conf que está en /home/usuario/.pip/
entonces, para que sirva con el root tambien crearemos el pip.conf pero en el home del root
que está en /root/.pip/

# touch /root/.pip/pip.conf

# nano /root/.pip/pip.conf // Y hacemos lo mismo que arriba, copiamos el contenido, guardamos y listo.

A veces no se crea el directorio .pip del usuario entonces lo creamos manualmente

/home/user$ mkdir .pip

root@debian# mkdir .pip // en /root

#############################################
########## Conexion remota con ssh ##########
#############################################

SSH (Secure SHell) es el nombre de un protocolo y del programa que lo implementa, y sirve para acceder
a máquinas remotas a través de una red. Permite manejar por completo la computadora mediante un intérprete
de comandos, y también puede redirigir el tráfico de X para poder ejecutar programas gráficos si tenemos ejecutando un Servidor X (en sistemas Unix y Windows).

Además de la conexión a otros dispositivos, SSH nos permite copiar datos de forma segura
(tanto archivos sueltos como simular sesiones FTP cifradas), gestionar claves RSA para no escribir
claves al conectar a los dispositivos y pasar los datos de cualquier otra aplicación por un canal seguro tunelizado mediante SSH.

// Instalar ssh y el servidor de ssh que permite conexiones remotas.
# aptitude install ssh openssh-server

// Conectarse a otra máquina o servidor
$ ssh Nombre_usuario@IP_servidor o nombre_servidor

$ ssh user@192.168.0.240 // Asi se accede a un ordenador o servidor remoto, debemos poner el usuario que debe estar creado asi como la ip
del server, nos pedira la clave de session, una vez adentro tenemos acceso a los archivos y podemos pedir el root para tener acceso total.
ssh es muy usado por administradores de redes y de sistemas para acceder a las maquinas y los servidores y hacer cambios asi 
como monitorear los procesos que esten ejecutando, especialmente en maquinas virtuales si varios proyectos corren en un mismo servidor.

$ ssh 192.168.200.xxx // Si el servidor tiene el mismo usuario que el host, no hace falta especificarlo, solamente con la ip del servidor
basta, pues toma el nombre del usuario del host para hacer la conexión.

Estando conectados al servidor, podemos enviar mensajes o abrir programas remotamente, ejemplo:

echo "mensaje" > /dev/pts/2 // Enviar mensaje a traves del shell a otro usuario, en el servidor o local, debe haber un shell abierto que sea receptor
Se puede hacer localmente para probar, con (who) veremos la identificacion de cada shell, si estamos conectados remotamente, comprobaremos si hay shells
abiertos en el local y el servidor, se identifican con los pts/0, pts/1, etc, y sabremos por la ip si son shells locales o del server  el mensaje sale en
el shell escogido.

$ export DISPLAY=:0.0 // Creamos la ventana virtual donde se abrira la aplicacion que ejecutemos, luego
$totem o $nautilus // Deberia abrir el programa en el servidor, ya esportada la ventana podemos:

DISPLAY=:0.0 totem // Abrir el reproductor totem en el servidor

DISPLAY=:0.0 nautilus // Abrir el explorador de archivos en el servidor

// Reiniciar el servicio de ssh, a veces se hace para que sirvan algunos cambios de configuración.
$ sudo service ssh restart

// Para ver el estado del servicio.
$ sudo service ssh status

###########################
##### Seguridad en ssh ####
###########################

Para hacer mas seguras las conexiones a través de ssh es necesario realizar ajustes adicionales en la configuración del servidor.
Estos ajustes se deben realizar en el fichero de configuración del servidor que, por ejemplo, en Linux se encuentra en /etc/ssh/sshd_config

-- Cambiar el puerto por defecto del servidor SSH --

Por defecto los servidores SSH utilizan el puerto 22 para las conexiones. Cuando un pirata intente buscar la forma de conectarse a nuestro
servidor SSH este probará en primer lugar con este puerto y, de estar abierto, comenzará el ataque.

Si cambiamos el puerto por defecto por otro de nuestra elección evitaremos que utilicen el puerto 22 para establecer
las conexiones, sin embargo, es fácil descubrir si este tipo de protocolos utilizan otros puertos adicionales para las conexiones.

-- Bloquear el acceso root en las conexiones remotas --

Es recomendable crear un único usuario para conectarse al servidor con una contraseña lo más fuerte posible de manera que no pueda
ser explotada fácilmente, sin embargo, por defecto el usuario Root también puede conectarse al servidor SSH de forma remota evitando
a un atacante el tener que adivinar el usuario y facilitándose el trabajo.

Desactivando los permisos de Root para conectarse al servidor SSH complicaremos notablemente la tarea de explotación por fuerza bruta
del servidor al tener que adivinar también el usuario establecido para permitir la conexión.

El valor por defecto en el archivo de configuración que permite las conexiones de root es:

    PermitRootLogin yes

Debemos cambiarlo por:

    PermitRootLogin no

De esta manera las conexiones root quedarán bloqueadas evitando que usuarios no autorizados puedan realizar
ataques de fuerza bruta contra nuestro servidor SSH para adivinar los credenciales del usuario Root.

-- Configuraciones de seguridad adicionales --

Existen otras configuraciones recomendadas para evitar las conexiones no deseadas a nuestro servidor SSH. Estas conexiones son:

LoginGraceTime: Estableceremos el tiempo necesario para introducir la contraseña, evitando que el atacante tenga que “pensar mucho”.

MaxAuthTries: Número de errores permitidos al introducir la contraseña antes de desconectarnos.

MaxStartups: Número de logins simultáneos desde una IP, para evitar que se pueda utilizar la fuerza bruta con varias sesiones a la vez.

AllowUsers: Este parámetro nos permite configurar los usuarios que podrán conectarse y desde la IP que lo podrán hacer. Una medida muy
restrictiva pero a la vez muy segura ya que bloqueará todas las conexiones que no cumplan los dos parámetros.

-- Reiniciar el servidor para aplicar los nuevos ajustes --

Una vez realizados los ajustes debemos reiniciar el servidor para que se apliquen correctamente. Para ello teclearemos:

$ sudo service ssh reload

En pocos segundos el servidor volverá a arrancar con la nueva configuración aplicada y mucho más seguro que antes.

##### Ejemplo de configuración #####

Port 432 (o el que se quiera menor a 1024)
Protocol 2
LoginGraceTime 30
PermitRootLogin no
MaxAuthTries 2
MaxStartups 3
AllowUsers jose  o también:
AllowUsers jose maria@192.1.1.300

---

Port: Por default el demonio ssh funciona en el puerto 22, y precisamente muchos scripts de ataques están dirigidos a este puerto, el cambiar
de puerto no garantiza que el servicio ya no será localizable, de hecho con herramientas como nmap o amap es sumamente fácil descubrir que un
servicio ssh esta a la escucha en otro puerto distinto al 22, pero al menos no será localizable por varios scripts que de manera automática
escanean redes y en cuanto a ssh se enfocan solo al puerto 22.

Protocol 2: Hay dos versiones de ssh en cuanto a su protocolo de comunicación, la versión 1 y la versión 2. La 1 esta en desuso pero todavía
se incluye por compatibilidad, tiene varias vulnerabilidades conocidas y su uso no es ya recomendable. Un error frecuente es dejar al demoinio
ssh que permita el uso de las dos versiones (Protocol 2,1). Para evitar el uso del protocolo 1 y sus posibles ataques a este, basta con indicar
en esta línea que solo admita comunicaciones de ssh basadas en el protocolo 2.

LoginGraceTime 30: El número indica la cantidad de segundos en que la pantalla de login estará disponible para que el usuario capture su nombre
de usuario y contraseña, si no lo hace el login se cerrará, evitando así dejar por tiempo indeterminado pantallas de login sin que nadie
las use, o peor aun, que alguien este intentando mediante un script varias veces el adivinar un usuario y contraseña. Aqui conviene identificar
en nuestros usuarios el tiempo promedio que tardan en ingresar su usuario y contraseña y darles unos cuantos segundos más de margen por los
usuarios lentos para que ingresen sus credenciales. Si somos el único usuario del sistema considero que con 20 o 30 segundos es mas que suficiente.

PermitRootLogin no: Esta es quizás la más importante directiva de seguridad que podemos indicar para fortalecer nuestro servidor ssh.
Prácticamente todos los sistemas Linux y Unix crean por default al usuario root, entonces sabemos que existe!!!. Muchos ataques de fuerza bruta
se concentran en atacar al usuario root con la esperanza de que tenga una contraseña débil (¡que es mas común de lo que pensamos!).

Entonces si ya sabemos una parte de la ecuación (root) solo será cuestión de tiempo para que alguien con paciencia y suerte vulnere el sistema.
Al poner en 'no' la variable PermitRootLogin el usuario root no tendrá permiso de acceder mediante ssh y por lo tanto cualquier intento de ataque
directo a root será inútil. Con esto siempre tendremos que ingresar como un usuario normal y ya estando adentro entonces mediante su o sudo
podremos usar funciones de root, no problem. Ahora bien, para el nombre de login del usuario normal te recomiendo que también NO uses palabras
conocidas como: admin, manager, juan, pedro, sistemas, etc. Usa algo mas dífcil de adivinar como jgon (de juan gonzález) o sispat (de sistemas pato)
o mejor aun también puedes combinar algún guión bajo o mayúsculas, minúsculas y números en la cuenta de login. Con lo anterior el hacker tendrá
que atinarle o crackear tanto al nombre del usuario como su contraseña.

MaxAuthTries 2: El número indica la cantidad de veces que podemos equivocarnos en ingresar el usuario y/o contraseña, en este caso después de dos
intentos, se perderá o cerrará la conexión. Claro, es totalmente posible volver a intentarlo, pero como son dos intentos por vez, evitaremos ataques
basados en la persistencia de la conexión, como se perderá al tercer intento de conexión, el ataque cesará.

MaxStartups 3: El número indica la cantidad de pantallas de login, o cantidad de conexiones simultaneas de login que permitirá el sshd por ip que
intente conectarse. Hay ataques muy efectivos que dividen el ataque en decenas y puede ser que en cientos (si el sistema atacado lo permite) de
conexiones de login. Es decir, el ataque divide en una gran cantidad de logins los intentos por ingresar, aumentando sus posibilidades de más
rapidamente adivinar al usuario y contraseña. Con esta directiva limitamos a tan solo 3 pantallas de login. Que quede claro, una vez logueados
en el sistema, es posible tener mas de 3 terminales de ssh, se refiere exclusivamente a pantallas de login.

AllowUsers: En sistemas donde se tiene varios usuarios, quizás existan varios que solo pueden acceder desde la LAN por ejemplo, o quizás solo
desde ciertos equipos. O incluso que solo desde su PC puedan trabajar en Linux por lo que no hay razón para que se conecten remotamente
via ssh. Con esta directiva podemos indicar los usuarios que pueden ingresar via ssh. Si solo indicamos al usuario:

AllowUsers jose

El usuario jose podrá ingresar desde cualquier PC en cualquier lugar, no se está validando el host.
Si se quiere mas seguridad, es posible indicar también el host mediante el símbolo @

AllowUsers jose@192.168.0.25     (solo desde la IP indicada)
AllowUsers jose@192.168.0.*       (Toda la red indicada)
AllowUsers jose@*.desarrollo.com  maria@contabilidad.com    
  (aosorio desde cualquier equipo del dominio indicado, maria solo desde el equipo indicado)

Como puede verse, bastan algunas cuantas directivas o variables bien configuradas en nuestro archivo /etc/ssh/sshd_config para incrementar
enormemente la seguridad en este servicio, seguramente no estoy considerando alguna otra variable que también pudiera ser importante
para la seguridad de ssh, si es así por favor házmelo saber para incluirla en este documento. Asi como también hay que tener en cuenta
que hay variables que permiten el no acceso con contraseñas y sería más bien con certificados o llaves, las posibilidades son extensas y
es posible incluso tener varios equipos Linux comunícandose entre si para respaldos, bases de datos, etc. con ssh y certificados de
seguridad, evitando intervención humana, consulta la sección de servicios si es lo que buscas en tu empresa.

###########################################
##### X11 forwarding a través de ssh  #####
###########################################

X11, es el servidor gráfico que usan casi todas las distribuciones Linux. Este servidor permite, entre otras cosas,
forwarding a través de SSH. Esto significa que es posible ejecutar apliaciones gráficas de una máquina remota exportando el display a nuestro escritorio.
Es decir, la aplicación se ejecuta en el servidor remoto, pero la interfaz gráfica la visualizamos en nuestro escritorio local.

Ejemplo:
1- En el servidor, editar el archivo /etc/ssh/ssh_config y modificar la opción X11Forwarding o ForwardX11 para que quede así:

X11Forwarding yes

ó

ForwardX11 yes

Luego de este cambio, posiblemente sea necesario reiniciar el demonio ssh. La forma de hacer esto varía de acuerdo a cada distribución Linux.
Lo más sencillo es reiniciar la máquina.

2- En el escritorio local, loguearse al servidor a través de ssh utilizando el parámetro -X:

$ ssh -X user@hostname

Donde user es el nombre de usuario utilizado para loguearse en el servidor y hostname es el ip o el alias del servidor.

3- Para ejecutar una aplicación, simplemente hay que hacerlo desde el terminal. Por ejemplo:

$ firefox

$ nautilus

$ evince

Cuando ejecutamos una aplicación gráficamente la consola se bloqueara con el proceso en ejecución, por lo que podemos usar &
para que se ejecute el proceso, construya el entorno grafico del programa y luego dezplace el proceso para poder seguir usando la
consola, ejemplo:

$ firefox

ó

$ firefox & nautilus &

######################################
##### Escritorio remoto, por ssh #####
######################################

Esta guía nos permitirá ejecutar un escritorio remoto a través de una conexión por ssh,
el cliente debe estar en modo consola, puede usar tty1 por ejemplo.

Primer paso, instalar openssh-server en el cliente y en el servidor

# apt-get install openssh-server openssh-client

Una vez hecho esto configuramos el servidor para que sea accesible desde los clientes:

$ sudo nano /etc/ssh/ssh_config

Hay tres lineas del archivo que deberían quedar así:
ForwardAgent yes
ForwardX11 yes
ForwardX11Trusted yes

Guardamos y abrimos otro archivo:

$ sudo nano/etc/ssh/sshd_config

Debe aparecer la siguiente línea:
ForwardX11 yes

Una vez hecho esto reiniciamos el servidor ssh:

$ sudo service ssh restart

Luego nos conectamos por ssh al servidor, con el parámetro -X que nos permitirá levantar gráficos en el cliente.

$ ssh -X username@ip_server

##### startx #####

Para iniciar o levantar el modo gráfico

$ startx -- :DISPLAY // Arrancar el servidor gráfico indicándole el DISPLAY, por defecto el primer DISPLAY es 0 (al cual accedemos con Cntrl+Alt+F7).

---

$ sudo startx // Levantará una sesión de escritorio como root, el cliente debe estár en modo ttyX.

ó

$ gnome-session // Puede que falle a veces, si es que el cliente ya tiene una interáz gráfica corriendo, por eso se recomienda que esté en ttyX.

###############################################################
##### El error ssh remote host identification has changed #####
###############################################################

Cuando el sistema base guarda una llave de acceso a un host, pero el host cambió, entonces la llave no funciona y arroja el típico error:

@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@    WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED!     @
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
IT IS POSSIBLE THAT SOMEONE IS DOING SOMETHING NASTY!
Someone could be eavesdropping on you right now (man-in-the-middle attack)!
It is also possible that a host key has just been changed.
The fingerprint for the ECDSA key sent by the remote host is
...
...
...

Entonces borramos ese host roto, llave perdida, etc.

$ ssh-keygen -R <host>

Ejemplo:

$ ssh-keygen -R 192.168.3.10

##########################################################
##### Generar llaves para ssh para saltar contraseña #####
##########################################################

Si el host desea conectarse al servidor, sin tener que escribir password cada vez que se intente conectarse
puede usar este método donde se generan claves publica y privada.

// Generamos las claves en el host
$ ssh-keygen -b 4096 -t rsa

No generar frase de paso: simplemente presionemos [Enter], un segundo después volvemos a presionar [Enter],
y un segundo después volvemos una vez más a presionar [Enter]. O sea, presionaríamos [Enter] un total de tres
(3) veces, solo lo presionamos… no escribimos nada.

Eso nos va a generar las claves en:

/home/user/.ssh
id_rsa // Es nuestra llave privada.
id_rsa.pub // Es nuestra llave pública.
known_hosts // Es un fichero ya existente en ese directorio.

Enviamos la llave publica para el home del servidor:

$ scp /home/.ssh/id_rsa.pub user@192.168.12.x:

Luego en el servidor renombraremos la clave publica a:

$ mv id_rsa.pub authorized_keys

Luego moveremos ese nuevo fichero a .ssh

$ mv authorized_keys .ssh/

Luego quedaría intentar conectarse desde el host al servidor, si todo está bien no debería pedir contraseña.

**Es funcional, pero hubo una vez que no se que coño paso y no quizo funcionar, las demas pruebas si fueron exitosas.

####################################################
##### Copias de directorios o ficheros por scp #####
####################################################

##### COPIAR ARCHIVOS DE LOCAL A SERVIDOR #####

Si queremos subir el archivo archivo.txt de nuestro ordenador a la carpeta /home/usuario del servidor, hacemos lo siguiente:

$ scp archivo.txt usuario@dominio.com:/home/usuario // Se especifica el archivo a copiar, luego el servidor y luego el directorio 
en el servidor donde copiaremos el archivo.

##### COPIAR ARCHIVOS DE SERVIDOR A LOCAL #####

Si queremos copiar el fichero archivo.txt del servidor a nuestro ordenador en la carpeta Documentos, hacemos lo siguiente:

$ scp usuario@dominio.com:/home/usuario/archivo.txt /home/usuario/Documentos // Especificamos el servidor, luego la ruta y el archivo a copiar y luego el directorio local donde sera copiado el archivo.

##### COPIAR ARCHIVOS DE SERVIDOR A SERVIDOR #####

$ scp usuario1@dominio1.com:/home/usuario1/archivo.txt usuario2@dominio2.com:/home/usuario2/

###### COPIAR UN DIRECTORIO COMPLETO DE LOCAL A SERVIDOR #####

Para copiar un directorio completo de mi ordenador al servidor, por ejemplo /home/mario/carpeta a /home/usuario, añadimos un -r en el comando:

$ scp -r /home/mario/carpeta usuario@dominio.com:/home/usuario

$ scp -r /home/mario/carpeta usuario@dominio.com: // Con los dos puntos al final se copiara automáticamente en el home del usuario.

##### COPIAR UN DIRECTORIO COMPLETO DE SERVIDOR A LOCAL #####

Para copiar un directorio completo del servidor al local, por ejemplo /home/usuario/carpeta a /home/user/docs, añadimos un -r en el comando:

$ scp -r usuario@dominio.com:/home/usuario/carpeta /home/user/docs

---

user$ scp x.txt 192.168.200.x // Si el servidor tiene el mismo usuario "user" en este caso, no hace falta especificarlo, solamente con la ip del servidor basta, pues toma el nombre del usuario del host para hacer la conexión y posterior copia.

###################
##### sshpass #####
###################

Nos permite enviar el password de SSH en la misma línea con el paquete sshpass, ejemplo:

$ sshpass -p «PASSWORD» ssh root@servidor

$ sshpass -p 123456 ssh user@192.168.1.200 // Accedemos remotamente a ese servidor, si la contraseña coincide no debería pedir mas nada, y despliega el prompt del servidor.

####################################################################
##### Conexion por nautilus explorador de archivos/directorios #####
####################################################################

Usando el navegador de archivos de Debian, Ubuntu, etc, podemos acceder a ordenador remoto "servidor" para ver graficamente 
los directorios, es decir, desde nuestro navegador de archivos, navegaremos en los directorios del servidor, para acceder vamos a:

$ nautilus

Archivo > Conectar con el servidor // Nos saldrá una ventana para llenar con:

Servidor: 192.168.12.400 // Aqui va la ip del servidor
Puerto: 22 // El puerto que tiene habilitado el ssh_config
Tipo: SSH
Carpeta: /home // Carpeta que abrira al entrar en conexion
Nombre de usuario: // Nombre de usuario, de sesion de ese servidor
Contraseña: // Contraseña de la sesion de usuario del servidor

Si todo esta bien deberia entrar a explorar los directorios del servidor.

###################################
##### Crear alias de comandos #####
###################################

Un alias es una palabra o frase que se asignara para 
remplazar un comando, por lo generalmente se usa para
remplazar comandos muy largos y dificiles de recordar
por lo que es una gran ventaja la creacion de alias.

Un alias Se pueden crear temporalmente, directamente en la consola
y durara hasta que cerremos ese shell, tambien asignar permanentemente
escribiendolo en el archivo .bashrc que esta en el /home 

$ alias nombre_alias='comando'

Ejemplo:
$ alias sa='aptitude search apache | grep rt4' // (sa) ahora es el alias de 
ese comando de busqueda en los repositorios de un paquete especifico.

$ unalias nombre_alias // Para eliminar el alias creado temporalmente

Otros ejemplos:

# some more ls aliases
alias ll='ls -l --color'
alias buscar='grep --color -n -Ir'

// Para que se haga efectivo algun cambio en .bashrc es necesario reiniciar
pero hay otra forma de actualizar el fichero sin reiniciar, entonces:

$ source .bashrc // Bastara para que se apliquen los cambios hechos

// Mensaje de bienvenida al usuario

Pegamos esto al final del .bashrc, reiniciamos el fichero
y ahora cada vez que iniciemos un shell nos saludará.

## Mensaje al iniciar
echo "Hola Usuario"

########################################################
### Saber la direccion ip de una pagina o un sevidor ###
########################################################

user@debian:~$ nslookup google.com // Saber la de google por ejemplo
Non-authoritative answer:
Name:   google.com
Address: 216.58.192.110 // Direccion ip de google

--- Otra forma ---

$ ping google.com // Haciendo ping al una pagina 
PING google.com (216.58.192.110) 56(84) bytes of data.
64 bytes from mia07s35-in-f14.1e100.net (216.58.192.110): icmp_req=1 ttl=49 time=69.6 ms // Ip de google
64 bytes from mia07s35-in-f14.1e100.net (216.58.192.110): icmp_req=2 ttl=49 time=70.4 ms

--- google.com ping statistics ---
3 packets transmitted, 2 received, 33% packet loss, time 2001ms
rtt min/avg/max/mdev = 69.645665/70.00475/470.48645/0.010 ms

########################################
##### Compilar e instalar paquetes #####
########################################

$ aptitude search build-essential // Este paquete es esencial para crear y manejar paquetes debian,
por consiguiente para la creación, compilacion e instalación de programas en debian, ubuntu etc.
Tambien se instala cuando se va a desarrollar con c y c++ puesto que la instalacion incluye
los compiladores y las librerias necesarias para comenzar a trabajar en estos lenguajes.

Descargámos el código fuente del programa que queremos compilar e instalar.
Normalmente lo encontraremos en un archivo comprimido, con extensión tar.bz2. 
Así que tendrás que descomprimirlo escribiendo en la consola:

$ tar xvzf paquete.tar.gz (o ver sección de Comprimir/Descomprimir archivos arriba)

//Ahora vamos al directorio donde hemos extraído el contenido del paquete:
$ cd path_del_paquete

// Confguramos el modo de compilación con:
./configure

Luego escribimos:
make

Y finalmente, instalamos con:
make install

// Si no hay errores ya deberíamos poder usar el programa instalado.

########################################
##### Cambiar permisos de usuarios #####
########################################

Al ver los permisos de los ficehros o directorios nos encontramos con varios parametros:

En la primera columna se pueden ver una serie de letras y guiones (-rwxr-x---)
estas letras nos dicen quien en el sistema, y que clases de permisos tiene el fichero o carpeta.

Estas letras están agrupadas en tres grupos con tres posiciones cada uno
más una primera posición que nos dice de que clase de archivo se trata
(los mas normales (d) directorios, o (-) archivos de datos).

El primer grupo de tres (rwx en nuestro caso) nos dice que clase de permisos tiene el dueño del fichero (u)(user/owner)
El segundo grupo de tres (r-x en nuestro caso) nos dice que clase de permisos tiene el grupo del fichero (g)(group).
Y el último grupo de tres (--- en nuestro caso) nos dice que clase de permisos tienen todos los demás usuarios del sistema sobre este
fichero (o)(others).

r :significa permiso para leer 
w :significa permiso para escribir  
x :significa permiso para ejecutar

u :permisos para el usuario/dueño del fichero/directorio
g :permisos de grupos
o :permisos de los demás usuarios

Los permisos se pueden especificar de diferentes maneras, una serie de ejemplos, es lo mejor para comprenderlo:

chmod ugo+rwx (da permisos rwx a todos, user,group,others)
chmod ugo-x test (quita permiso x (ejecucion) a todos, user,group,others) 
chmod o-rwx test (quita permisos rwx a others) 
chmod u=rwx,g=rx (da permisos rwx a user, rx a group y ninguno a others)

chmod -R u=rwx,g=rx,o=rx /dir/dir2/dir3 // Ejemplo de como otorgar permisos a un directorio específico, estos serían los permisos
predeterminados o por defecto de un directorio.

##### chmod en octal ######

Representación octal de chmod

Lectura tiene el valor de 4
Escritura tiene el valor de 2
Ejecución tiene el valor de 1

Entonces:

rwx |  7  | Lectura, escritura y ejecución
rw- |  6  | Lectura, escritura
r-x |  5  | Lectura y ejecución
r-- |  4  | Lectura
-wx |  3  | Escritura y ejecución
-w- |  2  | Escritura
--x |  1  | Ejecución
--- |  0  | Sin permisos

Por lo tanto:

chmod u=rwx,g=rwx,o=rx  | chmod 775 |
chmod u=rwx,g=rx,o=     | chmod 760 |
chmod u=rw,g=r,o=r      | chmod 644 |
chmod u=rw,g=r,o=       | chmod 640 |
chmod u=rw,go=          | chmod 600 |
chmod u=rwx,go=         | chmod 700 |

#################
##### chown #####
#################

Permite modificar a los usuarios o grupos dueños de un archivo o carpeta en el sistema de archivos.

$ chown usuario archivo/carpeta

$ chown -R usuario archivo/carpeta

$ chown usuario *

# chown -R root archivo/carpeta

#################################################################################
##### Cifrado de ficheros gpg, cifrado simétrico, asimétrico, firma digital #####
#################################################################################

$ aptitude search gnupg // Revisar si está instalado gnupg

##### ¿Qué es GnuPG? (GNU Privacy Guard) #####

Es un derivado libre de PGP y su utilidad es la de cifrar y firmar digitalmente, siendo además
multiplataforma (podéis descargarlo desde la página oficial) aunque viene incorporado en algunos
sistemas Linux, como en Ubuntu o Debian.

GnuPG es una herramienta de GNU para la comunicación y el almacenamiento de datos de manera segura. Se puede utilizar para
cifrar datos y para crear firmas digitales. Incluye capacidad avanzada de gestión de claves y cumple con el estándar de
Internet OpenPGP propuesto tal como se describe en el RFC 4880. 

##### Anillo de claves #####

GPG tiene un repositorio de claves (anillo de claves) donde guarda todas las que tenemos almacenadas en nuestro sistema,
ya sean privadas o públicas (como comenté, con la clave pública cifraremos un mensaje que solo podrá descifrar el
que posee la clave privada).

Más adelante cuando veamos un anillo de claves debemos de recordar que pub hace referencia a la clave pública y sub hace referencia
a la privada (y que tenemos que tener a buen recaudo).

##### Servidores de claves #####

Para que nos cifren un mensaje tenemos que compartir la clave pública de nuestro par de claves para cifrar, y como es un poco
engorroso difundir una clave a muchas personas existen los servidores de claves PGP (compatibles con GPG), donde subiré una
clave pública para el que quiera probar los ejemplos. Unos ejemplos de servidores son estos: pgp.rediris.es (español, aunque falla algunas veces)
o pgp.mit.edu (americano, del MIT y a mi no me ha dado problemas).

##### El cifrado simétrico y asimétrico #####

-En el cifrado simétrico, ciframos el archivo con una clave X
Para descifrarlo y obtener el archivo original, utilizamos la misma clave X.

-El cifrado asimétrico es más complicado. Aquí no tenemos una sola clave común. En su lugar
cada persona tiene dos claves, una pública y una privada. Para enviarle un archivo a un amigo
lo cifras con su clave pública. De esta forma, sólo lo puede descifrar él con su clave privada.
Es más seguro que el cifrado simétrico, ya que la clave de descifrado (la privada) nunca se
comparte, siempre la tiene el receptor.

Ejemplo: Sabiendo lo anterior, si queremos que tres compañeros de trabajo nos manden un archivo
cifrado debemos de mandarle nuestra clave pública (que está vinculada a la privada) y nos
podrán mandar de forma confidencial ese archivo que solo nosotros podremos
descifrar con la clave privada.

##### Cifrado simétrico #####

El cifrado simétrico es el tipo de cifrado más sencillo que hay, es más rápido de procesar y por desgracia
menos seguro que el cifrado asimétrico.

Crear un fichero cualquiera de ejemplo

$ touch prueba.txt

Dentro del fichero copiaremos algún texto de prueba para comprobar luego con el descifrado.

Luego en el shell escribimos el comando gpg con el parámetro -c para cifrar y -d para descifrar.

##### Parámetros básicos de gpg #####

-c // Encrypt with a symmetric cipher using a passphrase. The default symmetric cipher used is CAST5,

-d // Decrypt the file given on the command line

$ gpg -c prueba.txt // El comando gpg -c nombre_fichero nos aparecerá un cuadro que nos pide la contraseña
luego una confirmacion de la misma, luego  generará un archivo .gpg

Para descifrarlo usamos el comando gpg -d notas.txt.gpg introduciendo la contraseña correcta para poder decifrarlo.

$ gpg -d prueba.txt.gpg // Descifrar el fichero, nos permitira mirar el contenido.

$ man gpg // Ver el Manual de gpg

##### Cifrado asimétrico #####

*** Generar las claves ***

Para poder cifrar asimétricamente primero tenemos que crear la pareja de claves
(pública y privada) con el comando gpg --gen-key

$ gpg --gen-key
gpg (GnuPG) 1.4.12; Copyright (C) 2012 Free Software Foundation, Inc.
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.

Por favor seleccione tipo de clave deseado:
(1) RSA and RSA (default)
(2) DSA and Elgamal
(3) DSA (sólo firmar)
(4) RSA (sólo firmar)
Su elección:

// GPG nos permite elegir el tipo de clave que queremos usar, hay opciones que solo permiten firmar
y otras que permiten firmar y cifrar, en este caso usaremos DSA y Elgamal.

las claves DSA pueden tener entre 1024 y 3072 bits de longitud.
¿De qué tamaño quiere la clave? (2048)

Nos pedirá el tamaño de la clave que puede variar entre 1024 bits y 3072, esto es de libre elección,
tomarémos el que propone por defecto (2048).

Nos pide la fecha en la que expirará la clave, la información del emisor de la clave
(nombre, mail y algunos datos extra que queramos dar) y por último nos pedirá la
contraseña que salvaguarda la clave privada.

Tras generar las claves podemos verlas con el comando gpg -k que nos muestra nuestro
anillo de claves, lo importante de este paso es que veremos la identificación de cada una
que es necesaria para poderlas exportar y enviar.

$ gpg -k // Visualizar anillo de claves

/home/user/.gnupg/pubring.gpg
--------------------------------

pub   1559C/88651986 2017-01-01
uid                  username_lastname (Enunciado de la clave) <username@email.com>
sub   2048g/55GD33FG 2017-01-01

##### Exportar y enviar la clave pública #####

El objetivo de esta pareja de claves es que cualquiera nos pueda mandar un archivo cifrado
que solo veremos nosotros y esto se hace difundiendo la clave pública que acabamos de crear
(la pública, nunca la privada), para exportarla en un archivo usaremos el comando:

$ gpg -output [archivo destino] --export [ID de a clave pública] (la clave pública generada antes tiene la ID 88651986).

$ gpg --output ClavePublica_username.gpg --export 88651986

$ ls
ClavePublica_username.gpg // Fichero generado que contiene la clave pública

Este archivo ahora se puede difundir por el medio que queramos.

##### Subir una clave pública a un servidor de claves #####

Los servidores de claves suelen ser de acceso público (al no haber mucho problema por difundir una clave pública) y en este caso
subiremos una clave a los servidores del MIT (pgp.mit.edu) usando el comando:

$ gpg --send-keys --keyserver [Dirección del servidor] [ID de la clave pública] (al igual que antes la ID es 88651986).

$ gpg --send-keys --keyserver pgp.mit.edu 88651986

Entramos a --> https://pgp.mit.edu/ y buscamos nuestra clave pública por El Nombre y Apellido que añadimos cuando la estuvimos creando.

##### Importar la clave desde el archivo o servidor de claves #####

Para poder usar la clave pública para cifrar o comprobar la identidad del remitente tenemos que importar previamente la clave, desde un archivo
debemos de usar el comando gpg --import [Archivo de la clave pública]

$ gpg --import CPub.gpg 

Al tener la clave ya en mi anillo de claves me contesta que no hay cambios.

Para realizar la importación desde el servidor tenemos que usar el comando

$ gpg --keyserver [Dirección del servidor] --recv-keys [ID de la clave]

$ gpg --keyserver pgp.mit.edu --recv-keys 5616846865

##### Borrar una clave de mi anillo de claves #####

$ gpg --delete-keys id_key // Pasamos el id de la clave que queremos borrar.

##### Cifrar un fichero #####

$ vim x.txt // Creamos el fichero, lo llenamos con algo de texto para la prueba, lo guardamos.

gpg --encrypt --recipient [ID de la clave] [Archivo] // Cifrar con una clave pública.

gpg --encrypt --recipient 88651986 x.txt // Ciframos el fichero con la clave publica creada para la prueba.

Nos creará un fichero: x.txt.gpg // Fichero cifrado con la clave pública

##### Descifrar un archivo con la clave privada #####

$ gpg -d [Archivo] e introduciendo la contraseña que creamos para salvaguardar la clave privada.

$ gpg -d x.txt.gpg

Nos mostrará

Necesita una frase contraseña para desbloquear la clave secreta
del usuario: "Name_user Last_name (comment) <mail@mail.xxx>"
clave RSA de 2048 bits, ID 88651986, creada el 201x-xx-xx(ID de clave primaria 5F829889)

Introduzca frase contraseña:

---

La contraseña es la clave privada, la cual solo tendremos nosotros y nunca compartiremos, pues es la que nos permite descifrar los ficheros
que fueron cifrados con nuestra clave publica.

##### Firmar archivos #####

Una de las medidas de seguridad básicas al pasar un mensaje o fichero es asegurarnos que el emisor es quien dice ser, para asegurarnos de esto
digitalmente existe la firma digital, podemos cifrar y a su vez firmar ficheros, que es lo que haremos con el comando:

$ gpg -u [ID de la clave] --output [Archivo resultante] --sign [Archivo para firmar]

...e introduciendo la contraseña de la clave privada.

$ gpg -u 88651986 --output x_firmado.txt.gpg --sign x.txt

...

Necesita una frase contraseña para desbloquear la clave secreta
del usuario: "xxx xxx (xx) <mail@mail.xxx>"
clave RSA de 2048 bits, ID 88651986, creada el 201x-xx-xx

Introduzca frase contraseña: 

...

nos generará el fichero:

x_firmado.txt.gpg

##### Verificar y descifrar un archivo firmado #####

Cualquiera con la clave pública asociada a la que ha firmado el documento puede leerlo, de la misma forma que desciframos un archivo
(gpg -d [Archivo]) o verificándolo únicamente con el comando gpg --verify [Archivo].

$ gpg --verify x_firmado.txt.gpg 

muestra...

gpg: Firmado el xxx xx xx 201x xx:xx:xx VET usando clave RSA ID 88651986
gpg: Firma correcta de "User_name Last_name (comment) <user@mail.xxx>"

##### Exportar la clave privada #####

Si queremos verificar o firmar desde otro equipo con nuestra clave privada tenemos que tener nuestra clave privada
en ese equipo, para eso es necesario copiar el directorio .gnupg que está en el /home/user de la máquina en la cual
creamos la clave privada a la nueva máquina.

#####################################
##### Configurar sudo en Debian #####
#####################################

En Debian no viene instalado y configurado por defecto.

$ aptitude install sudo

Una vez con el sudo instalado deberemos agregar nuestro usuario en la sección "User privilege specification"
en el archivo /etc/sudoers, de tal forma que la sección quede así:

User privilege specification
root ALL=(ALL) ALL
tu_usuario ALL=(ALL) ALL

Una vez configurado esto, ya podremos ejecutar acciones de administrador desde una terminal común, anteponiendo el sudo a la acción a realizar.

###################################################################
##### Lista de fuentes de los paquetes de debian sources.list #####
###################################################################

----- Apt -----

Apt (Advanced Package Tool) es un set de herramientas del núcleo de Debian. Apt hace posible:
instalar, eliminar, mantener sus aplicaciones al día y mucho más... 

Apt, que basicamente resuelve problemas de dependencias y busca los paquetes solicitados, trabaja con dpkg, otra herramienta
que maneja la instalación y eliminación de paquetes (aplicaciones). Apt es muy poderoso, y se usa frecuentemente desde la línea
de comandos o consola/terminal. Sin embargo, hay muchas herramientas GUI/Gráficas para ayudarle a usar Apt sin tener
que tocar la línea de comando.

Al presente, aptitude es la herramienta recomendada para interactuar con la suite APT. Las herramientas APT deben ser usadas
especificamente para manejar acciones que no puedan ser manejadas por aptitude, o dónde se necesite mayor control de las dependencias. 

/etc/apt/sources.list // APT utiliza un archivo que enlista las "fuentes" en donde se encuentran los paquetes. Este archivo es: /etc/apt/sources.list

El contenido de este archivo, normalmente sigue este formato:
deb http://host/debian distribución sección1 sección2 sección3
deb-src http://host/debian distribución sección1 sección2 sección3

Los renglones arriba mencionados son ficticios y no deberán ser usados. La primera palabra en cada línea, deb o deb-src, indican
el tipo del archivo: ya sea que contenga paquetes binarios (deb), esto es, los paquetes pre-compilados que normalmente se usan
o los paquetes fuente (deb-src), que son los códigos originales, más el archivo de control de Debian (.dsc) y el diff.gz que
contienen los cambios necesarios para "debianizar" el programa.

Generalmente se encuentra lo siguiente por defecto en el archivo sources.list:

# See sources.list(5) for more information, especialy
# Remember that you can only use http, ftp or file URIs
# CDROMs are managed through the apt-cdrom tool.
deb http://http.us.debian.org/debian stable main contrib non-free
deb http://non-us.debian.org/debian-non-US stable/non-US main contrib non-free
deb http://security.debian.org stable/updates main contrib non-free

# Uncomment if you want the apt-get source function to work
#deb-src http://http.us.debian.org/debian stable main contrib non-free
#deb-src http://non-us.debian.org/debian-non-US stable/non-US main contrib non-free

Éstas son las líneas necesarias para una instalación básica de Debian. La primer línea deb apunta al archivo en el servidor oficial
la segunda línea apunta hacia el archivo del servidor non-US y la tercera línea apunta hacia el archivo del servidor de
actualizaciones de seguridad.

Las dos últimas líneas están deshabilitadas (con un "#" al inicio), así que apt-get las ignora. Éstas son las líneas de deb-src
esto es, apuntan hacia los paquetes fuente de Debian. Si frecuentemente descarga paquetes fuente para probar o recompilar
habilítelas (borrando el "#" al inicio de la línea).

El archivo /etc/apt/sources.list puede contener varios tipos de líneas. APT sabe como interpretar líneas del tipo http,
ftp, file (archivos locales, p.e., un directorio que contiene un CD-ROM) y ssh, según mis conocimientos.

No olvide ejecutar el comando apt-get update después de modificar el archivo /etc/apt/sources.list. Debe hacer
esto para permitir a APT obtener la lista de paquetes de las fuentes que especificó.

#################################################
##### Enlaces físicos y simbólicos en Linux #####
#################################################

##### Enlaces físicos #####

Un enlace físico no es más que una etiqueta o un nuevo nombre asociado a un archivo. Es una forma de identificar el mismo
contenido con diferentes nombres. Éste enlace no es una copia separada del archivo anterior sino un nombre diferente
para exactamente el mismo contenido.

$ ln archivo.txt nuevo_nombre.txt // Para crear un enlace físico en Linux del archivo archivo.txt a nuevo_nombre.txt

El enlace aparecerá como otro archivo más en el directorio y apuntará al mismo contenido de archivo.txt.
Cualquier cambio que se haga se reflejará de la misma manera tanto para archivo.txt como para nuevo_nombre.txt.

Un enlace se puede borrar usando el comando rm de la misma manera en que se borra un archivo, sin embargo el contenido del
iniodo no se eliminará mientras haya un enlace físico que le haga referencia. Esto puede tener varias ventajas, pero también
puede complicar la tarea de seguimiento de los archivos.

Un enlace físico tampoco puede usarse para hacer referencia a directorios o a archivos en otros equipos.

##### Enlaces simbólicos #####

Un enlace simbólico también puede definirse como una etiqueta o un nuevo nombre asociado a un archivo pero a diferencia de los enlaces físicos
el enlace simbólico no contiene los datos del archivo, simplemente apunta al registro del sistema de archivos donde se encuentran los datos.
Tiene mucha similitud a un acceso directo en guindows o un alias en OS X.

// Situados en "b" crearemos un enlace simbólico del fichero x.txt que está en la carpeta "a".
b$ ln -s ../a/x.txt

Éste enlace también aparecerá como otro archivo más en el directorio y apuntará al mismo contenido de archivo.txt, reflejando todos los cambios
que se hagan tanto para archivo.txt como para nuevo_nombre.txt.

Sobre un enlace simbólico también se pueden usar todos los comandos básicos de archivos (rm, mv, cp, etc). sin embargo cuando el archivo original
es borrado o movido a una ubicación diferente el enlace dejará de funcionar y se dice que el enlace está roto.

Un enlace simbólico permite enlazar directorios y, usando NFS, también permite enlazar archivos fuera del equipo.

########################
##### jaula chroot #####
########################

Con los programas chroot y debootstrap, es posible configurar un sistema Debian aislado en el cual poder entrar
y hacer pruebas, sin temor alguno a destruir su sistema principal.

Definimos un directorio en la raíz del sistema donde se ejecutará el sistema enjaulado, en este ejemplo lo mostrare para
debían Wheezy pero siguiendo la misma secuencia y sustituyendo adecuadamente se puede instalar cualquier versión de debían.

$ sudo mkdir /home/user/jaulas/wheezy

Instalamos la aplicación necesaria para ejecutar la jaula:

$ sudo apt-get install debootstrap

Creamos la jaula 

$ sudo debootstrap wheezy /home/user/jaulas/wheezy http://ftp.us.debian.org/debian/

o usamos un repo local o mas cercano para que las descarga de los ficheros sea mas rápida

$ sudo debootstrap wheezy /home/user/jaulas/wheezy http://debian.cenditel/debian/

Cuando termine, dependiendo de la velocidad de descarga, habrá creado todo el sistema básico para correr
debían wheezy en el directorio definido.

Antes de ejecutar la jaula se deben montar algunos directorios:

$ sudo mount -o bind /proc /home/user/jaulas/wheezy/proc 

Si senecesita conexión a periféricos como un módem usb o una impresora estos se guardan en el directorio /dev/
por ende tambien se debe montar.

$ sudo mount -o bind /dev/ /home/user/jaulas/wheezy/dev/ 

$ sudo mount -o bind /dev/pts/ /home/user/jaulas/wheezy/dev/pts/

$ sudo mount -o bind /sys/ /home/user/jaulas/wheezy/sys/ 

o creamos un script para montar los directorios, creamos el script: montar.sh

---

#!/bin/bash
mount -o bind /proc /home/user/jaulas/wheezy/proc
mount -o bind /dev/ /home/user/jaulas/wheezy/dev/
mount -o bind /dev/pts/ /home/user/jaulas/wheezy/dev/pts/
mount -o bind /sys/ /home/user/jaulas/wheezy/sys/

---

y lo ejecutamos con:

# ./montar.sh

Para desmontar por alguna razón (borrar la jaula por ejemplo), creamos un desmontar.sh:

---

#!/bin/bash
umount /home/user/jaulas/wheezy/proc
umount /home/user/jaulas/wheezy/dev/
umount /home/user/jaulas/wheezy/dev/pts/
umount /home/user/jaulas/wheezy/sys/

---

# ./desmontar

A partir de este momento ya tienes el sistema listo y puedes hacer cualquier tipo de prueba sin que corra riesgo
tu sistema base para salir de la jaula y continuar con tu sistema solo debes ejecutar:

# exit

// Para accecer a la jaula o ejecutarla debes ser usuario root o usar sudo
# chroot /home/user/jaulas/wheezy

##### Nota #####
Este sistema solo puede ejecutar aplicaciones en el terminal si se requiere interfaz gráfica se debe utilizar una
aplicación como Xnest que su utilización te detallo a continuación:

$ sudo apt-get xnest

Ejecución:

En terminal 1 ejecutas 

$ Xnest -ac -geometry 800x600 :1 

en un segundo terminal inicias la jaula 

# sudo chroot /jaulas/wheezy 

y dentro de la jaula ejecutas 

# export DISPLAY=localhost:1 

En este momento toda aplicación que ejecutes en dicha jaula que posea interfaz gráfica se mostrara en la pantalla
mostrada por Xnest adicionalmente cabe destacar que puedes colocar cualquier geometria de ventana al ejecutar xnest 

- Cada ves que reinicies la pc debes volver a montar los directorios /proc, /dev/pts y /dev, esto lo puedes automatizar
agregando las siguientes siguientes lineas en el archivo /etc/fstab o corriendo un script con esas sentencias.

/proc      /home/user/jaulas/wheezy/proc/        auto     bind 0       0
/dev       /home/user/jaulas/wheezy/dev/pts/     auto     bind 0       0
/dev/pts   /home/user/jaulas/wheezy/dev/pts/     auto     bind 0       0
/sys       /home/aosorio/jaulas/wheezy/sys/      auto     bind 0       0

Descargamos los paquetes locales y locales-all y ejecutamos:

$ dpkg-reconfigure locales 

Escogemos las configuraciones regionales que desea generar:

es_VE.UTF-8 UTF-8

Configuración regional predeterminada para el entorno del sistema:
es_VE.UTF-8

Listo, jaula de wheezy lista!

##### Remover un entorno chroot #####

Desmontar los directorios montados y borrar el directorio de que alverga la jaulea (wheezzy)

####################################################################
##### codecs de audio y video para GNU/Linux Debian 7 (Wheezy) #####
####################################################################

# apt-get install ffmpeg flashplugin-nonfree libcurl3 freepats gstreamer0.10-ffmpeg gstreamer0.10-plugins-bad gstreamer0.10-plugins-ugly  libaccess-bridge-java libcdaudio1 libdc1394-22 libdvdnav4 libfftw3-3 libgif4 libid3tag0 libiptcdata0 libmms0  libmpeg2-4 libneon27-gnutls libofa0 libsidplay1 libsndfile1 libswscale0  openjdk-7-jre openjdk-7-jre-headless openjdk-7-jre-lib rhino ttf-arphic-uming ttf-baekmuk ttf-bengali-fonts ttf-devanagari-fonts ttf-gujarati-fonts ttf-indic-fonts ttf-kannada-fonts ttf-kochi-gothic ttf-liberation ttf-malayalam-fonts ttf-mscorefonts-installer ttf-oriya-fonts ttf-punjabi-fonts ttf-sazanami-mincho ttf-tamil-fonts ttf-telugu-fonts tzdata-java

################################################
##### Ver un fichero .csv desde la consola #####
################################################

Ordenará por columnas, etc...

$ cat file.csv | sed -e 's/,,/, ,/g' | column -s, -t | less -#5 -N -S

#######################################
##### Rutas relativas y absolutas #####
#######################################

- Una ruta o path es donde se localiza una carpeta o fichero dentro de nuestro sistema de ficheros.
- Todos los comandos que se ejecuten sin especificar una ruta lo hará donde este situado.
- Hay dos tipos de ruta que debemos diferenciar:

***Ruta absoluta: Se indica toda la ruta del fichero incluyendo el directorio raíz. Por ejemplo:

/home/user/folder/file.txt

***Ruta relativa: Se indica la ruta a partir de donde este en ese momento situado. No se incluye el directorio raíz. Por ejemplo, si estamos en la
ruta /home/user y queremos acceder al file.txt que esta dentro de folder, seria:

folder/file.txt

###############################
##### Variables de entorno ####
###############################

Las variables de entorno contienen información a la que se accede a través del nombre de la
variable (al igual que ocurre en los lenguajes de programación).

Por ejemplo, PWD es una variable de entorno. Algo que puedo comprobar así:

$ echo $PWD
/home/user

(lo que significa que el comando "pwd" es una llamada a "echo $PWD"

// Consultar todas mis variables de entorno.
$ env
$ printenv

// Crear una variable de entorno
$ export name_var=Value

// Eliminar una variable de entorno
$ export name_var=

########################
##### Terminal tty #####
########################

tty es la consola que nos permite en GNU/Linux acceder a nuestro sistema operativo fuera de su entorno gráfico (X-Window).
En general disponemos de hasta seis terminales, para acceder:

Ctrl + Alt + F1 para acceder a la primera, F2 para la segunda y así hasta F6 para la sexta y F7 para volver al entorno gráfico.

No debemos confundir las consolas tty con la que habitualmente usamos sobre el entorno gráfico X-Window.

###################
##### tasksel #####
###################

El paquete Tasksel proporciona una interfaz sencilla para los usuarios que quieren configurar su sistema para realizar una tarea específica. Este programa es utilizado durante el proceso de instalación, pero los usuarios puede usarlo también en cualquier momento.

##### Entorno de escritorio #####

Después de instalar un sistema básico, usted puede instalar el DesktopEnvironment utilizando tasksel. La orden tasksel (ingresado como root) le muestra algunas opciones (de alto nivel de abstraccion) para instalar paquetes. Podría usted simplemente marcar la opción Desktop environment. Instalará los paquetes de Gnome y algunos paquetes considerados como estándar para un escritorio Debian.

################
##### dhcp #####
################

DHCP (siglas en inglés de Dynamic Host Configuration Protocol, en español «protocolo de configuración dinámica de host») es un servidor
que usa protocolo de red de tipo cliente/servidor en el que generalmente un servidor posee una lista de direcciones IP dinámicas y las
va asignando a los clientes conforme éstas van quedando libres, sabiendo en todo momento quién ha estado en posesión de esa IP, cuánto
tiempo la ha tenido y a quién se la ha asignado después. Así los clientes de una red IP pueden conseguir sus parámetros de configuración
automáticamente.

##### Asignación de direcciones IP #####

Cada dirección IP debe configurarse manualmente en cada dispositivo y, si el dispositivo se mueve a otra subred, se debe configurar otra
dirección IP diferente. El DHCP le permite al administrador supervisar y distribuir de forma centralizada las direcciones IP necesarias
y, automáticamente, asignar y enviar una nueva IP si fuera el caso en que el dispositivo es conectado en un lugar diferente de la red.

El protocolo DHCP incluye tres métodos de asignación de direcciones IP:

// Asignación manual o estática
Asigna una dirección IP a una máquina determinada. Se suele utilizar cuando se quiere controlar la asignación
de dirección IP a cada cliente, y evitar, también, que se conecten clientes no identificados.

// Asignación automática
Asigna una dirección IP a una máquina cliente la primera vez que hace la solicitud al servidor DHCP y hasta que
el cliente la libera. Se suele utilizar cuando el número de clientes no varía demasiado.

// Asignación dinámica
El único método que permite la reutilización dinámica de las direcciones IP. El administrador de la red determina un
rango de direcciones IP y cada dispositivo conectado a la red está configurado para solicitar su dirección IP al servidor
cuando la tarjeta de interfaz de red se inicializa. El procedimiento usa un concepto muy simple en un intervalo de tiempo
controlable. Esto facilita la instalación de nuevas máquinas clientes.

Algunas implementaciones de DHCP pueden actualizar el DNS asociado con los servidores para reflejar las nuevas direcciones IP
mediante el protocolo de actualización de DNS establecido en RFC 2136 (Inglés).

El DHCP es una alternativa a otros protocolos de gestión de direcciones IP de red, como el BOOTP (Bootstrap Protocol). DHCP es un
protocolo más avanzado, pero ambos son los usados normalmente.

########################################################################################
##### Restaurar o reiniciar las conexiones de red del sistema - networking restart #####
########################################################################################

# /etc/init.d/networking restart

# service networking restart

# invoke-rc.d networking restart

#### Para maquinas virtuales #####

Cuando se va a conectar por wireless, para que el dhcp le asigne una dirección ip
modificamos el fichero:

/etc/network/interfaces

Y quedará así:

# This file describes the network interfaces available on your system
# and how to activate them. For more information, see interfaces(5).

source /etc/network/interfaces.d/*

# The loopback network interface
#auto lo
#iface lo inet loopback
auto eth0
iface eth0 inet dhcp

---

Guardamos y reiniciamos las interfaces de redes con los tres comandos de arriba, esto
es para cuando una máquina virtual no agarra internet inalambrico, tambien debe estar
habilitada el adaptador de conexión inalambrica en el panel de configuración de la maquina virtual.
Dentro de la máquina virtual parecerá que esta conectado por cable.# The loopback network interface

Cuando se instala el SO y no consigue ninguna red cableada, es posible que el router/DHCP no le haya
asignado una dirección ip, entonces modificamos el mismo fichero para que quede así:

auto lo
iface lo inet loopback
auto eth0
iface eth0 inet dhcp

Y reiniciamos las interfaces de red, con suerte obtendremos una dirección ip de la red.

Podemos intentar un ifup para ver si el dhcp le asigna la dirección ip sin necesidad de reiniciar la maquina o las
interfaces de red:

# ifup eth0

Luego # ip addr a ver si ya tiene ip, si no es así entonces reiniciaremos las conexiones de red del sistema con los comandos descritos arriba.

################################################################################
##### Restaurar o reiniciar las conexiones de red inalambrica del sistema #####
################################################################################

If you really want to reset the network adapter you usually need to unload and reload the kernel module that it uses.

If you just want to reconfigure it you can usually do:

# /etc/init.d/network-manager restart

But if you just want a new dhcp lease (that's the technical name for obtain a new IP from the router), you just need to use:

# dhclient -v eth1

##################################
##### Configuración del grub #####
##################################

Fichero de configuración donde se define el tiempo de espera del grup para mostrar
la lista de SO disponibles y sus opciones.

/etc/default/grub

#################################################
##### w3m - Nnavegador web desde la consola #####
#################################################

w3m es un navegador web basados en texto/paginador.

# apt-get install w3m

$ w3m https://www.debian.org // Para iniciar el navegador en modo interactivo

$ w3m https://www.debian.org -dump // Volcado de una página con formato de salida estándar

##### Atajos de teclado en modo interactivo #####

Salir del navegador: q
Página anterior: B
Descargar página actual: a
Ir a inicio: g
Saltar al final: G
Desplazarse hacia arriba una página: -
Desplazarse hacia abajo una página: +
Abrir URL: U

#####################################################
##### apg - generador automático de contraseñas #####
#####################################################

apg (Automatic Password Generator)

// Instalación
# apt-get install apg

Apg es capaz de generar un listado de contraseñas.

Usa un algoritmo para generar contraseñas pronunciables e inpronunciables
también permite generar contraseñas aleatorias definidas a partir de conjuntos
de símbolos definidos por el usuario (dígitos, letras mayúsculas y minúsculas, y símbolos especiales.)

Por defecto, apg genera 6 contraseñas con caracteres alfanuméricos que además son pronunciables (en inglés)

$ apg

Please enter some random data (only first 16 are significant)
(eg. your old password):>
OrwefdyetEc6 (Or-wef-dyet-Ec-SIX)
9ovCaulvac5 (NINE-ov-Caulv-ac-FIVE)
EryidribMeb7 (Er-yi-drib-Meb-SEVEN)
beoddIcox2 (be-odd-Ic-ox-TWO)
Oamyalirl6 (Oam-yal-irl-SIX)
IgPiham1 (Ig-Pi-ham-ONE)

Ahora generemos 4 contraseñas con una longitud mínima de 8 caracteres, máxima de 12
y que además sean impronunciables, usan el segundo algoritmos:

-n x = Número de contraseñas a generar.
-m x = Mínimo de caractéres que deberá tener la contraseña.
-x x = Máximo de caractéres que deberá tener la contraseña.

$ apg -n 4 -m 8 -x 8 -a 1

// Mínimo 8 máximo 12, incluyendo caractéres especiales
$ apg -n 4 -m 8 -x 12 -a 1

// Mínimo 8 máximo 12, incluyendo caractéres especiales en menor medida
$ apg -n 4 -m 8 -x 12 -a 0

###############################
##### Herramientas de red #####
###############################

$ ifconfig // Siendo root, permite desplegar numerosos parámetros de las interfaces de red residentes  en el núcleo,
como la dirección ip (dinámica o estática), o la máscara de red entre otros.

$ ip addr// Para ver el estatus de las conexiones de red, este comando le mostrará su dirección ip, el tipo de conexión que está utilizando, etc.

$ nmap -sT -O localhost // Ver que puertos estan escuchando 

##### Iproute2 #####

Iproute2 es un paquete de herramientas muy potentes para administrar interfaces de red y conexiones en sistemas Linux.

Este paquete reemplaza completamente las funcionalidades presentes en ifconfig, ya que este no viene instalado por defecto en GNU/Linux Debian 9 Stretch, ya que a ifconfig
se le considera obsoleto.

##### Instalar ifconfig y route en Debian 9 #####

Lo primero que tenemos que hacer es abrir un terminal e instalar el paquete “net-tools”. Si en la instalación hemos elegido hacer “sudo” para ascender a superusuario para instalar paquetes, tecleamos:

# apt-get  install net-tools

##### Comparación de comandos de entre ifconfig e IP #####

// Mostrar dispositivos de red y su configuración.
$ ifconfig

$ ip addr show

ó

$ ip link show

// Activar una interfaz de red.
$ ifconfig eth0 up

$ ip link set eth0 up

// Desactivar una interfaz de red.
$ ifconfig eth0 down

$ ip link set eth0 down

// Establecer una dirección IP a una interfaz.
$ ifconfig eth0 192.168.1.1

$ ip address add 192.168.1.1 dev eth0

// Eliminar una dirección IP de una interfaz.
ifconfig no podrá hacer esto.

$ ip address del 192.168.1.1 dev eth0

// Añadir una interfaz virtual.
$ ifconfig eth0:1 10.0.0.1/8

$ ip addr add 10.0.0.1/8 dev eth0 label eth0:1

// Para configurar una tarjeta de red física, por ejemplo, con ifconfig debemos teclear lo siguiente:
$ ifconfig eth0 192.168.0.2 netmask 255.255.255.0

$ ip addr add 192.168.0.2/24 dev eth0

########################################
##### Actualizar versión de Debian #####
########################################

En este ejemplo actualizaremos de la version 8 a la 9.

1-) Actualizamos el source.list a que apunte a repos de 9 Stretch.

##### CENDITEL mirror - Debian GNU/Linux 9 (Stretch) #####

deb http://debian.cenditel/debian stretch main
deb-src http://debian.cenditel/debian stretch main

deb http://debian.cenditel/debian stretch-updates main
deb-src http://debian.cenditel/debian stretch-updates main

deb http://debian.cenditel/debian-security stretch/updates main
deb-src http://debian.cenditel/debian-security stretch/updates main

2-) Actualizamos la lista de los repositorios:
# apt-get update

3-) Actualizamos los paquetes del sistema, para que instale las versiones de 9 Stretch
# apt-get upgrade

4-) Finalmente actualizamos todo de manera inteligente:
# apt-get dist-upgrade

5-) Reiniciamos el sistema, con eso ya deberíamos estar en GNU/Linux Debian 9 Stretch.
# reboot

Hay que estar pendiente de la consola, porque seguro va a pedir revisión
manual de algunos paquetes, donde te dirá siquieres conservar la versión
y configuración actual, como ssh, vim, postgresql, otros...

################################
##### source.list example  #####
################################

**The format is
deb <respository server/mirror> <repository name> <sub branches of the repo>

#----------------------------------

##### Debian GNU/Linux Testing & Unstable #####

# Testing repository - main, contrib and non-free branches
#deb http://http.us.debian.org/debian testing main non-free contrib
#deb-src http://http.us.debian.org/debian testing main non-free contrib

# Testing security updates repository
#deb http://security.debian.org/ testing/updates main contrib non-free
#deb-src http://security.debian.org/ testing/updates main contrib non-free

# Unstable repo main, contrib and non-free branches, no security updates here
#deb http://http.us.debian.org/debian unstable main non-free contrib
#deb-src http://http.us.debian.org/debian unstable main non-free contrib

#----------------------------------

##### Debian GNU/Linux 9 (Stretch) Updates #####

deb http://security.debian.org/ stretch/updates main contrib non-free
deb-src http://security.debian.org/ stretch/updates main contrib non-free
deb http://ftp.us.debian.org/debian/ stretch main contrib non-free

#----------------------------------

##### Debian GNU/Linux 8 (Jessie) Estable #####

# Repositorio Oficial
deb http://http.us.debian.org/debian/ jessie main contrib non-free
deb-src http://http.us.debian.org/debian/ jessie main contrib non-free
deb http://httpredir.debian.org/debian/ jessie main
deb-src http://httpredir.debian.org/debian/ jessie main

# jessie-updates, previously known as 'volatile'
deb http://httpredir.debian.org/debian/ jessie-updates main
deb-src http://httpredir.debian.org/debian/ jessie-updates main

# Repositorio de Seguridad
deb http://security.debian.org/ jessie/updates main contrib non-free
deb-src http://security.debian.org/ jessie/updates main contrib non-free
deb http://security.debian.org/ jessie/updates main
deb-src http://security.debian.org/ jessie/updates main

#----------------------------------

##### Debian GNU/Linux 7 (Wheezy) Estable #####

#Repositorio Oficial
deb http://ftp.us.debian.org/debian/ wheezy main contrib
deb-src http://ftp.us.debian.org/debian/ wheezy main contrib

#Actualizaciones de Seguridad
deb http://security.debian.org/ wheezy/updates main contrib
deb-src http://security.debian.org/ wheezy/updates main contrib

#Actualizaciones de Wheezy
deb http://ftp.debian.org/debian wheezy-updates main contrib non-free
deb-src http://ftp.debian.org/debian wheezy-updates main contrib non-free

#Backports
deb http://ftp.debian.org/debian/ wheezy-backports main

#----------------------------------

##### Debian GNU/Linux 8 (Jessie) Multimedia repo #####

deb http://www.deb-multimedia.org jessie main non-free
#or
#deb ftp://ftp.deb-multimedia.org jessie main non-free
#or
#deb http://www.deb-multimedia.org stable main non-free
#or
#deb ftp://ftp.deb-multimedia.org stable main non-free

#----------------------------------

##### Debian GNU/Linux 7 (Wheezy) Multimedia repo #####

deb http://www.deb-multimedia.org wheezy main
#or
#deb ftp://ftp.deb-multimedia.org wheezy main
#or
#deb http://www.deb-multimedia.org oldstable main
#or
#deb ftp://ftp.deb-multimedia.org oldstable main

#----------------------------------

##### CENDITEL mirror - Debian GNU/Linux 9 (Stretch) #####

deb http://debian.cenditel/debian stretch main
deb-src http://debian.cenditel/debian stretch main

deb http://debian.cenditel/debian stretch-updates main
deb-src http://debian.cenditel/debian stretch-updates main

deb http://debian.cenditel/debian-security stretch/updates main
deb-src http://debian.cenditel/debian-security stretch/updates main

#----------------------------------

##### CENDITEL mirror - Debian GNU/Linux 8 (Jessie) Estable #####

deb http://debian.cenditel/debian/ jessie main contrib non-free
deb-src http://debian.cenditel/debian/ jessie main contrib non-free

# jessie-updates, previously known as 'volatile'
deb http://debian.cenditel/debian/ jessie-updates main contrib non-free
deb-src http://debian.cenditel/debian/ jessie-updates main contrib non-free

#deb http://repositorio.cenditel.gob.ve/debian/ jessie main contrib non-free
#deb http://tibisay.cenditel.gob.ve/repositorio jessie main contrib non-free

# Agregar la llave del repositorio al sistema, como root escribimos:
# wget -q -O- http://repositorio.cenditel.gob.ve/debian/repositorio_cenditel.asc | apt-key add -

#----------------------------------

##### CENDITEL mirror - Debian GNU/Linux 7 (Wheezy) Estable #####

deb http://debian.cenditel/debian/ wheezy main
deb-src http://debian.cenditel/debian/ wheezy main

# wheezy-updates, previously known as 'volatile'
deb http://debian.cenditel/debian/ wheezy-updates main
deb-src http://debian.cenditel/debian/ wheezy-updates main

##################################
##### Repositorios de Debian #####
##################################

En el siguiente enlace podemos encontrar un espejo
donde poder descargar los paquetes de todas las versiones
de Debian --> http://archive.debian.org/debian/README

O simplemente agregando el repositorio en el source.list, por ejemplo:

#deb http://archive.debian.org/debian/ squeeze main contrib
#deb http://archive.debian.org/debian/ wheezy main contrib
deb http://archive.debian.org/debian/ jessie main contrib

########################################################
##### Recommended installation packages for Debian #####
########################################################

Actualizar el source.list 

# apt-get update

Si da problemas con el fichero dir/dir/lock por ejemplo, lo borramos

# rm -f dir/dir/lock

No se pudo bloquear /var/lib/dpkg/lock - open (11: Recurso no disponible temporalmente)

Solución...

$ sudo fuser -vki  /var/lib/dpkg/lock

luego seguimos con...

##### Programas para el Sistema #####

terminator (Configurar, luego)
vim (Configurarlo)

.bashrc (Configurarlo, alias, etc...)
alias ll='ls -l --color'
alias buscar='grep --color -n -Ir'

sudo (Configurar y Probar)
aptitude (Probar)
ssh (Configurar y Probar)
git (Configurarlo, Probarlo)
vlc player
apache (Probar)
postgresql (Probar)
Virtual Box (Opcional)
Paquete para dar formatos a unidades usb
rsync
meld
audacity

tree // Muestra un árbol de directorios con sangría, en color.

screenfetch // Busca y muestra información sobre el sistema operativo que estemos utilizando, datos
como el tipo de distribución, kernel, entorno de escritorio, windows manager, CPU, themes, RAM, etc… 

#####  Para compilacion y construcción de paquetes #####

build-essential
gcc
dpkg-dev
fakeroot
cmake
devscripts
autoconf
automake
dh-make
debhelper
autotools-dev
gnupg
lintian
quilt
packaging-dev

##### Desarrollo #####

curl
Sublime (Instalar el .deb de la página o buscar en los repos, > a v2.)
python (Probarlo)
python-pip
virtualenv
virtualenvwrapper
python-requests
django (Opcional)
    pip install django-compressor (Opcional)
    pip install south (Opcional)
    pip install django-extensions (Opcional)

ruby (Probarlo)
ruby on rails (Opcional)
Qt-Creator (Opcional)

##### Navegador Web Firefox #####

# apt-get install firefox-esr-l10n-es-es // Poner firefox en español
# apt-get install libreoffice-l10n-es // Poner el libreoffice en español
# apt-get install libreoffice-l10n-ve // Poner el libreoffice en español de venezuela

Adblock --> https://addons.mozilla.org/es/firefox/addon/adblock-plus/

Private Tab --> https://addons.mozilla.org/es/firefox/addon/private-tab/

Firebug --> https://addons.mozilla.org/es/firefox/addon/firebug/

Youtube Video Downloader --> https://addons.mozilla.org/es/firefox/addon/download-youtube/

Youtube - Ver videos mientras se leen comentarios --> https://addons.mozilla.org/es/firefox/addon/pop-up-play/

Save as PDF --> https://addons.mozilla.org/es/firefox/addon/save-as-pdf/

Google Translator for Firefox --> https://addons.mozilla.org/es/firefox/addon/google-translator-for-firefox/?src=userprofile ó
http://translatorforfirefox.blogspot.com/

######################
##### Virtualbox #####
######################

// Entrar en tty1 desde la máquina virtual, lo mismo para ttyn...
RightCtrl + F1

############################
##### Debian Backports #####
############################

Proporciona paquetes para nuevas versiones de determinadas aplicaciones que se van incluyendo a lo largo
del periodo de vida de la versión. Sin embargo desde el sitio oficial (http://backports.debian.org/Instructions/)
recomiendan utilizar este repositorio con precaución ya que en ocasiones pueden existir incompatibilidades
de dependencias entre estos paquetes y los estables. 

#################
##### bind9 #####
#################

El Nombre de Dominio de Internet de Berkeley (BIND) implementa un servidor de nombres de dominio de Internet.
BIND es el servidor de nombres más ampliamente utilizado en Internet, y tiene el
respaldo del Consorcio de «Software» de Internet, www.isc.org.
Este paquete proporciona el servidor y los archivos de configuración relacionados. 

// Instalación del paquete bind9
# apt-get install bind9 bind9-doc

// Editamos /etc/resolv.conf para que lea el localhost
nameserver 127.0.0.1

En /etc/bind están los archivos de configuración del paquete.

################
##### vlan #####
################

Una VLAN, acrónimo de virtual LAN (Red de área local virtual), es un método para crear redes lógicas
independientes dentro de una misma red física.

Varias VLAN pueden coexistir en un único conmutador físico o en una única red física. Son útiles para
reducir el tamaño del dominio de difusión y ayudan en la administración de la red, separando segmentos
lógicos de una red de área local (los departamentos de una empresa, por ejemplo) que no deberían
intercambiar datos usando la red local (aunque podrían hacerlo a través de un enrutador
o un conmutador de capa 3 y 4).

Una VLAN consiste en dos o más redes de computadoras que se comportan como si estuviesen conectados
al mismo conmutador, aunque se encuentren físicamente conectados a diferentes segmentos de una
red de área local (LAN). Los administradores de red configuran las VLAN mediante software en
lugar de hardware, lo que las hace extremadamente fuertes.

###############
##### vpn #####
###############

Una red privada virtual (en inglés: Virtual Private Network (VPN)) es una tecnología de red de computadoras que
permite una extensión segura de la red de área local (LAN) sobre una red pública o no controlada como Internet.

Permite que la computadora en la red envíe y reciba datos sobre redes compartidas o públicas como si fuera una
red privada con toda la funcionalidad, seguridad y políticas de gestión de una red privada.

Esto se realiza estableciendo una conexión virtual punto a punto mediante el uso de conexiones dedicadas, cifrado
o la combinación de ambos métodos.

Ejemplos comunes son la posibilidad de conectar dos o más sucursales de una empresa utilizando como vínculo Internet, permitir
a los miembros del equipo de soporte técnico la conexión desde su casa al centro de cómputo, o que un usuario pueda acceder
a su equipo doméstico desde un sitio remoto, como por ejemplo un hotel. Todo ello utilizando la infraestructura de Internet.

La conexión VPN a través de Internet es técnicamente una unión wide area network (WAN) entre los sitios pero al usuario le
parece como si fuera un enlace privado— de allí la designación "virtual private network".

###############################################
##### Desactivar actualización en firefox #####
###############################################

Probado en Firefox 55 o menor. 

La desactivación la podemos hacer desde la interfáz del navegador
pero para hacerla a nivel de codigo editamos el fichero:

firefox/defaults/pref/channel-prefs.js

Nos quedará así:

---

/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

/*pref("app.update.channel", "release");*/
pref("app.update.channel", "false");

---

Guardamos, reiniciamos el firefox y listo, actualizaciones desactivadas.

#################################
##### Reiniciar un servicio #####
#################################

Funcional para GNU/Linux Debian 7 Wheezy

user@debian7:~$ /etc/init.d/ssh 
force-reload  reload        restart       start         status        stop          try-restart   
user@debian7:~$ /etc/init.d/ssh restart

##### Copiar un imagen .iso en unidad USB #####

// Para hacerlo booteable, debe estar desmontado pero conectado en el puerto usb.

$ cat xxxx.iso > /dev/sdxxx ; sync

######################################################################
##### Instalar esto para porder descargar repositorios con https #####
######################################################################

# apt-get install apt-transport-https

#############################################################
##### Winetricks, Instalando librerias (DLLs) para Wine #####
#############################################################

Fuente: https://ubuntulife.wordpress.com/2008/10/16/winetricks-instalando-librerias-dlls-para-wine/

Wine es la aplicacion que generalmente empleamos para ejecutar aplicaciones de Windows en Linux, pero muchas veces, la aplicacion falla porque no tenemos una determinada libreria de enlace dinamico (DLL) instalada.
Winetricks es un script que nos va a ayudar un poco en esta faena, con este script podemos descargar e instalar en wine, las principales librerias que nos solicitan los programas windows.

Para instalarlo:

$ wget http://www.kegel.com/wine/winetricks

Le damos permisos de ejecucion:

$ chmod +x ./winetricks

Y si quisieramos ya instalar una determinada libreria, podriamos hacerlo directamente. Por ejemplo:

$ sh winetricks corefonts vcrun6

Para instalar unas fuentes de texto, y el runtime de VisualC.

Si lo ejecutamos sin parametros, se abre una ventana y nos permite seleccionar las librerias a instalar.

#################
##### xkill #####
#################

Probado en gnome-desktop

xkill permite formar el cierre de programas rebeldes desde la interfáz gráfica, con solo escribir
xkill en la consola el cursor del mouse se transforma en una calavera, acto seguido podemos cliquear
derecho sobre alguna ventana para matar ese proceso.

$ xkill

###############################
##### Instalar Unetbootin #####
###############################

UNetbootin le permite crear unidades USB Live de Ubuntu y otras distribuciones de Linux sin necesidad de grabar un CD.

Página para descarga: https://unetbootin.github.io/linux_download.html

// Podemos descargamos directamente el .bin, este enlace es para arquitecturas de 64bits
$ wget -c https://github.com/unetbootin/unetbootin/releases/download/657/unetbootin-linux64-657.bin

Eso nos descargara el fichero unetbootin-linux64-657.bin

// Instalamos lo siguiente, que son unas herramientas para manipular archivos MSDOS.
# apt-get install mtools

// Para correrlo
# ./unetbootin-linux64-657.bin

Listo, se nos debería ejecutar la ventana del programa.

##################################
##### Instalar Google Chrome #####
##################################

// Primero hay que añadir un repositorio de google en el  /etc/apt/sources.list, es el siguiente:

# Chrome de 64bits
deb [arch=amd64] http://dl.google.com/linux/chrome/deb/ stable main

// Ahora añadimos la llave pública del repositorio “Google Chrome stable” a apt.

# gpg --keyserver keys.gnupg.net --recv-key A040830F7FAC5991

# gpg --export --armor A040830F7FAC5991 | apt-key add -

// Actualizamos la lista de paquetes de los repositorios.

# apt-get update

// Si sale el siguiente error:

W: No existe ninguna clave pública disponible para los siguientes identificadores de clave:
1397BC53640DB551

// Ejecutamos los siguiente:

# wget -q -O - https://dl.google.com/linux/linux_signing_key.pub | apt-key add -

// Actualizamos la lista de paquetes de los repositorios.

# apt-get update

// Ahora instalamos Google Chrome stable con:

# apt-get install google-chrome-stable

// Si toda va bien, debería estar disponible en la sección internet de nuestro GNU/Linux Debian 8 o 9

###############################################
##### Instalar extensiones en LIbreOffice #####
###############################################

# apt-get install myspell-es // Este es el diccionario de español para usar con el corrector ortográfico myspell, que actualmente se usa en OpenOffice.org y el corrector ortográfico de mozilla. Al parecer con esto basta pero a mi no me funciono esa mierda, entonces hice lo siguiente:

Hay que bajarse un .oxt, investigarlo, luego en desde el LibreOffice

Herramientas > Gestor de extensiones > Buscar el .oxt descargado

En este caso lo he probado con spanish-dictionary.oxt que es la extensión para que funcione la correción de errores.

